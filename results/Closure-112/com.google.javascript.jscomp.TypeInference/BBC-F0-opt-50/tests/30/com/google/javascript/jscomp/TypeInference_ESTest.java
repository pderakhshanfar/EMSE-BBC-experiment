/*
 * This file was automatically generated by EvoSuite
 * Sat Oct 23 22:23:42 GMT 2021
 */

package com.google.javascript.jscomp;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSortedMap;
import com.google.javascript.jscomp.ClosureCodingConvention;
import com.google.javascript.jscomp.CodingConvention;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerOptions;
import com.google.javascript.jscomp.ControlFlowGraph;
import com.google.javascript.jscomp.GoogleCodingConvention;
import com.google.javascript.jscomp.JqueryCodingConvention;
import com.google.javascript.jscomp.LinkedFlowScope;
import com.google.javascript.jscomp.Scope;
import com.google.javascript.jscomp.SourceFile;
import com.google.javascript.jscomp.StatementFusion;
import com.google.javascript.jscomp.SyntacticScopeCreator;
import com.google.javascript.jscomp.TightenTypes;
import com.google.javascript.jscomp.TypeInference;
import com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.FlowScope;
import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;
import com.google.javascript.rhino.ErrorReporter;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.SimpleErrorReporter;
import com.google.javascript.rhino.jstype.BooleanLiteralSet;
import com.google.javascript.rhino.jstype.JSType;
import com.google.javascript.rhino.jstype.JSTypeNative;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import java.io.File;
import java.util.List;
import java.util.Map;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.mock.java.io.MockFile;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class TypeInference_ESTest extends TypeInference_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = compiler0.getJsRoot();
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertFalse(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.TRUE;
      // Undeclared exception!
      try { 
        TypeInference.getBooleanOutcomes((BooleanLiteralSet) null, booleanLiteralSet0, true);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node0 = new Node(38);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // NAME is not a string node
         //
         verifyException("com.google.javascript.rhino.Node", e);
      }
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(38);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // NAME is not a string node
         //
         verifyException("com.google.javascript.rhino.Node", e);
      }
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      TypeInference typeInference0 = null;
      try {
        typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, (Scope) null, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.Compiler", e);
      }
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("7YY> wW_4SJT");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = Node.newString(101, "", 135, 2642);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
      assertSame(booleanLiteralSet0, booleanLiteralSet1);
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = Node.newString(155, "/-AdeP0OE6ue1^jm", 1, 4636);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // CAST /-AdeP0OE6ue1^jm 1 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(154);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // STRING_KEY does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(152);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // DEBUGGER does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(151);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 151
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = Node.newString(150, "// Input %num%", 724, 161);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 150
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(148);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SETTER_DEF does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(147);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // GETTER_DEF does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("vu=CHjr/L,");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node0 = new Node(146);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 146
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention(jqueryCodingConvention0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(145);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrdeingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(144);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 144
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = Node.newString(143, "The separator may not be the empty string.", Integer.MIN_VALUE, 15);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 143
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("7YY> wW_4SJT");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = Node.newString(141, "", (-1694), 183);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 141
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrdeingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(140);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 140
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("vu=CHjr/L,");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(139, 112, 38);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 139
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("7YY> wW_4SJT");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = Node.newString(138, "8xMTce", 46, 172);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 138
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrdeingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = Node.newString(137, "8db 7w-8wIbiuc", 4, 8);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 137
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = Node.newString(136, "Suppliers.memoizeWithExpiration(", 57, 53);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 136
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(135);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 135
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrdeingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(134);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 134
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node0 = Node.newString(133, "HJl+G}Ny", 127, 33);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 133
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = compiler0.parseSyntheticCode("Object#Key", "OrderingK{explicit(");
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SCRIPT [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000001148] [input_id: com.google.javascript.rhino.Node$ObjectPropListItem@0000001149] does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention(closureCodingConvention0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(")(x");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("com.google.javascript.rhino.jstype.TernaryValue", codingConvention_AssertionFunctionSpec0, "z)d,9!nO{XA, Yw09p", codingConvention_AssertionFunctionSpec0, "JSC_INTERFACE_METHOD_OVERRIDE", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(129);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 129
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("7YY> wW_4SJT");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(128);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 128
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = Node.newString(126, "QWSi/i^FB", 29, 112);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LABEL QWSi/i^FB 29 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(124);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // EMPTY does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test32()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(123);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 123
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test33()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("7YY> wW_4SJT");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = Node.newString(122, "7YY> wW_4SJT", 54, 40);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // VOID 7YY> wW_4SJT 54 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test34()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(121);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 121
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test35()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node0 = Node.newString(119, "com.google.javascript.jscomp.TypeInference$1", (-960), 1);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // WITH com.google.javascript.jscomp.TypeInference$1 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test36()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("7YY> wW_4SJT");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = Node.newString(118, "/xZy>Yn7)d9v", 38, 4);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // VAR /xZy>Yn7)d9v 38 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test37()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = Node.newString(117, "", (-2060), (-437));
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // CONTINUE  does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test38()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("7YY> wW_4SJT");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      Node node0 = new Node(116);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // BREAK does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test39()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("7YY> wW_4SJT");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = Node.newString(114, "", (-1694), 183);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // DO  does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test40()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("7YY> wW_4SJT");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(113);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // WHILE does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test41()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(111);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // CASE does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test42()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(110);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test43()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("7YY> wW_4SJT");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(109);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 109
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test44()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = Node.newString(108, "", 4095, 15);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // IF  4095 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test45()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = Node.newString(107, "Yi/w[a$^~`1}\":Jl_U", 453, 122);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 107
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test46()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(99);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 99
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test47()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = Node.newString(94, "", (-853), 116);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // ASSIGN_SUB  : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test48()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("7YY> wW_4SJT");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = Node.newString(88, "", (-1668), 183);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // ASSIGN_BITXOR  : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test49()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null, false);
      JSType[] jSTypeArray0 = new JSType[1];
      Node node0 = jSTypeRegistry0.createParameters(jSTypeArray0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // PARAM_LIST : ? does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test50()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(81);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 81
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test51()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("vu=CHjr/L,");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node0 = new Node(80);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 80
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test52()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(78);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 78
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test53()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(70);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 70
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test54()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = Node.newString(59, "", 4095, 30);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 59
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test55()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(57);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 57
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test56()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(56);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 56
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test57()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("7YY> wW_4SJT");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node0 = new Node(55);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 55
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test58()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = Node.newString(54, "MX4lK`6v&|^;3!", 109, 5);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 54
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test59()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("|W*LPb!");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = Node.newString(53, "// Input %num%", 38, 152);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 53
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test60()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = Node.newString(52, "DarQxT<h", 775, (-27));
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // INSTANCEOF DarQxT<h : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test61()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(51);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // IN : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test62()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = Node.newString(50, "", 4095, 101);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 50
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test63()  throws Throwable  {
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("<Zq}U$g{TBqs:;ro", "M2>NWO2?-Qr};", "2i82N8BxDS0GQUG");
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      // Undeclared exception!
      try { 
        compiler0.parseInputs();
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Multiple entries with same key: author=NOT_IMPLEMENTED and author=AUTHOR
         //
         verifyException("com.google.common.collect.ImmutableMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test64()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      compiler0.computeCFG();
      JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null, jSTypeNative0);
      ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("", codingConvention_AssertionFunctionSpec0, "", codingConvention_AssertionFunctionSpec0, "cQg668.", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = Node.newString(48, "", (-2527), 12);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 48
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test65()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("7YY> wW_4SJT");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = Node.newString(32, "", 47, (-31));
      Node node1 = new Node(47, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // REGEXP does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test66()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      JSTypeNative jSTypeNative0 = JSTypeNative.UNKNOWN_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null, jSTypeNative0);
      ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("", codingConvention_AssertionFunctionSpec0, "", codingConvention_AssertionFunctionSpec0, "cQg668.", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(46);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SHNE : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test67()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(45);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SHEQ : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test68()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(43);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // FALSE does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test69()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("7YY> wW_4SJT");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = Node.newString(42, "", (-447), (-532));
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // THIS  does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test70()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = Node.newString("2", 2532, (-8));
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // STRING 2 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test71()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = Node.newString(39, "", 33, 1283);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // NUMBER  33 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test72()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(32);
      Node node1 = Node.newString(38, "verbose:pretty:all", (-557), 47);
      Node node2 = StatementFusion.fuseExpressionIntoExpression(node1, node0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // COMMA : string does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test73()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = Node.newString(37, "", 16, 145);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test74()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(36);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test75()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(35);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test76()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("vu=CHjr/L,");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = Node.newString(34, "com.google.javascript.jscomp.TypeInference", 150, 1);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 34
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test77()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = Node.newString(31, "d[_(; !W(", 109, 112);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // DELPROP d[_(; !W( 109 : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test78()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(30);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test79()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("7YY> wW_4SJT");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(29);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test80()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrdeingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(19);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // RSH : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test81()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(16);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // GT : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test82()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = Node.newString(15, "// Input %num%", 110, 152);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LE // Input %num% 110 : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test83()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(12);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // EQ : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test84()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(9);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // BITOR : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test85()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = Node.newString(8, "// Input %num%", 55, (-693));
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 8
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test86()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("7YY> wW_4SJT");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(5);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 5
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test87()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(4);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // RETURN does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test88()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      MockFile mockFile0 = new MockFile("NON_TOP_LEVEL_STATEMENT_DEFINE", "NON_TOP_LEVEL_STATEMENT_DEFINE");
      SourceFile sourceFile0 = SourceFile.fromFile((File) mockFile0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
      List<FlowScope> list0 = typeInference0.branchedFlowThrough((Node) null, flowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test89()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(100);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test90()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrdeingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      typeInference0.analyze(140);
  }

  @Test(timeout = 4000)
  public void test91()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      assertNotNull(flowScope0);
  }

  @Test(timeout = 4000)
  public void test92()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("vu=CHjr/L,");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node0 = new Node(63);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // ARRAYLIT : Array does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test93()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = new Node(33);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test94()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("OrderingK{explicit(");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler0 = new Compiler();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      compiler0.parseInputs();
      Scope scope0 = SyntacticScopeCreator.generateUntypedTopScope(compiler0);
      ControlFlowGraph<Node> controlFlowGraph0 = compiler0.computeCFG();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node0 = Node.newString((-1524), "prototype", (-2078), 107);
      Node node1 = new Node(101, node0, 2, 1443);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }
}
