/*
 * This file was automatically generated by EvoSuite
 * Tue Oct 12 10:32:20 GMT 2021
 */

package com.google.javascript.jscomp;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.common.collect.ImmutableSortedMap;
import com.google.javascript.jscomp.ClosureCodingConvention;
import com.google.javascript.jscomp.CodingConvention;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerInput;
import com.google.javascript.jscomp.ControlFlowGraph;
import com.google.javascript.jscomp.GoogleCodingConvention;
import com.google.javascript.jscomp.JqueryCodingConvention;
import com.google.javascript.jscomp.LinkedFlowScope;
import com.google.javascript.jscomp.LoggerErrorManager;
import com.google.javascript.jscomp.Scope;
import com.google.javascript.jscomp.SourceFile;
import com.google.javascript.jscomp.Tracer;
import com.google.javascript.jscomp.TypeInference;
import com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.FlowScope;
import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.SimpleErrorReporter;
import com.google.javascript.rhino.jstype.BooleanLiteralSet;
import com.google.javascript.rhino.jstype.JSType;
import com.google.javascript.rhino.jstype.JSTypeNative;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import java.util.List;
import java.util.Map;
import java.util.logging.Logger;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class TypeInference_ESTest extends TypeInference_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test000()  throws Throwable  {
      Node node0 = Node.newString("H6ri0i%l", (-346), (-346));
      SourceFile sourceFile0 = SourceFile.fromFile("H6ri0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(2, node1, node1, node1, node1);
      Scope scope0 = Scope.createLatticeBottom(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node3 = new Node(93, node2, 93, 15);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node3, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test001()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      // Undeclared exception!
      try { 
        TypeInference.getBooleanOutcomes(booleanLiteralSet0, (BooleanLiteralSet) null, false);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test002()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("Oh");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node0 = compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(125, node0, node0, node0, 12, 55);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, (FlowScope) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test003()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Logger logger0 = Tracer.logger;
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Node.newString("Object#Key");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = null;
      try {
        typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, (Scope) null, immutableSortedMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.Compiler", e);
      }
  }

  @Test(timeout = 4000)
  public void test004()  throws Throwable  {
      Node node0 = Node.newString("+_`I:CN");
      SourceFile sourceFile0 = SourceFile.fromFile("+_`I:CN");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(52, node0, node1, node1, 0, 16);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test005()  throws Throwable  {
      Node node0 = new Node(97, 97, 97);
      SourceFile sourceFile0 = SourceFile.fromFile("// Input %num%");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(15, node0, 37, 32);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test006()  throws Throwable  {
      Node node0 = Node.newString("H6^ri0i%l", 767, 767);
      SourceFile sourceFile0 = SourceFile.fromFile("H6^ri0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(118, node0, node1, node1, 0, 16);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test007()  throws Throwable  {
      Node node0 = Node.newString("Y#7aLHD", 799, 799);
      SourceFile sourceFile0 = SourceFile.fromFile("Y#7aLHD");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(95, node0, node1, node1, 0, 16);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test008()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("Oh");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node0 = compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(125, node0, node0, node0, 12, 55);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test009()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("Y#7aLHD");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node0 = compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(46, node0, node0, node0, 2668, 767);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test010()  throws Throwable  {
      Node node0 = Node.newString(780, "H6ri0i%l", 780, 780);
      SourceFile sourceFile0 = SourceFile.fromFile("H6ri0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(101, node0, node1, node1, 0, 16);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node2, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test011()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("// Input %num%");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node0 = compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(135, node0, node0, node0, 12, 55);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      Node node2 = new Node(19, node1);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // RSH : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test012()  throws Throwable  {
      Node node0 = Node.newString("Y#7aLHD", 767, 767);
      SourceFile sourceFile0 = SourceFile.fromFile("Y#7aLHD");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(106, node0, node1, node1, 0, 16);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test013()  throws Throwable  {
      Node node0 = Node.newString(773, "H6ri0i%l", 773, 773);
      SourceFile sourceFile0 = SourceFile.fromFile("H6ri0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(56, node0, node0, node0, 37, 57);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test014()  throws Throwable  {
      Node node0 = Node.newString(773, "H6ri0i%l", 773, 773);
      SourceFile sourceFile0 = SourceFile.fromFile("H6ri0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(47, node1, node1, node0, 3, 49);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test015()  throws Throwable  {
      Node node0 = Node.newString("Y#7aLHD", 799, 799);
      SourceFile sourceFile0 = SourceFile.fromFile("Y#7aLHD");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(151, node0, node1, node1, 0, 16);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test016()  throws Throwable  {
      Node node0 = new Node((-381), (-381), (-381));
      SourceFile sourceFile0 = SourceFile.fromFile("H6ri0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(16, node0);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(37, node1, 47, 122);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node2, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test017()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
      assertSame(booleanLiteralSet1, booleanLiteralSet0);
  }

  @Test(timeout = 4000)
  public void test018()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, true);
      assertSame(booleanLiteralSet0, booleanLiteralSet1);
  }

  @Test(timeout = 4000)
  public void test019()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("// Input %num%");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node0 = compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(125, node0, node0, node0, 12, 55);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      Node node2 = new Node(35, node1);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test020()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("// Input %num%");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node0 = compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(29, node0, node0, node0, 12, 55);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node2 = new Node(30, node1);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test021()  throws Throwable  {
      Node node0 = Node.newString("Y#7aLHD", 799, 799);
      SourceFile sourceFile0 = SourceFile.fromFile("Y#7aLHD");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(120, node0, node1, node1, 0, 16);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node2, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test022()  throws Throwable  {
      Node node0 = new Node(728, 728, 728);
      SourceFile sourceFile0 = SourceFile.fromFile("O");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(155, node0, node0, node1, 129, 15);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("");
      Node node3 = codingConvention_AssertionFunctionSpec0.getAssertedParam(node2);
      FlowScope flowScope0 = typeInference0.flowThrough(node3, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test023()  throws Throwable  {
      Node node0 = new Node(71);
      SourceFile sourceFile0 = SourceFile.fromFile("// Input %num%");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(150, node0, node1, node1, 39, 42);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node3 = new Node(154, node2);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node3, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // STRING_KEY does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test024()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("H6ri0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      compilerInput0.getAstRoot(compiler0);
      Node node0 = new Node(153, 126, 32);
      Node node1 = new Node(36, node0);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test025()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("checkVars");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node0 = compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(152, node0);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test026()  throws Throwable  {
      Node node0 = new Node(71);
      SourceFile sourceFile0 = SourceFile.fromFile("// Input %num%");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(150, node0, node1, node1, 39, 42);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test027()  throws Throwable  {
      Node node0 = Node.newString("InxYA`p)S", 773, (-4087));
      SourceFile sourceFile0 = SourceFile.fromFile("gyn");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(15, node0, 37, 32);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node3 = new Node(149, node1);
      FlowScope flowScope0 = typeInference0.flowThrough(node3, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test028()  throws Throwable  {
      Node node0 = new Node(767, 767, 767);
      SourceFile sourceFile0 = SourceFile.fromFile("Oh");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(148, node1, node1, node1, 31, 115);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test029()  throws Throwable  {
      Node node0 = new Node(767);
      SourceFile sourceFile0 = SourceFile.fromFile("Oh");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(55, node0, node0, node1, 42, (-869));
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node3 = new Node(147, node2);
      FlowScope flowScope0 = typeInference0.flowThrough(node3, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test030()  throws Throwable  {
      Node node0 = Node.newString(780, "H6ri0i%l", 780, 780);
      SourceFile sourceFile0 = SourceFile.fromFile("H6ri0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(146, node0, node1, node1, 0, 16);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test031()  throws Throwable  {
      Node node0 = Node.newString(">N[^(^F", 773, 773);
      SourceFile sourceFile0 = SourceFile.fromFile("// Input %num%");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(15, node0, 37, 32);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node3 = new Node(145, node1);
      FlowScope flowScope0 = typeInference0.flowThrough(node3, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test032()  throws Throwable  {
      Node node0 = Node.newString("H6ri0o%l", 767, 767);
      SourceFile sourceFile0 = SourceFile.fromFile("Oh");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(144, node0, node0, node1, (-45), (-869));
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test033()  throws Throwable  {
      Node node0 = Node.newString("H6ri0i%l", 767, 767);
      SourceFile sourceFile0 = SourceFile.fromFile("H6ri0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(143, node1, node1, node0, 3099, 29);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      CodingConvention codingConvention0 = compiler0.getCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(codingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test034()  throws Throwable  {
      Node node0 = Node.newString("H6ri0i%l", 767, 767);
      SourceFile sourceFile0 = SourceFile.fromFile("Ih");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(142, node0, node0, node1, (-45), (-869));
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test035()  throws Throwable  {
      Node node0 = Node.newString("H6ri0i%l", 767, 767);
      SourceFile sourceFile0 = SourceFile.fromFile("// Input %num%");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(141, node0, node1, node1, 5069, (-2272));
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test036()  throws Throwable  {
      Node node0 = new Node(767);
      SourceFile sourceFile0 = SourceFile.fromFile("Oh");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(55, node0, node0, node1, 42, 12);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node3 = new Node(140, node2);
      FlowScope flowScope0 = typeInference0.flowThrough(node3, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test037()  throws Throwable  {
      Node node0 = Node.newString("H6ri0i%l", 767, 767);
      SourceFile sourceFile0 = SourceFile.fromFile("H6ri0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(139, node0, node1, node1, 0, 16);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test038()  throws Throwable  {
      Node node0 = Node.newString("Y#7aLH0", 767, 767);
      SourceFile sourceFile0 = SourceFile.fromFile("Y#7aLH0");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(138, node0, node1, node1, 0, 16);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test039()  throws Throwable  {
      Node node0 = Node.newString("H6ri0i%l", 767, 767);
      SourceFile sourceFile0 = SourceFile.fromFile("Oh");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(137, node0, node0, node1, 122, 15);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, false, true);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test040()  throws Throwable  {
      Node node0 = new Node(728, 728, 728);
      SourceFile sourceFile0 = SourceFile.fromFile("x/#Yc+|X:JF;M3C");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(134, node0, node0, node1, 129, 15);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, true, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test041()  throws Throwable  {
      Node node0 = new Node(767, 767, 767);
      SourceFile sourceFile0 = SourceFile.fromFile("Oh");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(133, node0, node0, node1, 38, (-903));
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test042()  throws Throwable  {
      Node node0 = Node.newString(797, "H6ri0i%l", 797, 797);
      SourceFile sourceFile0 = SourceFile.fromFile("H6ri0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(117, node0, node1, node1, 0, 16);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node3 = new Node(131, node2, 55, 30);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      FlowScope flowScope0 = typeInference0.flowThrough(node3, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test043()  throws Throwable  {
      Node node0 = Node.newString(">N[^(^F", 773, 773);
      SourceFile sourceFile0 = SourceFile.fromFile("// Input %num%");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(15, node0, 37, 32);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node3 = new Node(130, node1);
      FlowScope flowScope0 = typeInference0.flowThrough(node3, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test044()  throws Throwable  {
      Node node0 = Node.newString("H6ri0i%l");
      SourceFile sourceFile0 = SourceFile.fromFile("H6ri0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(129, node0, node1, node1, 0, 16);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test045()  throws Throwable  {
      Node node0 = Node.newString(780, "H6ri0i%l", 780, 780);
      SourceFile sourceFile0 = SourceFile.fromFile("H6ri0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(128, node0, node1, node1, 0, 16);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node2, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test046()  throws Throwable  {
      Node node0 = Node.newString("YeR#7aLHD", 767, 767);
      SourceFile sourceFile0 = SourceFile.fromFile("YeR#7aLHD");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(127, node0, node1, node1, 0, 16);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test047()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("Y#7aLHD");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node0 = compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(46, node0);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      Node node2 = new Node(126, node1, 4095, 31);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test048()  throws Throwable  {
      Node node0 = Node.newString("Y#7aLHD", 767, 767);
      SourceFile sourceFile0 = SourceFile.fromFile("Y#7aLHD");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(122, node0, node1, node1, 0, 16);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, true, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test049()  throws Throwable  {
      Node node0 = new Node((-381), (-381), (-381));
      SourceFile sourceFile0 = SourceFile.fromFile("H6ri0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(16, node0);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(121, node1, 121, 15);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test050()  throws Throwable  {
      Node node0 = Node.newString(767, "Y#7aLHD", 767, 767);
      SourceFile sourceFile0 = SourceFile.fromFile("Y#7aLHD");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(119, node0, node1, node1, 0, 16);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test051()  throws Throwable  {
      Node node0 = Node.newString("H6ri0i%l", 767, 767);
      SourceFile sourceFile0 = SourceFile.fromFile("H6ri0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(117, node0, node1, node1, 960, 16);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test052()  throws Throwable  {
      Node node0 = Node.newString((-346), "H6ri0i%l");
      SourceFile sourceFile0 = SourceFile.fromFile("H6ri0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(2, node1, node1, node1, node1);
      Scope scope0 = Scope.createLatticeBottom(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node3 = new Node(116, node2, 116, 15);
      FlowScope flowScope0 = typeInference0.flowThrough(node3, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test053()  throws Throwable  {
      Node node0 = new Node(773, 773, 773);
      SourceFile sourceFile0 = SourceFile.fromFile("JRw-v}fA u");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(115, node0);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, true);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test054()  throws Throwable  {
      Node node0 = Node.newString(782, "InxYA`p)S", 782, (-4087));
      SourceFile sourceFile0 = SourceFile.fromFile("~6W");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(31, node0, node0, node0, 2, 42);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node3 = new Node(114, node1);
      FlowScope flowScope0 = typeInference0.flowThrough(node3, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test055()  throws Throwable  {
      Node node0 = Node.newString(773, "InxYA`p)S", 773, (-4087));
      SourceFile sourceFile0 = SourceFile.fromFile("gyn");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(31, node0, node0, node0, (-2321), 42);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node3 = new Node(113, node1);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node3, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // WHILE does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test056()  throws Throwable  {
      Node node0 = Node.newString((-828), "Y#7aHD", (-828), (-828));
      SourceFile sourceFile0 = SourceFile.fromFile("Y#7aHD");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(112, node0, node1, node1, 0, 12);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test057()  throws Throwable  {
      Node node0 = Node.newString("H6ri0o%l", 767, 767);
      SourceFile sourceFile0 = SourceFile.fromFile("Oh");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(111, node0, node0, node1, 38, (-903));
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test058()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("Y#7aLHD");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node0 = compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(46, node0);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      Node node2 = new Node(110, node1, 4095, 31);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test059()  throws Throwable  {
      Node node0 = Node.newString("H6ri0i%l");
      SourceFile sourceFile0 = SourceFile.fromFile("H6ri0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(109, node0, node1, node1, 0, 16);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test060()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("// Input %num%");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node0 = compilerInput0.getAstRoot(compiler0);
      Node[] nodeArray0 = new Node[0];
      Node node1 = new Node(108, nodeArray0, 2804, 810);
      Node node2 = new Node(4, node0, node1, node0, 38, 706);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, true, false);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, (JSTypeRegistry) null);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test061()  throws Throwable  {
      Node node0 = new Node(107, 107, 107);
      SourceFile sourceFile0 = SourceFile.fromFile("6Ge");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(15, node0, 37, 32);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LE 37 : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test062()  throws Throwable  {
      Node node0 = Node.newString(106, "H6ri0i%l", 120, 4);
      SourceFile sourceFile0 = SourceFile.fromFile("H6ri0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(15, node1, node0, node0, 124, 97);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, true);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test063()  throws Throwable  {
      Node node0 = Node.newString((-828), "Y#7aHD", (-828), (-828));
      SourceFile sourceFile0 = SourceFile.fromFile("Y#7aHD");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(105, node0, node1, node1, 0, 12);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test064()  throws Throwable  {
      Node node0 = Node.newString("Y#7aHD", (-828), (-828));
      SourceFile sourceFile0 = SourceFile.fromFile("Y#7aHD");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(102, node0, node1, node1, 0, 16);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test065()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("// Input %num%");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node0 = compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(99, node0);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test066()  throws Throwable  {
      Node node0 = Node.newString("Y#7aLHD", 767, 767);
      SourceFile sourceFile0 = SourceFile.fromFile("Y#7aLHD");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(37, node0, node0, node0, node0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, true, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(93, 15, 145);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node2, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test067()  throws Throwable  {
      Node node0 = new Node((-346), (-346), (-346));
      SourceFile sourceFile0 = SourceFile.fromFile("H6ri0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(2, node1, node1, node1, node1);
      Scope scope0 = Scope.createLatticeBottom(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node3 = new Node(92, node2, 92, 15);
      FlowScope flowScope0 = typeInference0.flowThrough(node3, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test068()  throws Throwable  {
      Node node0 = new Node(90);
      SourceFile sourceFile0 = SourceFile.fromFile("6Ge");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(15, node0, 37, 32);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node0, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test069()  throws Throwable  {
      Node node0 = Node.newString("Y#7aLHD", 767, 767);
      SourceFile sourceFile0 = SourceFile.fromFile("Y#7aLHD");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(118, node0, node1, node1, 0, 16);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      Node node3 = new Node(87, node2, (-524), 143);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node3, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test070()  throws Throwable  {
      Node node0 = new Node(767);
      SourceFile sourceFile0 = SourceFile.fromFile("Oh");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(85, node1, node0, node1, 4, (-342));
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, true, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test071()  throws Throwable  {
      Node node0 = new Node((-381), (-381), (-381));
      SourceFile sourceFile0 = SourceFile.fromFile("H6ri0N%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(16, node0);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(84, node1, 84, 15);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test072()  throws Throwable  {
      Node node0 = Node.newString("H6ri0i%E!Al", (-254), (-254));
      SourceFile sourceFile0 = SourceFile.fromFile("// Input %num%");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(68, node0, node0, node1, (-45), (-254));
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      JSType[] jSTypeArray0 = new JSType[1];
      Node node3 = jSTypeRegistry0.createParameters(jSTypeArray0);
      FlowScope flowScope0 = typeInference0.flowThrough(node3, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test073()  throws Throwable  {
      Node node0 = new Node(79);
      SourceFile sourceFile0 = SourceFile.fromFile("// Input %num%");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(15, node0, 37, 32);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, true, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test074()  throws Throwable  {
      Node node0 = new Node(78, 78, 78);
      SourceFile sourceFile0 = SourceFile.fromFile("// Input %num%");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(15, node0, 37, 32);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test075()  throws Throwable  {
      Node node0 = new Node(76);
      SourceFile sourceFile0 = SourceFile.fromFile("// Input %num%");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(15, node0, 37, 32);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test076()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("Y#7aLHD");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node0 = compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(74, node0, 38, 32);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, true);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test077()  throws Throwable  {
      Node node0 = Node.newString("H6ri0i%l");
      SourceFile sourceFile0 = SourceFile.fromFile("H6ri0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(73, node0, node1, node1, 0, 16);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test078()  throws Throwable  {
      Node node0 = new Node(72, 72, 72);
      SourceFile sourceFile0 = SourceFile.fromFile("// Input %num%");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(15, node0, 37, 32);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test079()  throws Throwable  {
      Node node0 = new Node(71);
      SourceFile sourceFile0 = SourceFile.fromFile("6Ge");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(15, node0, 37, 32);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test080()  throws Throwable  {
      Node node0 = Node.newString("H6ri0i%l", 767, 767);
      SourceFile sourceFile0 = SourceFile.fromFile("// Input %num%");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(68, node0, node0, node1, (-45), (-869));
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test081()  throws Throwable  {
      Node node0 = Node.newString("H6ri0i%l", 767, 767);
      SourceFile sourceFile0 = SourceFile.fromFile("Oh");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(65, node0, node0, node1, (-45), (-869));
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test082()  throws Throwable  {
      Node node0 = new Node((-381), (-381), (-381));
      SourceFile sourceFile0 = SourceFile.fromFile("H6ri0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(16, node0);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node3 = new Node(57, node1, (-1621), 101);
      FlowScope flowScope0 = typeInference0.flowThrough(node3, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test083()  throws Throwable  {
      Node node0 = new Node(767);
      SourceFile sourceFile0 = SourceFile.fromFile("Oh");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(55, node0, node0, node1, 42, (-869));
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test084()  throws Throwable  {
      Node node0 = Node.newString((-385), "H6ri0i%l", (-385), (-385));
      SourceFile sourceFile0 = SourceFile.fromFile("H6ri0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(16, node0);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      Node node2 = new Node(54, node1, 667, 675);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 54
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test085()  throws Throwable  {
      Node node0 = new Node((-381), (-381), (-381));
      SourceFile sourceFile0 = SourceFile.fromFile("H6ri0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(16, node0);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(53);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test086()  throws Throwable  {
      Node node0 = new Node(773);
      Node node1 = Node.newString("prototype");
      SourceFile sourceFile0 = SourceFile.fromFile("gyn");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(15, node0, 4, 32);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, true);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node3 = new Node(51, node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      FlowScope flowScope0 = typeInference0.flowThrough(node3, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test087()  throws Throwable  {
      Node node0 = new Node(767);
      SourceFile sourceFile0 = SourceFile.fromFile("H6i0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(2, node0, node0, node0, 250, 36);
      Scope scope0 = Scope.createLatticeBottom(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      Node node3 = new Node(50, node2);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node3, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test088()  throws Throwable  {
      Node node0 = new Node((-381), (-381), (-381));
      SourceFile sourceFile0 = SourceFile.fromFile("H6ri0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(16, node0);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(49, 31, 1);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test089()  throws Throwable  {
      Node node0 = new Node((-381), (-381), (-381));
      SourceFile sourceFile0 = SourceFile.fromFile("H6ri0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(47, node1, node1, node0, 38, 49);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, false, false);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(googleCodingConvention0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node3 = new Node(48, node2);
      FlowScope flowScope0 = typeInference0.flowThrough(node3, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test090()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("H6ri0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node0 = compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(2137, node0);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, true, true);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(43, node1);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test091()  throws Throwable  {
      Node node0 = new Node(773);
      Node node1 = Node.newString("prototype");
      SourceFile sourceFile0 = SourceFile.fromFile("gyn");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(15, node0, 37, 32);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node3 = new Node(42, node1);
      FlowScope flowScope0 = typeInference0.flowThrough(node3, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test092()  throws Throwable  {
      Node node0 = Node.newString("H6ri0i%l", 767, 767);
      SourceFile sourceFile0 = SourceFile.fromFile("Ih");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(142, node0, node0, node1, (-45), (-869));
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node3 = Node.newNumber((double) 0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node3, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // NUMBER 0.0 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test093()  throws Throwable  {
      Node node0 = new Node((-417), (-417), (-417));
      SourceFile sourceFile0 = SourceFile.fromFile("H6ri0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(16, node0);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node3 = new Node(38, node1, 56, 56);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node3, linkedFlowScope0);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // NAME 56 is not a string node
         //
         verifyException("com.google.javascript.rhino.Node", e);
      }
  }

  @Test(timeout = 4000)
  public void test094()  throws Throwable  {
      Node node0 = Node.newString("Y#7aLHD", 767, 767);
      SourceFile sourceFile0 = SourceFile.fromFile("Y#7aLHD");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(37, node0, node1, node1, 0, 16);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      JSTypeNative jSTypeNative0 = JSTypeNative.FUNCTION_INSTANCE_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null, jSTypeNative0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("", codingConvention_AssertionFunctionSpec0, "CW*Ejh]", codingConvention_AssertionFunctionSpec0, "// Input %num%", codingConvention_AssertionFunctionSpec0, "Y#7aLHD", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test095()  throws Throwable  {
      Node node0 = new Node((-381), (-381), (-381));
      SourceFile sourceFile0 = SourceFile.fromFile("H6ri0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(47, node1, node1, node0, 38, 49);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node3 = new Node(36, node2, 148, 114);
      FlowScope flowScope0 = typeInference0.flowThrough(node3, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test096()  throws Throwable  {
      Node node0 = Node.newString((-377), "H6ri0i%l", (-377), (-377));
      SourceFile sourceFile0 = SourceFile.fromFile("H6ri0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(16, node0);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node3 = new Node(34, node1, 55, 16);
      FlowScope flowScope0 = typeInference0.flowThrough(node3, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test097()  throws Throwable  {
      Node node0 = new Node(767, 767, 767);
      SourceFile sourceFile0 = SourceFile.fromFile("H6ri0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(47, node1, node1, node0, 38, 49);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node3 = new Node(32, node2);
      FlowScope flowScope0 = typeInference0.flowThrough(node3, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test098()  throws Throwable  {
      Node node0 = Node.newString("InxYA`p)S", 773, (-4087));
      SourceFile sourceFile0 = SourceFile.fromFile("gyn");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(31, node0, node0, node0, (-2321), 42);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test099()  throws Throwable  {
      Node node0 = Node.newString("H6ri0i%l", 767, 767);
      SourceFile sourceFile0 = SourceFile.fromFile("H6ri0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(30, node1, node0, node1, 51, 48);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test100()  throws Throwable  {
      Node node0 = Node.newString("Y#7aLHD", 799, 799);
      SourceFile sourceFile0 = SourceFile.fromFile("Y#7aLHD");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(95, node0, node1, node1, 0, 16);
      Scope scope0 = Scope.createGlobalScope(node2);
      Node node3 = new Node(29, node2, 150, 799);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      FlowScope flowScope0 = typeInference0.flowThrough(node3, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test101()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("// Input %num%");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node0 = compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(125, node0, node0, node0, 12, 55);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      Node node2 = new Node(26, node1);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test102()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("// Input %num%");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node0 = compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(135, node0, node0, node0, 12, 55);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      Node node2 = new Node(19, node1);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test103()  throws Throwable  {
      Node node0 = new Node((-381), (-381), (-381));
      SourceFile sourceFile0 = SourceFile.fromFile("H6ri0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(16, node0);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test104()  throws Throwable  {
      Node node0 = Node.newString((-346), "NIqH6ril0i%l", (-346), (-346));
      SourceFile sourceFile0 = SourceFile.fromFile("NIqH6ril0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(2, node1, node1, node1, node1);
      Scope scope0 = Scope.createLatticeBottom(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node3 = new Node(13, node0);
      FlowScope flowScope0 = typeInference0.flowThrough(node3, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test105()  throws Throwable  {
      Node node0 = Node.newString(773, "H6ri0i%l", 773, 773);
      SourceFile sourceFile0 = SourceFile.fromFile("H6ri0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(56, node0, node0, node0, 37, 57);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      Scope scope0 = Scope.createGlobalScope(node2);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      Node node3 = new Node(12, node2);
      FlowScope flowScope1 = typeInference0.flowThrough(node3, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test106()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("// Input %num%");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node0 = compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(125, node0, node0, node0, 12, 55);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      Node node2 = new Node(10, node1);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test107()  throws Throwable  {
      Node node0 = Node.newString(797, "H6ri0i%l", 797, 797);
      SourceFile sourceFile0 = SourceFile.fromFile("H6ri0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(4, node1, node0, node1, 50, 42);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test108()  throws Throwable  {
      Node node0 = Node.newString("+_wI:C3");
      SourceFile sourceFile0 = SourceFile.fromFile("+_wI:C3");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(8, node0, node0, node1, (-55), 8);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_FALSE;
      controlFlowGraph0.connectToImplicitReturn(node2, controlFlowGraph_Branch0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 8
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test109()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("Y#7aLHD");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node0 = compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(46, node0, node0, node0, 2668, 767);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.UNCOND;
      controlFlowGraph0.connect(node1, controlFlowGraph_Branch0, (Node) null);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
      assertFalse(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test110()  throws Throwable  {
      Node node0 = Node.newString(">N[^(^F", 773, 773);
      SourceFile sourceFile0 = SourceFile.fromFile("// Input %num%");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(15, node0, 37, 32);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_TRUE;
      controlFlowGraph0.connectToImplicitReturn(node0, controlFlowGraph_Branch0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // STRING >N[^(^F 773 does not have a condition.
         //
         verifyException("com.google.javascript.jscomp.NodeUtil", e);
      }
  }

  @Test(timeout = 4000)
  public void test111()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("H6ri0i%l");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node0 = compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(2137, node0);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, true, true);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node0, flowScope0);
      assertSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test112()  throws Throwable  {
      Node node0 = Node.newString("Y#7aLHD", 767, 767);
      SourceFile sourceFile0 = SourceFile.fromFile("Y#7aLHD");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node1 = compilerInput0.getAstRoot(compiler0);
      Node node2 = new Node(151, node0, node1, node1, 0, 16);
      Scope scope0 = Scope.createGlobalScope(node2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      Node node3 = new Node(100, node2, (-524), 143);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node3, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test113()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("// Input %num%");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node0 = compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(86, node0);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test114()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("// Input %num%");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node0 = compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(33, node0, node0, node0, 12, 55);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      Node node2 = new Node(35, node1);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node2, linkedFlowScope0);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // SCRIPT [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000000201] [input_id: com.google.javascript.rhino.Node$ObjectPropListItem@0000000202] is not a string node
         //
         verifyException("com.google.javascript.rhino.Node", e);
      }
  }

  @Test(timeout = 4000)
  public void test115()  throws Throwable  {
      SourceFile sourceFile0 = SourceFile.fromFile("// Input %num%");
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Compiler compiler0 = new Compiler();
      Node node0 = compilerInput0.getAstRoot(compiler0);
      Node node1 = new Node(15, node0, node0, node0, 1487, (-954));
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      Node node2 = new Node(101, node1);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node2, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }
}
