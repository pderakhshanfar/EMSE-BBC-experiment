/*
 * This file was automatically generated by EvoSuite
 * Wed Oct 13 17:56:11 GMT 2021
 */

package com.google.javascript.jscomp;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.common.collect.ImmutableSortedMap;
import com.google.javascript.jscomp.AbstractCompiler;
import com.google.javascript.jscomp.CleanupPasses;
import com.google.javascript.jscomp.ClosureCodingConvention;
import com.google.javascript.jscomp.CodingConvention;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerOptions;
import com.google.javascript.jscomp.ControlFlowAnalysis;
import com.google.javascript.jscomp.ControlFlowGraph;
import com.google.javascript.jscomp.DefaultPassConfig;
import com.google.javascript.jscomp.ExploitAssigns;
import com.google.javascript.jscomp.GoogleCodingConvention;
import com.google.javascript.jscomp.JqueryCodingConvention;
import com.google.javascript.jscomp.LightweightMessageFormatter;
import com.google.javascript.jscomp.LinkedFlowScope;
import com.google.javascript.jscomp.LoggerErrorManager;
import com.google.javascript.jscomp.Normalize;
import com.google.javascript.jscomp.PassConfig;
import com.google.javascript.jscomp.PrintStreamErrorManager;
import com.google.javascript.jscomp.Scope;
import com.google.javascript.jscomp.TightenTypes;
import com.google.javascript.jscomp.Tracer;
import com.google.javascript.jscomp.TypeInference;
import com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.FlowScope;
import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;
import com.google.javascript.rhino.ErrorReporter;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.SimpleErrorReporter;
import com.google.javascript.rhino.jstype.BooleanLiteralSet;
import com.google.javascript.rhino.jstype.JSTypeNative;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Filter;
import java.util.logging.Logger;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.System;
import org.evosuite.runtime.mock.java.io.MockFile;
import org.evosuite.runtime.mock.java.io.MockPrintStream;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class TypeInference_ESTest extends TypeInference_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      LightweightMessageFormatter lightweightMessageFormatter0 = LightweightMessageFormatter.withoutSource();
      FileSystemHandling.shouldAllThrowIOExceptions();
      Logger logger0 = Logger.getLogger("");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(lightweightMessageFormatter0, logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "");
      Node.newString("2uvg sYKI@VOiDe^^", 40, (-3607));
      Node node1 = new Node(101, node0, node0, 54, 14);
      Scope scope0 = Scope.createLatticeBottom(node1);
      HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, true, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, closureReverseAbstractInterpreter0, scope0, hashMap0);
      typeInference0.createEntryLattice();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      typeInference0.flowThrough(node1, flowScope0);
      typeInference0.createInitialEstimateLattice();
      System.setCurrentTimeMillis(347L);
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      LightweightMessageFormatter lightweightMessageFormatter0 = LightweightMessageFormatter.withoutSource();
      FileSystemHandling.shouldAllThrowIOExceptions();
      Logger logger0 = Logger.getLogger("-XyOt7cpT;a");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(lightweightMessageFormatter0, logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "-XyOt7cpT;a");
      Node node1 = new Node(155, node0, node0, 4, 46);
      Scope scope0 = Scope.createLatticeBottom(node1);
      HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, true, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      typeInference0.flowThrough(node1, flowScope0);
      typeInference0.createEntryLattice();
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      LightweightMessageFormatter.withoutSource();
      FileSystemHandling.shouldAllThrowIOExceptions();
      Logger.getLogger("^[");
      Compiler compiler0 = new Compiler();
      Compiler compiler1 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "");
      Node node1 = Node.newString("", 55, 1);
      Node node2 = new Node(56, node1, node1, 42, 131);
      Scope scope0 = Scope.createLatticeBottom(node2);
      HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, true, true);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, true);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      typeInference0.flowThrough(node2, flowScope0);
      typeInference0.createInitialEstimateLattice();
      System.setCurrentTimeMillis(400000);
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      LightweightMessageFormatter lightweightMessageFormatter0 = LightweightMessageFormatter.withoutSource();
      FileSystemHandling.shouldAllThrowIOExceptions();
      Logger logger0 = Logger.getLogger("qB(TwQ(hIKFv");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(lightweightMessageFormatter0, logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "");
      Node node1 = new Node(49, node0, node0, 46, (-4509));
      Scope scope0 = Scope.createLatticeBottom(node1);
      HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, hashMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      LinkedFlowScope linkedFlowScope0 = (LinkedFlowScope)typeInference0.flowThrough(node1, flowScope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      typeInference0.createInitialEstimateLattice();
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      LightweightMessageFormatter lightweightMessageFormatter0 = LightweightMessageFormatter.withoutSource();
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      Logger logger0 = Logger.getLogger("Xe|`E5m\"ggekedn");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(lightweightMessageFormatter0, logger0);
      Compiler compiler0 = new Compiler();
      Logger logger1 = Tracer.logger;
      LoggerErrorManager loggerErrorManager1 = new LoggerErrorManager(lightweightMessageFormatter0, logger1);
      Compiler compiler1 = new Compiler(loggerErrorManager1);
      String string0 = "\"`&&rDU";
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "\"`&&rDU");
      int int0 = 109;
      int int1 = 2475;
      Node node1 = new Node(int0, node0, node0, node0.NO_SIDE_EFFECTS, int1);
      Scope scope0 = Scope.createLatticeBottom(node1);
      HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, boolean0, boolean0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeRegistry jSTypeRegistry1 = compiler0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, hashMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      typeInference0.flowThrough(node1, flowScope0);
      typeInference0.createInitialEstimateLattice();
      typeInference0.createEntryLattice();
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      LightweightMessageFormatter lightweightMessageFormatter0 = LightweightMessageFormatter.withoutSource();
      FileSystemHandling.shouldAllThrowIOExceptions();
      Logger logger0 = Logger.getLogger("Xe|`E5m\"ggekedn");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(lightweightMessageFormatter0, logger0);
      Compiler compiler0 = new Compiler();
      Compiler compiler1 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "");
      Node node1 = Node.newString("Xe|`E5m\"ggekedn", 46, (-1));
      Node node2 = new Node(12, node1, node0, (-155), (-10));
      Scope scope0 = Scope.createLatticeBottom(node2);
      HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, closureReverseAbstractInterpreter0, scope0, hashMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      typeInference0.flowThrough(node2, flowScope0);
      typeInference0.createInitialEstimateLattice();
      System.setCurrentTimeMillis(55);
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      LightweightMessageFormatter lightweightMessageFormatter0 = LightweightMessageFormatter.withoutSource();
      FileSystemHandling.shouldAllThrowIOExceptions();
      Logger logger0 = Logger.getLogger("");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(lightweightMessageFormatter0, logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Compiler compiler1 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler1, "");
      Node node1 = new Node(15, node0, node0, node0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler1, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, hashMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      typeInference0.flowThrough(node1, flowScope0);
      typeInference0.createInitialEstimateLattice();
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      LightweightMessageFormatter lightweightMessageFormatter0 = LightweightMessageFormatter.withoutSource();
      FileSystemHandling.shouldAllThrowIOExceptions();
      Logger logger0 = Logger.getLogger("");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(lightweightMessageFormatter0, logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "");
      Node node1 = new Node(43, node0, node0, 2, 0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, true, true);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, hashMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      FlowScope flowScope2 = typeInference0.createInitialEstimateLattice();
      assertNotSame(flowScope2, flowScope1);
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      LightweightMessageFormatter lightweightMessageFormatter0 = LightweightMessageFormatter.withoutSource();
      FileSystemHandling.shouldAllThrowIOExceptions();
      Logger logger0 = Logger.getLogger("");
      Logger logger1 = logger0.getParent();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(lightweightMessageFormatter0, logger1);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "");
      Node node1 = new Node(54, node0, node0, (-1429), 142);
      Scope scope0 = Scope.createLatticeBottom(node1);
      HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, true, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, hashMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      FlowScope flowScope2 = typeInference0.createInitialEstimateLattice();
      assertNotSame(flowScope2, flowScope1);
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      LightweightMessageFormatter lightweightMessageFormatter0 = LightweightMessageFormatter.withoutSource();
      FileSystemHandling.shouldAllThrowIOExceptions();
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(lightweightMessageFormatter0, logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      String string0 = "o.p,6JU'M1`/.+F(*G";
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "o.p,6JU'M1`/.+F(*G");
      int int0 = (-2056);
      int int1 = 2;
      Node node1 = new Node(node0.INCRDECR_PROP, node0, node0, int0, int1);
      Scope scope0 = Scope.createLatticeBottom(node1);
      HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
      boolean boolean0 = false;
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, boolean0, boolean0);
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp1 = new LinkedFlowScope.FlowScopeJoinOp();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = null;
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
      FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
      Node.newString(string0);
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      FlowScope flowScope2 = typeInference0.createInitialEstimateLattice();
      typeInference0.branchedFlowThrough(node1, flowScope2);
      FlowScope flowScope3 = typeInference0.createEntryLattice();
      FlowScope flowScope4 = linkedFlowScope_FlowScopeJoinOp0.apply(flowScope3, flowScope1);
      linkedFlowScope_FlowScopeJoinOp1.apply(flowScope4, flowScope3);
      typeInference0.flowThrough(node1, flowScope3);
      typeInference0.flowThrough(node1, flowScope1);
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      LightweightMessageFormatter lightweightMessageFormatter0 = LightweightMessageFormatter.withoutSource();
      FileSystemHandling.shouldAllThrowIOExceptions();
      Logger logger0 = Logger.getLogger("qB(TwQ(hIKFv");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(lightweightMessageFormatter0, logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "");
      Node node1 = new Node(153, node0, node0, 46, (-4509));
      Scope scope0 = Scope.createLatticeBottom(node1);
      HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, hashMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      typeInference0.createInitialEstimateLattice();
      typeInference0.branchedFlowThrough(node0, flowScope0);
      assertNotSame(flowScope0, flowScope1);
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      LightweightMessageFormatter lightweightMessageFormatter0 = LightweightMessageFormatter.withoutSource();
      FileSystemHandling.shouldAllThrowIOExceptions();
      Logger logger0 = Logger.getLogger("");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(lightweightMessageFormatter0, logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer");
      Node node1 = new Node(128, node0, node0, 46, 49);
      Scope scope0 = Scope.createLatticeBottom(node1);
      HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, hashMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      typeInference0.flowThrough(node1, flowScope0);
      FlowScope flowScope1 = typeInference0.createInitialEstimateLattice();
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      LightweightMessageFormatter lightweightMessageFormatter0 = LightweightMessageFormatter.withoutSource();
      FileSystemHandling.shouldAllThrowIOExceptions();
      Logger.getLogger("");
      Logger logger0 = Logger.getLogger("-XyOt7cpT;a");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(lightweightMessageFormatter0, logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "-XyOt7cpT;a");
      Node node1 = new Node(155, node0, node0, 22, 46);
      Scope scope0 = Scope.createLatticeBottom(node1);
      HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, true, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, hashMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      FlowScope flowScope2 = typeInference0.createInitialEstimateLattice();
      assertNotSame(flowScope2, flowScope1);
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      LightweightMessageFormatter lightweightMessageFormatter0 = LightweightMessageFormatter.withoutSource();
      FileSystemHandling.shouldAllThrowIOExceptions();
      Logger logger0 = Logger.getLogger("");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(lightweightMessageFormatter0, logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer");
      Scope scope0 = Scope.createLatticeBottom(node0);
      HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, hashMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.createEntryLattice();
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      linkedFlowScope_FlowScopeJoinOp0.apply(flowScope0, flowScope1);
      Node node1 = new Node(16, node0, node0, node0, node0);
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp1 = new LinkedFlowScope.FlowScopeJoinOp();
      FlowScope flowScope2 = linkedFlowScope_FlowScopeJoinOp1.apply(flowScope1, flowScope1);
      FlowScope flowScope3 = typeInference0.flowThrough(node1, flowScope2);
      assertNotSame(flowScope3, flowScope2);
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      LightweightMessageFormatter lightweightMessageFormatter0 = LightweightMessageFormatter.withoutSource();
      FileSystemHandling.shouldAllThrowIOExceptions();
      Logger logger0 = Logger.getLogger("");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(lightweightMessageFormatter0, logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "");
      Node node1 = new Node(57, node0, node0, 1638, 2765);
      Scope scope0 = Scope.createLatticeBottom(node1);
      HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, hashMap0);
      FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
      Node node2 = Node.newString("");
      FlowScope flowScope1 = typeInference0.flowThrough(node2, flowScope0);
      typeInference0.createInitialEstimateLattice();
      typeInference0.branchedFlowThrough(node1, flowScope0);
      FlowScope flowScope2 = typeInference0.createEntryLattice();
      FlowScope flowScope3 = linkedFlowScope_FlowScopeJoinOp0.apply(flowScope2, flowScope0);
      FlowScope flowScope4 = linkedFlowScope_FlowScopeJoinOp0.apply(flowScope1, flowScope3);
      typeInference0.flowThrough(node1, flowScope3);
      FlowScope flowScope5 = typeInference0.flowThrough(node2, flowScope4);
      assertNotSame(flowScope5, flowScope4);
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      LightweightMessageFormatter lightweightMessageFormatter0 = LightweightMessageFormatter.withoutSource();
      FileSystemHandling.shouldAllThrowIOExceptions();
      Logger logger0 = Logger.getLogger("");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(lightweightMessageFormatter0, logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Compiler compiler1 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler1, "");
      Node node1 = Node.newString("", 0, 2);
      Node node2 = new Node(50, node1, node1, (-1464), 1512);
      Scope scope0 = Scope.createLatticeBottom(node2);
      HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler1, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, hashMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      typeInference0.flowThrough(node2, flowScope0);
      typeInference0.createInitialEstimateLattice();
      System.setCurrentTimeMillis(36);
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      LightweightMessageFormatter lightweightMessageFormatter0 = LightweightMessageFormatter.withoutSource();
      FileSystemHandling.shouldAllThrowIOExceptions();
      Logger logger0 = Logger.getGlobal();
      Logger logger1 = logger0.getParent();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(lightweightMessageFormatter0, logger1);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      String string0 = "o.p,6JU'M1`/.+F(*G";
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "o.p,6JU'M1`/.+F(*G");
      int int0 = (-2056);
      int int1 = 2;
      Node node1 = new Node(node0.INCRDECR_PROP, node0, node0, int0, int1);
      Scope scope0 = Scope.createLatticeBottom(node1);
      HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
      boolean boolean0 = false;
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, boolean0, boolean0);
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = null;
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
      FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
      String string1 = "com.google.common.collect.ImmutableSetMultimap$EntrySet";
      Node.newString(string1);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
      typeInference1.flowThrough(node1, flowScope0);
      TypeInference typeInference2 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
      FlowScope flowScope1 = typeInference2.createInitialEstimateLattice();
      typeInference0.branchedFlowThrough(node1, flowScope1);
      typeInference1.createEntryLattice();
      FlowScope flowScope2 = linkedFlowScope_FlowScopeJoinOp0.apply(flowScope0, flowScope0);
      typeInference1.flowThrough(node1, flowScope1);
      typeInference0.flowThrough(node0, flowScope2);
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      LightweightMessageFormatter lightweightMessageFormatter0 = LightweightMessageFormatter.withoutSource();
      FileSystemHandling.shouldAllThrowIOExceptions();
      Logger logger0 = Logger.getLogger("");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(lightweightMessageFormatter0, logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer");
      Node node1 = new Node(36, node0, node0, 46, 49);
      Scope scope0 = Scope.createLatticeBottom(node1);
      HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, hashMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      typeInference0.flowThrough(node1, flowScope0);
      FlowScope flowScope1 = typeInference0.createInitialEstimateLattice();
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      LightweightMessageFormatter lightweightMessageFormatter0 = LightweightMessageFormatter.withoutSource();
      FileSystemHandling.shouldAllThrowIOExceptions();
      Logger logger0 = Logger.getLogger("");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(lightweightMessageFormatter0, logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Compiler compiler1 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler1, "");
      Node node1 = new Node(8, node0, node0, 47, 52);
      Scope scope0 = Scope.createLatticeBottom(node1);
      HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler1, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, hashMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      typeInference0.flowThrough(node1, flowScope0);
      FlowScope flowScope1 = typeInference0.createInitialEstimateLattice();
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      int int0 = 5;
      LightweightMessageFormatter lightweightMessageFormatter0 = LightweightMessageFormatter.withoutSource();
      FileSystemHandling.shouldAllThrowIOExceptions();
      Logger logger0 = Logger.getLogger("");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(lightweightMessageFormatter0, logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      String string0 = "o.p,6JU'M1`/.+F(*G";
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "o.p,6JU'M1`/.+F(*G");
      int int1 = 712;
      int int2 = (-1238);
      Node node1 = new Node(int0, node0, node0, int1, int2);
      Scope scope0 = Scope.createLatticeBottom(node1);
      HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
      boolean boolean0 = false;
      boolean boolean1 = false;
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, boolean1, boolean0);
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = null;
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
      FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
      String string1 = "cm.google.javascript.jscomp.TypeInference";
      Node node2 = Node.newString(string1);
      FlowScope flowScope1 = typeInference0.flowThrough(node0, flowScope0);
      typeInference0.createInitialEstimateLattice();
      typeInference0.branchedFlowThrough(node1, flowScope0);
      typeInference0.createEntryLattice();
      FlowScope flowScope2 = linkedFlowScope_FlowScopeJoinOp0.apply(flowScope1, flowScope0);
      typeInference0.flowThrough(node2, flowScope2);
      typeInference0.flowThrough(node1, flowScope2);
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      LightweightMessageFormatter lightweightMessageFormatter0 = LightweightMessageFormatter.withoutSource();
      FileSystemHandling.shouldAllThrowIOExceptions();
      Logger logger0 = Logger.getLogger("");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(lightweightMessageFormatter0, logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer");
      Node node1 = new Node(39, node0, node0, 43, 132);
      Scope scope0 = Scope.createLatticeBottom(node1);
      HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
      HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap1 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, true, true);
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, hashMap1);
      typeInference0.createInitialEstimateLattice();
      typeInference0.createInitialEstimateLattice();
      ControlFlowAnalysis.computeFollowNode(node0, (ControlFlowAnalysis) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = linkedFlowScope0.createChildFlowScope();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough((Node) null, flowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      LightweightMessageFormatter lightweightMessageFormatter0 = LightweightMessageFormatter.withoutSource();
      FileSystemHandling.shouldAllThrowIOExceptions();
      Logger logger0 = Logger.getLogger("");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(lightweightMessageFormatter0, logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer");
      Node node1 = new Node(148, node0, node0, 46, 49);
      Scope scope0 = Scope.createLatticeBottom(node1);
      HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, hashMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      typeInference0.flowThrough(node1, flowScope0);
      FlowScope flowScope1 = typeInference0.createInitialEstimateLattice();
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      LightweightMessageFormatter lightweightMessageFormatter0 = LightweightMessageFormatter.withoutSource();
      FileSystemHandling.shouldAllThrowIOExceptions();
      Logger logger0 = Logger.getLogger("");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(lightweightMessageFormatter0, logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer");
      Node node1 = new Node(144, node0, node0, 46, 49);
      Scope scope0 = Scope.createLatticeBottom(node1);
      HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      logger0.getFilter();
      logger0.setFilter((Filter) null);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, hashMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      typeInference0.createInitialEstimateLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 144
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      LightweightMessageFormatter lightweightMessageFormatter0 = LightweightMessageFormatter.withoutSource();
      FileSystemHandling.shouldAllThrowIOExceptions();
      Logger logger0 = Logger.getLogger("");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(lightweightMessageFormatter0, logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer");
      Node node1 = new Node(144, node0, node0, 46, 49);
      Scope scope0 = Scope.createLatticeBottom(node1);
      HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, hashMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      typeInference0.flowThrough(node1, flowScope0);
      FlowScope flowScope1 = typeInference0.createInitialEstimateLattice();
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      int int0 = 5;
      LightweightMessageFormatter lightweightMessageFormatter0 = LightweightMessageFormatter.withoutSource();
      FileSystemHandling.shouldAllThrowIOExceptions();
      Logger logger0 = Logger.getLogger("");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(lightweightMessageFormatter0, logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      String string0 = "o.p,6JU'M1`/.+F(*G";
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "o.p,6JU'M1`/.+F(*G");
      int int1 = 712;
      int int2 = (-1218);
      Node node1 = new Node(int0, node0, node0, int1, int2);
      Scope scope0 = Scope.createLatticeBottom(node1);
      HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
      boolean boolean0 = false;
      boolean boolean1 = false;
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, boolean1, boolean0);
      boolean boolean2 = true;
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node1, boolean1, boolean2);
      boolean boolean3 = false;
      ControlFlowGraph<Node> controlFlowGraph2 = new ControlFlowGraph<Node>(node0, boolean3, boolean2);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      String string1 = "j[5Xs.\\J+S&vbj|=`;";
      int int3 = 1;
      int int4 = 112;
      simpleErrorReporter0.error(string1, string1, int3, int4);
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry1 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, closureReverseAbstractInterpreter0, scope0, hashMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph1, closureReverseAbstractInterpreter0, scope0, hashMap0);
      int int5 = (-196);
      Node node2 = Node.newString(int5, string0, node0.CHANGE_TIME, node0.MAX_COLUMN_NUMBER);
      typeInference1.flowThrough(node2, flowScope0);
      typeInference0.branchedFlowThrough(node0, flowScope0);
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      int int0 = 5;
      LightweightMessageFormatter lightweightMessageFormatter0 = LightweightMessageFormatter.withoutSource();
      FileSystemHandling.shouldAllThrowIOExceptions();
      Logger logger0 = Logger.getLogger("");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(lightweightMessageFormatter0, logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      String string0 = "o.p,6JU'M1`/.+F(*G";
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "o.p,6JU'M1`/.+F(*G");
      int int1 = 712;
      int int2 = (-1218);
      Node node1 = new Node(int0, node0, node0, int1, int2);
      Scope scope0 = Scope.createLatticeBottom(node1);
      HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
      boolean boolean0 = false;
      boolean boolean1 = false;
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, boolean1, boolean0);
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = null;
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
      FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
      String string1 = "cm.google.javascript.jscomp.TypeInference";
      Node node2 = Node.newString(string1);
      FlowScope flowScope1 = typeInference0.flowThrough(node0, flowScope0);
      typeInference0.createInitialEstimateLattice();
      typeInference0.branchedFlowThrough(node1, flowScope0);
      typeInference0.createEntryLattice();
      FlowScope flowScope2 = linkedFlowScope_FlowScopeJoinOp0.apply(flowScope1, flowScope0);
      typeInference0.flowThrough(node2, flowScope2);
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      int int0 = 5;
      LightweightMessageFormatter lightweightMessageFormatter0 = LightweightMessageFormatter.withoutSource();
      FileSystemHandling.shouldAllThrowIOExceptions();
      Logger logger0 = Logger.getLogger("");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(lightweightMessageFormatter0, logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      String string0 = "?e?2iC oOS7E|rA?:";
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "?e?2iC oOS7E|rA?:");
      int int1 = 712;
      int int2 = (-1218);
      Node node1 = new Node(int0, node0, node0, int1, int2);
      Scope scope0 = Scope.createLatticeBottom(node1);
      HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
      boolean boolean0 = false;
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, boolean0, boolean0);
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = null;
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
      FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
      Node node2 = Node.newString(string0);
      typeInference0.flowThrough(node2, flowScope0);
      typeInference0.createInitialEstimateLattice();
      FlowScope flowScope1 = null;
      typeInference0.flowThrough(node0, flowScope1);
      typeInference0.createEntryLattice();
      typeInference0.createInitialEstimateLattice();
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      int int0 = 5;
      LightweightMessageFormatter lightweightMessageFormatter0 = LightweightMessageFormatter.withoutSource();
      FileSystemHandling.shouldAllThrowIOExceptions();
      Logger logger0 = Logger.getLogger("");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(lightweightMessageFormatter0, logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      String string0 = "o.p,6JU'M1`/.+F(*G";
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "o.p,6JU'M1`/.+F(*G");
      int int1 = 712;
      int int2 = (-1218);
      Node node1 = new Node(int0, node0, node0, int1, int2);
      Scope scope0 = Scope.createLatticeBottom(node1);
      HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
      boolean boolean0 = false;
      boolean boolean1 = false;
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, boolean1, boolean0);
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = null;
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
      FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
      String string1 = "com.google.javascript.jscomp.TypeInference";
      Node.newString(string1);
      FlowScope flowScope1 = typeInference0.flowThrough(node0, flowScope0);
      typeInference0.createInitialEstimateLattice();
      typeInference0.branchedFlowThrough(node1, flowScope0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;
      boolean boolean2 = true;
      TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, boolean2);
      typeInference0.flowThrough(node1, flowScope1);
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      int int0 = 5;
      LightweightMessageFormatter lightweightMessageFormatter0 = LightweightMessageFormatter.withoutSource();
      FileSystemHandling.shouldAllThrowIOExceptions();
      Logger logger0 = Logger.getLogger("");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(lightweightMessageFormatter0, logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      String string0 = "?e?2iC oOS7E|rA?:";
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "?e?2iC oOS7E|rA?:");
      int int1 = 712;
      int int2 = (-1218);
      Node node1 = new Node(int0, node0, node0, int1, int2);
      Scope scope0 = Scope.createLatticeBottom(node1);
      HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
      boolean boolean0 = false;
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, boolean0, boolean0);
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = null;
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
      FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
      Node node2 = Node.newString(string0);
      typeInference0.flowThrough(node2, flowScope0);
      FlowScope flowScope1 = typeInference0.createInitialEstimateLattice();
      typeInference0.branchedFlowThrough(node2, flowScope1);
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      int int0 = 5;
      LightweightMessageFormatter lightweightMessageFormatter0 = LightweightMessageFormatter.withoutSource();
      FileSystemHandling.shouldAllThrowIOExceptions();
      Logger logger0 = Logger.getLogger("");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(lightweightMessageFormatter0, logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      String string0 = "?e?2iC oOS7E|rA?:";
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "?e?2iC oOS7E|rA?:");
      int int1 = 712;
      int int2 = (-1218);
      Node node1 = new Node(int0, node0, node0, int1, int2);
      Scope scope0 = Scope.createLatticeBottom(node1);
      HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
      boolean boolean0 = false;
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, boolean0, boolean0);
      boolean boolean1 = false;
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, boolean1, boolean0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, closureReverseAbstractInterpreter0, scope0, hashMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      typeInference0.flowThrough(node0, flowScope0);
  }

  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      // Undeclared exception!
      try { 
        TypeInference.getBooleanOutcomes(booleanLiteralSet0, (BooleanLiteralSet) null, true);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      BooleanLiteralSet booleanLiteralSet1 = BooleanLiteralSet.BOTH;
      TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet1, false);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      cleanupPasses0.getTopScope();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      compilerOptions0.getCodingConvention();
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention((CodingConvention) null);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
      closureReverseAbstractInterpreter0.append(semanticReverseAbstractInterpreter0);
      Scope scope0 = Scope.createLatticeBottom((Node) null);
      HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, (String) null);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      TypeInference typeInference0 = null;
      try {
        typeInference0 = new TypeInference((AbstractCompiler) null, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, hashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test32()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, true);
      booleanLiteralSet1.contains(false);
      BooleanLiteralSet booleanLiteralSet2 = BooleanLiteralSet.FALSE;
      booleanLiteralSet1.union(booleanLiteralSet2);
      BooleanLiteralSet booleanLiteralSet3 = booleanLiteralSet1.intersection(booleanLiteralSet0);
      BooleanLiteralSet booleanLiteralSet4 = BooleanLiteralSet.TRUE;
      BooleanLiteralSet booleanLiteralSet5 = BooleanLiteralSet.FALSE;
      booleanLiteralSet1.union(booleanLiteralSet5);
      booleanLiteralSet1.union(booleanLiteralSet4);
      booleanLiteralSet1.intersection(booleanLiteralSet0);
      BooleanLiteralSet booleanLiteralSet6 = BooleanLiteralSet.FALSE;
      booleanLiteralSet3.contains(true);
      TypeInference.getBooleanOutcomes(booleanLiteralSet1, booleanLiteralSet6, true);
      BooleanLiteralSet booleanLiteralSet7 = BooleanLiteralSet.EMPTY;
      TypeInference.getBooleanOutcomes(booleanLiteralSet3, booleanLiteralSet7, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention(jqueryCodingConvention0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.append(semanticReverseAbstractInterpreter0);
      Scope scope0 = Scope.createLatticeBottom((Node) null);
      HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = null;
      try {
        typeInference0 = new TypeInference((AbstractCompiler) null, (ControlFlowGraph<Node>) null, chainableReverseAbstractInterpreter0, scope0, hashMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.DataFlowAnalysis", e);
      }
  }

  @Test(timeout = 4000)
  public void test33()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      BooleanLiteralSet booleanLiteralSet1 = BooleanLiteralSet.BOTH;
      TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet1, false);
      Compiler compiler0 = new Compiler();
      ControlFlowGraph<Node> controlFlowGraph0 = null;
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = null;
      CompilerOptions compilerOptions0 = new CompilerOptions();
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      cleanupPasses0.getTopScope();
      JSTypeNative jSTypeNative0 = JSTypeNative.URI_ERROR_FUNCTION_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null, jSTypeNative0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("`AD%", codingConvention_AssertionFunctionSpec0, "", codingConvention_AssertionFunctionSpec0);
      // Undeclared exception!
      try { 
        immutableSortedMap0.tailMap((String) null, false);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test34()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
      Compiler compiler0 = new Compiler();
      ExploitAssigns exploitAssigns0 = new ExploitAssigns();
      Node node0 = Node.newString("SRaIUd}wxLszV7}i", 57, 57);
      Node node1 = exploitAssigns0.optimizeSubtree(node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      GoogleCodingConvention googleCodingConvention1 = new GoogleCodingConvention(googleCodingConvention0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention1, jSTypeRegistry0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      closureReverseAbstractInterpreter0.append(semanticReverseAbstractInterpreter0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      PassConfig.PassConfigDelegate passConfig_PassConfigDelegate0 = new PassConfig.PassConfigDelegate(defaultPassConfig0);
      passConfig_PassConfigDelegate0.getTopScope();
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("T=d'OU");
      JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("Object#Key", jSTypeNative0);
      // Undeclared exception!
      try { 
        ImmutableSortedMap.of((String) null, codingConvention_AssertionFunctionSpec0, "", codingConvention_AssertionFunctionSpec0, (String) null, codingConvention_AssertionFunctionSpec0, (String) null, codingConvention_AssertionFunctionSpec1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // null key in entry: null=com.google.javascript.jscomp.CodingConvention$AssertionFunctionSpec@22a
         //
         verifyException("com.google.common.collect.CollectPreconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test35()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.TRUE;
      BooleanLiteralSet booleanLiteralSet1 = BooleanLiteralSet.TRUE;
      TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet1, true);
      MockFile mockFile0 = new MockFile("com.google.javascript.jscomp.TypeInference$1");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      // Undeclared exception!
      try { 
        compiler0.computeCFG();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.Compiler", e);
      }
  }

  @Test(timeout = 4000)
  public void test36()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      boolean boolean0 = true;
      BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, true);
      booleanLiteralSet1.contains(false);
      BooleanLiteralSet booleanLiteralSet2 = BooleanLiteralSet.FALSE;
      booleanLiteralSet1.union(booleanLiteralSet2);
      booleanLiteralSet1.intersection(booleanLiteralSet0);
      BooleanLiteralSet booleanLiteralSet3 = BooleanLiteralSet.TRUE;
      BooleanLiteralSet booleanLiteralSet4 = BooleanLiteralSet.FALSE;
      booleanLiteralSet1.union(booleanLiteralSet4);
      booleanLiteralSet1.union(booleanLiteralSet3);
      // Undeclared exception!
      try { 
        BooleanLiteralSet.valueOf("");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // No enum constant com.google.javascript.rhino.jstype.BooleanLiteralSet.
         //
         verifyException("java.lang.Enum", e);
      }
  }
}
