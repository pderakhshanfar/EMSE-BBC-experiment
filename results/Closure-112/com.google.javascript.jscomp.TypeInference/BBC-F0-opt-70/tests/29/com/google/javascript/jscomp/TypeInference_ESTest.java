/*
 * This file was automatically generated by EvoSuite
 * Sat Oct 23 22:22:37 GMT 2021
 */

package com.google.javascript.jscomp;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.common.collect.ImmutableSortedMap;
import com.google.javascript.jscomp.CodingConvention;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerInput;
import com.google.javascript.jscomp.CompilerOptions;
import com.google.javascript.jscomp.ControlFlowGraph;
import com.google.javascript.jscomp.LinkedFlowScope;
import com.google.javascript.jscomp.Scope;
import com.google.javascript.jscomp.SourceFile;
import com.google.javascript.jscomp.TypeInference;
import com.google.javascript.jscomp.type.FlowScope;
import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.SimpleErrorReporter;
import com.google.javascript.rhino.jstype.BooleanLiteralSet;
import com.google.javascript.rhino.jstype.JSType;
import com.google.javascript.rhino.jstype.JSTypeNative;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import java.util.List;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class TypeInference_ESTest extends TypeInference_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.TRUE;
      // Undeclared exception!
      try { 
        TypeInference.getBooleanOutcomes(booleanLiteralSet0, (BooleanLiteralSet) null, false);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      Node node1 = new Node(38, node0, node0);
      node0.addChildrenToBack(node1);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "Function literal argument refers to undefined this argument", codingConvention_AssertionFunctionSpec0, "TRUE", codingConvention_AssertionFunctionSpec0, "[", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("TRUE", "Function literal argument refers to undefined this argument");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // NAME is not a string node
         //
         verifyException("com.google.javascript.rhino.Node", e);
      }
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      Node node0 = Node.newString((-593), "L94,3'Co?#X$$");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      JSTypeNative jSTypeNative0 = JSTypeNative.U2U_FUNCTION_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("", jSTypeNative0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Function literal argument refers to undefined this argument", codingConvention_AssertionFunctionSpec0, "L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "W4fp", codingConvention_AssertionFunctionSpec0, "", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      TypeInference typeInference0 = null;
      try {
        typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.Compiler", e);
      }
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      Node node0 = Node.newString(155, "z`dt(h[TOv6H0C|E,");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createGlobalScope(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("[4");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("^L` )>vx+fO`", codingConvention_AssertionFunctionSpec0, "S3;.},lTo~h~P(#$W", codingConvention_AssertionFunctionSpec0, "com.google.javascript.jscomp.JsMessage", codingConvention_AssertionFunctionSpec0, "?|'aG+]qS'p", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("k?eg,w&-`Z51v", "");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      typeInference0.flowThrough(node0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.TRUE;
      BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
      assertSame(booleanLiteralSet1, booleanLiteralSet0);
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, true);
      assertSame(booleanLiteralSet0, booleanLiteralSet1);
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      Node node1 = Node.newString(38, "[4", 30, 54);
      node0.addChildrenToBack(node1);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("G.H3fM6JB4X", codingConvention_AssertionFunctionSpec0, "inherits", codingConvention_AssertionFunctionSpec0, "", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("[4", "Message must be initialized using goog.getMsg function.");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      Node node0 = new Node((-568), (-568), (-568));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      Node node1 = Node.newString(4, "", 615, (-41));
      node0.addChildrenToBack(node1);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(") must not be negative", codingConvention_AssertionFunctionSpec0, "', '", codingConvention_AssertionFunctionSpec0, "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair", codingConvention_AssertionFunctionSpec0, "", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("', '", "', '");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      Node node0 = Node.newString((-593), "L94,3'Co?#X$$");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("[4");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Function literal argument refers to undefined this argument", codingConvention_AssertionFunctionSpec0, "L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode(";NHIt8PM$Lt,gX=2f;G", "[4", "[{|O!m7T$:y%2x*P");
      CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      Node node0 = Node.newString(155, "z`dt(h[TOv6H0C|E,");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createGlobalScope(node0);
      Node node1 = Node.newString(79, "nGebPrsGOS:s\"K6B", 38, 30);
      node0.addChildrenToBack(node1);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("[4");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("^L` )>vx+fO`", codingConvention_AssertionFunctionSpec0, "S3;.},lTo~h~P(#$W", codingConvention_AssertionFunctionSpec0, "com.google.javascript.jscomp.JsMessage", codingConvention_AssertionFunctionSpec0, "?|'aG+]qS'p", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("k?eg,w&-`Z51v", "");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("', '");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "]t<p]VOT/c~M", codingConvention_AssertionFunctionSpec0, "', '", codingConvention_AssertionFunctionSpec0, "com.google.javascript.rhino.head.ast.ThrowStatement", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("', '", "[4");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = new Node(153);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("', '");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "]t<p]VOT/c~M", codingConvention_AssertionFunctionSpec0, "', '", codingConvention_AssertionFunctionSpec0, "com.google.javascript.rhino.head.ast.ThrowStatement", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("', '", "[4");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = new Node(152);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-563), (-563));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createGlobalScope(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("L94,3'Co?#X$$");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("gmgZHUCpo", codingConvention_AssertionFunctionSpec0, "', '", codingConvention_AssertionFunctionSpec0, "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair", codingConvention_AssertionFunctionSpec0, "'n!FF@H9 gm!", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("L94,3'Co?#X$$", "gmgZHUCpo");
      CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = new Node(151);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      Node node0 = Node.newString((-568), "L84,3'Co?cX$$");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("[4");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("com.google.javascript.jscomp.TypeInference$BooleanOutcomePair", codingConvention_AssertionFunctionSpec0, "L84,3'Co?cX$$", codingConvention_AssertionFunctionSpec0, "m", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("m", "[4", "[{|O!m7T$:y%2x*P");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(150);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 150
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("', '");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0, "', '", codingConvention_AssertionFunctionSpec0, "com.google.javascript.rhino.head.ast.ThrowStatement", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("', '", "[4");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      Node node1 = new Node(145, 57, 141);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      Node node0 = Node.newString(1, "L94,3'Co?#$$");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      Node node1 = new Node(144);
      node0.addChildrenToBack(node1);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.javascript.jscomp.TypeInference$1");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("L94,3'Co?#$$", codingConvention_AssertionFunctionSpec0, "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0, "g=BldNw:!J/N4KjtI", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("I|a%}/]!4I|bXs", "I|a%}/]!4I|bXs", "com.google.javascript.jscomp.TypeInference$1");
      CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("UZ");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "', '", codingConvention_AssertionFunctionSpec0, "b:7RrS=-^Hu6t!p", codingConvention_AssertionFunctionSpec0, "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("L94,3'Co?#X$$", "UZ");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = new Node(143);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      Node node0 = new Node((-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("', ");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0, "', ", codingConvention_AssertionFunctionSpec0, "unreachable code", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("', ", "[4");
      CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = new Node(142);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      Node node1 = Node.newString(141, "[4", 57, 0);
      node0.addChildrenToBack(node1);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("', '");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "]t<p]VOT/c~M", codingConvention_AssertionFunctionSpec0, "', '", codingConvention_AssertionFunctionSpec0, "com.google.javascript.rhino.head.ast.ThrowStatement", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("', '", "[4");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 141
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("', '");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0, "', '", codingConvention_AssertionFunctionSpec0, "com.google.javascript.rhino.head.ast.ThrowStatement", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("', '", "[4");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = new Node(140);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      Node node1 = Node.newString(139, "[4", 1204, 0);
      node0.addChildrenToBack(node1);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("', '");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "]t<p]VOT/c~M", codingConvention_AssertionFunctionSpec0, "', '", codingConvention_AssertionFunctionSpec0, "com.google.javascript.rhino.head.ast.ThrowStatement", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("', '", "[4");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 139
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("', '");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "]t<p]VOT/c~M", codingConvention_AssertionFunctionSpec0, "', '", codingConvention_AssertionFunctionSpec0, "com.google.javascript.rhino.head.ast.ThrowStatement", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("', '", "[-");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = new Node(137);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-622), (-622));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      Node node1 = new Node(136);
      node0.addChildrenToBack(node1);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("[4");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("WHILE", codingConvention_AssertionFunctionSpec0, "com.google.javascript.jscomp.^ypeInference$B5oleanOutcomePair", codingConvention_AssertionFunctionSpec0, "1!v-TZ0{h,Xdi@4<", codingConvention_AssertionFunctionSpec0, "\"5)mU", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.^ypeInference$B5oleanOutcomePair", "[4");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 136
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      Node node0 = Node.newString("L84/,3'C?&cX$$");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createLatticeBottom(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("[4");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("com.goole.jvascript.jscom.^ypeIference$B5oleanOutcomePair", codingConvention_AssertionFunctionSpec0, "L84/,3'C?&cX$$", codingConvention_AssertionFunctionSpec0, "", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("aev\"p$~utp(UE$P", "U+|");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = new Node(135);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("', '");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair", codingConvention_AssertionFunctionSpec0, "', '", codingConvention_AssertionFunctionSpec0, "com.google.javascript.rhino.head.ast.ThrowStatement", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("', '", "UZ");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = new Node(133);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      Node node0 = Node.newString((-582), "L94,3'Co?#X$$");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createGlobalScope(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("[4");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Function literal argument refers to undefined this argument", codingConvention_AssertionFunctionSpec0, "L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "OAe", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("Function literal argument refers to undefined this argument", "Function literal argument refers to undefined this argument");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      CompilerInput compilerInput0 = new CompilerInput(sourceFile0);
      Node node1 = compilerInput0.getAstRoot(compiler0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SCRIPT [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000001093] [input_id: com.google.javascript.rhino.Node$ObjectPropListItem@0000001094] does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      Node node1 = Node.newString(129, "L94,3'Co?#X$$", 57, 0);
      node0.addChildrenToBack(node1);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("y[v'");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "]t<p]VOT/c~M", codingConvention_AssertionFunctionSpec0, "y[v'", codingConvention_AssertionFunctionSpec0, "com.google.javascript.rhino.head.ast.ThrowStatement", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("y[v'", "L94,3'Co?#X$$");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 129
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("', '");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "]t<p]VOT/c~M", codingConvention_AssertionFunctionSpec0, "', '", codingConvention_AssertionFunctionSpec0, "com.google.javascript.rhino.head.ast.ThrowStatement", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("', '", "[4");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = new Node(128);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("', '");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "[J", codingConvention_AssertionFunctionSpec0, "', '", codingConvention_AssertionFunctionSpec0, "com.google.javascript.rhino.head.ast.ThrowStatement", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.rhino.head.ast.ThrowStatement", (String) null, "[J");
      CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = new Node(127);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Mo?#X$$");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createGlobalScope(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("1!v-TZ0{h,Xdi@4<");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("z3>|vcGbg+kn", codingConvention_AssertionFunctionSpec0, ": CbKO..F???b`$", codingConvention_AssertionFunctionSpec0, ")#{tXH84=f-{TJi*Yi", codingConvention_AssertionFunctionSpec0, "+f[&", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode(": CbKO..F???b`$", "1!v-TZ0{h,Xdi@4<");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = new Node(126);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LABEL does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-563), (-563));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createGlobalScope(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("', '", codingConvention_AssertionFunctionSpec0, "", codingConvention_AssertionFunctionSpec0, "=5*J04LQIl1We$3Wd&", codingConvention_AssertionFunctionSpec0, "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode(".", "~|r0G");
      CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = new Node(125);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      Node node0 = Node.newString("L9,3'C#X+$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      Node node1 = Node.newString(123, "[4", 57, 40);
      node0.addChildrenToBack(node1);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("L9,3'C#X+$");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("L9,3'C#X+$", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0, "', '", codingConvention_AssertionFunctionSpec0, "com.google.javascript.rhino.head.ast.ThrowStatement", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("', '", "[4");
      CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test32()  throws Throwable  {
      Node node0 = Node.newString((-568), "L84,3'Co?cX$$");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("[4");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("com.google.javascript.jscomp.TypeInference$BooleanOutcomePair", codingConvention_AssertionFunctionSpec0, "L84,3'Co?cX$$", codingConvention_AssertionFunctionSpec0, "m", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("m", "[4", "[{|O!m7T$:y%2x*P");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(122);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // VOID does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test33()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("y[v'");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "]t<p]VOT/c~M", codingConvention_AssertionFunctionSpec0, "y[v'", codingConvention_AssertionFunctionSpec0, "com.google.javascript.rhino.head.ast.ThrowStatement", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("y[v'", "[4");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = new Node(120);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test34()  throws Throwable  {
      Node node0 = new Node((-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("', '");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("L994,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0, "', '", codingConvention_AssertionFunctionSpec0, "com.google.javascript.rhino.head.ast.ThrowStatement", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("', '", "[4");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      Node node1 = new Node(118);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // VAR does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test35()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("', ");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0, "', ", codingConvention_AssertionFunctionSpec0, "com.google.javascript.rhino.head.ast.ThrowStatement", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("', ", "[4");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = new Node(117);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test36()  throws Throwable  {
      Node node0 = new Node((-568));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createGlobalScope(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("[4");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("com.google.javascript.jscomp.TypeInference$BooleanOutcomePair", codingConvention_AssertionFunctionSpec0, "L84,3'Co?cX$$", codingConvention_AssertionFunctionSpec0, "m", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("m", "[4", "L84,3'Co?cX$$");
      CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(115);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test37()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("extern");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("isVarArgs", codingConvention_AssertionFunctionSpec0, "qk /*xm@", codingConvention_AssertionFunctionSpec0, "extern", codingConvention_AssertionFunctionSpec0, "kieS%", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.rhino.head.ast.ThrowStatement", "[4");
      CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = new Node(114);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test38()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("', '");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0, "', '", codingConvention_AssertionFunctionSpec0, "com.google.javascript.rhino.head.ast.ThrowStatement", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("', '", "[4");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = new Node(111);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test39()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("', '");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0, "', '", codingConvention_AssertionFunctionSpec0, "com.google.javascript.rhino.head.ast.ThrowStatement", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("', '", "[4");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      Node node1 = new Node(109);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test40()  throws Throwable  {
      Node node0 = Node.newString(155, "z`dt(h[TOv6H0C|E,");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createGlobalScope(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("[4");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("^L` )>vx+fO`", codingConvention_AssertionFunctionSpec0, "S3;.},lTo~h~P(#$W", codingConvention_AssertionFunctionSpec0, "com.google.javascript.scomp.JsMssage", codingConvention_AssertionFunctionSpec0, "?|'aG+]qS'p", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("k?eg,w&-`Z51v", "");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(108);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test41()  throws Throwable  {
      Node node0 = Node.newString("L9,3'C#X+$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      Node node1 = Node.newString(107, "[4", 57, 40);
      node0.addChildrenToBack(node1);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("', '");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("L9,3'C#X+$", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0, "', '", codingConvention_AssertionFunctionSpec0, "com.google.javascript.rhino.head.ast.ThrowStatement", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("', '", "[4");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test42()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("y[v'");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "]t<p]VOT/c~M", codingConvention_AssertionFunctionSpec0, "y[v'", codingConvention_AssertionFunctionSpec0, "com.google.javascript.rhino.head.ast.ThrowStatement", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("y[v'", "L94,3'Co?#X$$");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = new Node(96);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test43()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("[4");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("com.google.javascript.jscomp.TpeInference$BooleanOutcomePair", codingConvention_AssertionFunctionSpec0, "L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "m", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode(";NHISt8PM$Lt,gX=2f;G", "[4", "[{|O!m7T$:y%2x*X");
      CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSType[] jSTypeArray0 = new JSType[0];
      Node node1 = jSTypeRegistry0.createParametersWithVarArgs(jSTypeArray0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test44()  throws Throwable  {
      Node node0 = Node.newString((-593), "L94,3'Co?#X$$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("extern");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("isVas(rAugs", codingConvention_AssertionFunctionSpec0, "", codingConvention_AssertionFunctionSpec0, "extern", codingConvention_AssertionFunctionSpec0, "kie%", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.rhino.head.ast.ThrowStatement", "[4");
      CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = new Node(74);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test45()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createGlobalScope(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("', '");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "]t<p]VOT/c~M", codingConvention_AssertionFunctionSpec0, "', '", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JSC_FUNCTION_LITERAL_UNDEFINED_THIS", "");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = new Node(69);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test46()  throws Throwable  {
      Node node0 = Node.newString((-568), "L84,3'Co?cX$$");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("[4");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("com.google.javascript.jscomp.TypeInference$BooleanOutcomePair", codingConvention_AssertionFunctionSpec0, "L84,3'Co?cX$$", codingConvention_AssertionFunctionSpec0, "m", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("m", "[4", "[{|O!m7T$:y%2x*P");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(57);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test47()  throws Throwable  {
      Node node0 = Node.newString((-593), "L94,3'Co?#X$$");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      Node node1 = new Node(56, node0, node0, node0, node0);
      node0.addChildrenToBack(node1);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("[4");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Function literal argument refers to undefined this argument", codingConvention_AssertionFunctionSpec0, "L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("Function literal argument refers to undefined this argument", "Function literal argument refers to undefined this argument");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test48()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      Node node1 = new Node(55, node0, node0, node0);
      node0.addChildrenToBack(node1);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("[4");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("com.google.javascript.jscomp.TypeInference$BooleanOutcomePair", codingConvention_AssertionFunctionSpec0, "L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode(";NHIt8PM$Lt,gX=2f;G", "[4", "[{|O!m7T$:y%2x*P");
      CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test49()  throws Throwable  {
      Node node0 = Node.newString("L9,3'C#X+$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("', '");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("L9,3'C#X+$", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0, "', '", codingConvention_AssertionFunctionSpec0, "com.google.javascript.rhino.head.ast.ThrowStatement", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("', '", "[4");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = new Node(54);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test50()  throws Throwable  {
      Node node0 = Node.newString("L84,3'Co?cX$$", (-568), (-568));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("[4");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("com.google.javascript.jscomp.TypeInference$BooleanOutcomePair", codingConvention_AssertionFunctionSpec0, "L84,3'Co?cX$$", codingConvention_AssertionFunctionSpec0, "m", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("m", "[4", "[{|O!m7T$:y%2x*P");
      CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(53);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 53
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test51()  throws Throwable  {
      Node node0 = new Node((-568));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createGlobalScope(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("[4");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("com.google.javascript.jscomp.TypeInference$BooleanOutcomePair", codingConvention_AssertionFunctionSpec0, "L84,3'Co?cX$$", codingConvention_AssertionFunctionSpec0, "m", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("m", "[4", "L84,3'Co?cX$$");
      CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(52);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test52()  throws Throwable  {
      Node node0 = Node.newString((-582), "L94,3'Co?#X$$");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      Scope scope0 = Scope.createLatticeBottom(node0);
      Node node1 = new Node(51);
      node0.addChildrenToBack(node1);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("L94,3'Co?#X$$");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("com.google.javascript.jscomp.TypeInference$1", codingConvention_AssertionFunctionSpec0, "`/ua-", codingConvention_AssertionFunctionSpec0, "a1~Pv{vXwR3A9y\"h_", codingConvention_AssertionFunctionSpec0, "Y=&@'{Do<i", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromFile("a1~Pv{vXwR3A9y\"h_");
      CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // IN : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test53()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("', '");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "]t<p]VOT/c~M", codingConvention_AssertionFunctionSpec0, "', '", codingConvention_AssertionFunctionSpec0, "com.google.javascript.rhino.head.ast.ThrowStatement", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("', '", "[-");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = new Node(50);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test54()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      Node node1 = Node.newString(49, "", 1262, 111);
      node0.addChildrenToBack(node1);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("L94,3'Co?#X$$");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Function literal argument refers to undefined this argument", codingConvention_AssertionFunctionSpec0, "", codingConvention_AssertionFunctionSpec0, "iy:Vk", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("iy:Vk", "Function literal argument refers to undefined this argument");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test55()  throws Throwable  {
      Node node0 = Node.newString(1, "L94,3'Co?#$$");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      Node node1 = new Node(48, node0);
      node0.addChildrenToBack(node1);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.javascript.jscomp.TypeInference$1");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("L94,3'Co?#$$", codingConvention_AssertionFunctionSpec0, "rh_]:?", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0, "com.google.javascript.jscomp.TypeInference$1", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("I|a%}/]!4I|bXs", "I|a%}/]!4I|bXs", "com.google.javascript.jscomp.TypeInference$1");
      CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test56()  throws Throwable  {
      Node node0 = Node.newString((-593), "L94,3'Co?#X$$");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createGlobalScope(node0);
      Node node1 = new Node(47, node0, node0, node0);
      Node node2 = new Node(0, 39, 57);
      node0.addChildrenToBack(node2);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("[4");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Function literal argument refers to undefined this argument", codingConvention_AssertionFunctionSpec0, "L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("Function literal argument refers to undefined this argument", "Function literal argument refers to undefined this argument");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test57()  throws Throwable  {
      Node node0 = Node.newString((-568), "L84,3'Co?cX$$");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("[4");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("com.google.javascript.jscomp.TypeInference$BooleanOutcomePair", codingConvention_AssertionFunctionSpec0, "L84,3'Co?cX$$", codingConvention_AssertionFunctionSpec0, "m", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("m", "[4", "[{|O!m7T$:y%2x*P");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = new Node(46, 125, 33);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test58()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-622), (-622));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("[4");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("WHILE", codingConvention_AssertionFunctionSpec0, "com.google.javascript.jscomp.^ypeInference$B5oleanOutcomePair", codingConvention_AssertionFunctionSpec0, "1!v-TZ0{h,Xdi@4<", codingConvention_AssertionFunctionSpec0, "\"5)mU", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.^ypeInference$B5oleanOutcomePair", "[4");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = new Node(43);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test59()  throws Throwable  {
      Node node0 = Node.newString((-568), "L84,3'Co?cX$$");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("[4");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("JSC_FUNCTION_LITERAL_UNDEFINED_THIS", codingConvention_AssertionFunctionSpec0, "", codingConvention_AssertionFunctionSpec0, "com.google.javascript.rhino.head.ast.ThrowStatement", codingConvention_AssertionFunctionSpec0, "L84,3'Co?cX$$", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("[4", "JSC_FUNCTION_LITERAL_UNDEFINED_THIS");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = new Node(42);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test60()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("[4");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("com.google.javascript.jscomp.TypeInference$BooleanOutcomePair", codingConvention_AssertionFunctionSpec0, "L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference$BooleanOutcomePair", "[4", "@ngInject can only be used when defining a function or assigning a function expression.");
      CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newNumber((double) 0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // NUMBER 0.0 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test61()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createLatticeBottom(node0);
      Node node1 = new Node(38, node0, node0);
      node0.addChildrenToBack(node1);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "Function literal argument refers to undefined this argument", codingConvention_AssertionFunctionSpec0, "TRUE", codingConvention_AssertionFunctionSpec0, "[", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("TRUE", "Function literal argument refers to undefined this argument");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // NAME is not a string node
         //
         verifyException("com.google.javascript.rhino.Node", e);
      }
  }

  @Test(timeout = 4000)
  public void test62()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Mo?#X$$");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createGlobalScope(node0);
      Node node1 = Node.newString(37, "L94,3'Mo?#X$$", 151, 2);
      node0.addChildrenToBack(node1);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("L94,3'Mo?#X$$");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("[4", codingConvention_AssertionFunctionSpec0, "2Mx\u0001,b|Vz", codingConvention_AssertionFunctionSpec0, "", codingConvention_AssertionFunctionSpec0, "%s (%s) must not be negative", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("UeM*I'YloH", "vBw8KaUa7");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test63()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      Node node1 = new Node(36);
      node0.addChildrenToBack(node1);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("[4");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("com.google.javascript.jscomp.TypeInference$BooleanOutcomePair", codingConvention_AssertionFunctionSpec0, "L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference$BooleanOutcomePair", "[4", "@ngInject can only be used when defining a function or assigning a function expression.");
      CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test64()  throws Throwable  {
      Node node0 = Node.newString("d2m JkWnktV*-u2a", 154, 154);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createGlobalScope(node0);
      Node node1 = Node.newString(31, "bs)jZQTNek:Tfxb!|", 167, 130);
      node0.addChildrenToBack(node1);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("CmPXlh", codingConvention_AssertionFunctionSpec0, "com.google.javascript.jscomp.ReplaceCssNames$Traversal", codingConvention_AssertionFunctionSpec0, "s4ADv-mP.b&", codingConvention_AssertionFunctionSpec0, "", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("6Q]%e}\"=3dC", "com.google.javascript.jscomp.ReplaceCssNames$Traversal");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // DELPROP bs)jZQTNek:Tfxb!| 167 : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test65()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createGlobalScope(node0);
      Node node1 = new Node(29);
      node0.addChildrenToBack(node1);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("L94,3'Co?#X$$");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Function literal argument refers to undefined this argument", codingConvention_AssertionFunctionSpec0, "", codingConvention_AssertionFunctionSpec0, "iy:Vk", codingConvention_AssertionFunctionSpec0, "$z", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("iy:Vk", "Function literal argument refers to undefined this argument");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test66()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("', '");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0, "', '", codingConvention_AssertionFunctionSpec0, "com.google.javascript.rhino.head.ast.ThrowStatement", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("', '", "[4");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = new Node(23);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // MUL : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test67()  throws Throwable  {
      Node node0 = Node.newString((-593), "L94,3'Co?#X$$");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createGlobalScope(node0);
      Node node1 = Node.newString(16, "[4", 30, 2);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("[4");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Function literal argument refers to undefined this argument", codingConvention_AssertionFunctionSpec0, "L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("Function literal argument refers to undefined this argument", "Function literal argument refers to undefined this argument");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // GT [4 30 : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test68()  throws Throwable  {
      Node node0 = new Node((-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("x%te");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("", codingConvention_AssertionFunctionSpec0, "x%te", codingConvention_AssertionFunctionSpec0, "@,g?]sM,./&/Sce", codingConvention_AssertionFunctionSpec0, "L994,3'Co?#X$$", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("&Q^ Oc]!", "h=|kD");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      Node node1 = new Node(15, 57, (-1954));
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test69()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      Node node1 = Node.newString(12, "L94,3'Co?#X$$", 31, 1);
      node0.addChildrenToBack(node1);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("FgI5^hN%5}ljcwGsj]");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("=%h", codingConvention_AssertionFunctionSpec0, "com.google.javascript.rhino.head.ast.ThrowStatement", codingConvention_AssertionFunctionSpec0, "(<0r#FN+p", codingConvention_AssertionFunctionSpec0, "IA-'onCzzr-KL6G.ejx", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("}51<zw", "com.google.javascript.rhino.head.ast.ThrowStatement");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test70()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      Node node1 = Node.newString(8, "GLq?", 30, 15);
      node0.addChildrenToBack(node1);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(";d1&wh~g3Y&:wfb:/b");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("com.google.javascript.jscomp.TypeInference$1", codingConvention_AssertionFunctionSpec0, "com.google.common.collect.ImmutableListMultimap$Builder", codingConvention_AssertionFunctionSpec0, "p^>w1G[(]", codingConvention_AssertionFunctionSpec0, ";d1&wh~g3Y&:wfb:/b", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("l^zqHI)m;<f|1aym", "[e>gA#cS?e8M<tb=Pn?");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 8
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test71()  throws Throwable  {
      Node node0 = new Node((-568), (-568), (-568));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(") must not be negative", codingConvention_AssertionFunctionSpec0, "', '", codingConvention_AssertionFunctionSpec0, "", codingConvention_AssertionFunctionSpec0, "", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("', '", "', '");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = new Node(7);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test72()  throws Throwable  {
      Node node0 = new Node((-568), (-568), (-568));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      Node node1 = Node.newString(5, "", 33, (-41));
      node0.addChildrenToBack(node1);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("K");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(") must not be negative", codingConvention_AssertionFunctionSpec0, "', '", codingConvention_AssertionFunctionSpec0, "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair", codingConvention_AssertionFunctionSpec0, "K", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("', '", "com.google.javascript.jscomp.TypeInference");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 5
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test73()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createGlobalScope(node0);
      Node node1 = new Node(4, node0, node0);
      node0.addChildrenToBack(node1);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("L94,3'Co?#X$$");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Function literal argument refers to undefined this argument", codingConvention_AssertionFunctionSpec0, "", codingConvention_AssertionFunctionSpec0, "iy:Vk", codingConvention_AssertionFunctionSpec0, "$z", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("iy:Vk", "Function literal argument refers to undefined this argument");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test74()  throws Throwable  {
      Node node0 = Node.newString((-593), "L94,3'Co?#X$$");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("[4");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Function literal argument refers to undefined this argument", codingConvention_AssertionFunctionSpec0, "L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("Function literal argument refers to undefined this argument", "Function literal argument refers to undefined this argument");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.SYN_BLOCK;
      controlFlowGraph0.connectToImplicitReturn(node0, controlFlowGraph_Branch0);
      FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void test75()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("[4");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("com.google.javascript.jscomp.TypeInference$BooleanOutcomePair", codingConvention_AssertionFunctionSpec0, "L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "m", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode(";NHISt8PM$Lt,gX=2f;G", "[4", "[{|O!m7T$:y%2x*P");
      CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_TRUE;
      controlFlowGraph0.connectToImplicitReturn(node0, controlFlowGraph_Branch0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // STRING L94,3'Co?#X$$ does not have a condition.
         //
         verifyException("com.google.javascript.jscomp.NodeUtil", e);
      }
  }

  @Test(timeout = 4000)
  public void test76()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Co?#X$$", (-593), (-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      Node node1 = new Node(30, node0, node0, node0, node0, 49, 42);
      node0.addChildrenToBack(node1);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("[4");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("com.google.javascript.jscomp.TpeInference$BooleanOutcomePair", codingConvention_AssertionFunctionSpec0, "L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "m", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode(";NHISt8PM$Lt,gX=2f;G", "[4", "[{|O!m7T$:y%2x*X");
      CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test77()  throws Throwable  {
      Node node0 = new Node((-568));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createGlobalScope(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("[4");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("com.google.javascript.jscomp.TypeInference$BooleanOutcomePair", codingConvention_AssertionFunctionSpec0, "L84,3'Co?cX$$", codingConvention_AssertionFunctionSpec0, "m", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("m", "[4", "L84,3'Co?cX$$");
      CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(100);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test78()  throws Throwable  {
      Node node0 = Node.newString("L94,3'Mo?#X$$");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("+f[&");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("OAjL[h!eu@%d", codingConvention_AssertionFunctionSpec0, "L94,3'Mo?#X$$", codingConvention_AssertionFunctionSpec0, "", codingConvention_AssertionFunctionSpec0, "+f[&", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("+f[&", "+f[&", "[{|O!m7T$:y%2x*P");
      CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = new Node(101);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test79()  throws Throwable  {
      Node node0 = Node.newString("L84,3'Co?cX$$", (-568), (-568));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("[4");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("com.google.javascript.jscomp.TypeInference$BooleanOutcomePair", codingConvention_AssertionFunctionSpec0, "L84,3'Co?cX$$", codingConvention_AssertionFunctionSpec0, "m", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("m", "[4", "[{|O!m7T$:y%2x*P");
      CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      assertNotNull(flowScope0);
  }

  @Test(timeout = 4000)
  public void test80()  throws Throwable  {
      Node node0 = new Node((-593));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      node0.addChildrenToBack(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("', '");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("L94,3'Co?#X$$", codingConvention_AssertionFunctionSpec0, "[4", codingConvention_AssertionFunctionSpec0, "', '", codingConvention_AssertionFunctionSpec0, "com.google.javascript.rhino.head.ast.ThrowStatement", codingConvention_AssertionFunctionSpec0);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("', '", "[4");
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = new Node(32);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }
}
