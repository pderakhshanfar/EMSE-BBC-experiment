/*
 * This file was automatically generated by EvoSuite
 * Tue Oct 12 10:33:53 GMT 2021
 */

package com.google.javascript.jscomp;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.common.collect.ImmutableBiMap;
import com.google.javascript.jscomp.CodingConvention;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.ControlFlowGraph;
import com.google.javascript.jscomp.LinkedFlowScope;
import com.google.javascript.jscomp.LoggerErrorManager;
import com.google.javascript.jscomp.Scope;
import com.google.javascript.jscomp.TypeInference;
import com.google.javascript.jscomp.type.FlowScope;
import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.jstype.BooleanLiteralSet;
import java.io.ByteArrayOutputStream;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.logging.Logger;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.mock.java.io.MockFile;
import org.evosuite.runtime.mock.java.io.MockPrintStream;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class TypeInference_ESTest extends TypeInference_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test000()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.TRUE;
      // Undeclared exception!
      try { 
        TypeInference.getBooleanOutcomes(booleanLiteralSet0, (BooleanLiteralSet) null, true);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test001()  throws Throwable  {
      MockFile mockFile0 = new MockFile("com.google.jiascript.jscomp.AiasStrings");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode("prototype");
      Node node1 = new Node(33, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("prototype");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("com.google.jiascript.jscomp.AiasStrings", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node1, flowScope0);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // SCRIPT 1 [synthetic: com.google.javascript.rhino.Node$IntPropListItem@0000000606] [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000000607] [input_id: com.google.javascript.rhino.Node$ObjectPropListItem@0000000608] is not a string node
         //
         verifyException("com.google.javascript.rhino.Node", e);
      }
  }

  @Test(timeout = 4000)
  public void test002()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789$");
      Node node1 = new Node(120, node0, node0, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("g@|c/*Cv<:", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createGlobalScope(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test003()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("prototype");
      Node node1 = new Node(64, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("prototype");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("com.google.jiascript.jscomp.AiasStrings", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test004()  throws Throwable  {
      MockFile mockFile0 = new MockFile("com.google.javascript.jscomp.AliasStrings", "com.google.javascript.jscomp.AliasStrings");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      // Undeclared exception!
      try { 
        compiler0.parseSyntheticCode("com.google.javascript.jscomp.AliasStrings", "com.google.javascript.jscomp.AliasStrings");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Multiple entries with same key: constructor=NOT_IMPLEMENTED and constructor=CONSTRUCTOR
         //
         verifyException("com.google.common.collect.ImmutableMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test005()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      // Undeclared exception!
      try { 
        compiler0.parseSyntheticCode("?", "B");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Multiple entries with same key: constructor=NOT_IMPLEMENTED and constructor=CONSTRUCTOR
         //
         verifyException("com.google.common.collect.ImmutableMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test006()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      // Undeclared exception!
      try { 
        compiler0.parseSyntheticCode("com.google.jvascript.jscomp.AiasStrings", "com.google.jvascript.jscomp.AiasStrings");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Multiple entries with same key: constructor=NOT_IMPLEMENTED and constructor=CONSTRUCTOR
         //
         verifyException("com.google.common.collect.ImmutableMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test007()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("com.google.jvascript.jscomp.AiasStrings");
      Node node1 = new Node(155, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.jvascript.jscomp.AiasStrings");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("com.google.jvascript.jscomp.AiasStrings", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createGlobalScope(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertTrue(flowScope0.equals((Object)linkedFlowScope0));
  }

  @Test(timeout = 4000)
  public void test008()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      // Undeclared exception!
      try { 
        compiler0.parseSyntheticCode("?", "");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Multiple entries with same key: constructor=NOT_IMPLEMENTED and constructor=CONSTRUCTOR
         //
         verifyException("com.google.common.collect.ImmutableMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test009()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      // Undeclared exception!
      try { 
        compiler0.parseSyntheticCode("com.google.jvascript.jscomp.AiasStrings", "JSC_FUNCTION_LITERAL_UNDEFINED_THIS");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Multiple entries with same key: constructor=NOT_IMPLEMENTED and constructor=CONSTRUCTOR
         //
         verifyException("com.google.common.collect.ImmutableMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test010()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("com.google.jvascript.jscomp.AiasStrings");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode(":Q-O{2\"a&;i&G");
      Node node1 = new Node(37, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, true, true);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("JSC_FUNCTIO{_LITERAL_UNDEFINED_THIS");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of(":Q-O{2\"a&;i&G", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      assertTrue(flowScope1.equals((Object)flowScope0));
  }

  @Test(timeout = 4000)
  public void test011()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      // Undeclared exception!
      try { 
        compiler0.parseSyntheticCode("com.google.jvascript.jscomp.AiasStrings", "");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Multiple entries with same key: constructor=NOT_IMPLEMENTED and constructor=CONSTRUCTOR
         //
         verifyException("com.google.common.collect.ImmutableMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test012()  throws Throwable  {
      MockFile mockFile0 = new MockFile("com.google.jiascript.jscomp.AiasStrings");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode("prototype");
      Node node1 = new Node(29, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("prototype");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("com.google.jiascript.jscomp.AiasStrings", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // NEG : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test013()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode(" MH");
      Node node1 = new Node(23, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      node1.detachChildren();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // MUL : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test014()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      // Undeclared exception!
      try { 
        compiler0.parseSyntheticCode("com.google.jvascript.jscomp.AiasStrings", "externsValidation");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Multiple entries with same key: constructor=NOT_IMPLEMENTED and constructor=CONSTRUCTOR
         //
         verifyException("com.google.common.collect.ImmutableMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test015()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("com.google.jvascriptVjscomp.AiasStrings");
      Node node1 = new Node(25, node0, node0, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test016()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("BLOCK_COMMENT");
      Node node1 = new Node(49, node0, node0, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(":5u1");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("a", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createGlobalScope(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test017()  throws Throwable  {
      MockFile mockFile0 = new MockFile("com.google.jvascript.jscomp.AiasStrings", "com.google.jvascript.jscomp.AiasStrings");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      // Undeclared exception!
      try { 
        compiler0.parseSyntheticCode("AFLg?$6${iHp*", "com.google.jvascript.jscomp.AiasStrings");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Multiple entries with same key: constructor=NOT_IMPLEMENTED and constructor=CONSTRUCTOR
         //
         verifyException("com.google.common.collect.ImmutableMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test018()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("?");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      compiler0.parseTestCode("?");
      Node node0 = Node.newString(18, "?");
      Node node1 = new Node((-1466), node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      Scope scope0 = Scope.createLatticeBottom(node1);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LSH ? : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test019()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
      assertEquals(BooleanLiteralSet.BOTH, booleanLiteralSet1);
  }

  @Test(timeout = 4000)
  public void test020()  throws Throwable  {
      MockFile mockFile0 = new MockFile("com.wogle.jvasriptVjscomp.AiasStrings", "com.wogle.jvasriptVjscomp.AiasStrings");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      // Undeclared exception!
      try { 
        compiler0.parseSyntheticCode("AFLg?$6${iHp*", "com.wogle.jvasriptVjscomp.AiasStrings");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Multiple entries with same key: constructor=NOT_IMPLEMENTED and constructor=CONSTRUCTOR
         //
         verifyException("com.google.common.collect.ImmutableMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test021()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("com.google.javascript.jscomp.AliasStrings");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      // Undeclared exception!
      try { 
        compiler0.parseSyntheticCode("com.google.javascript.jscomp.AliasStrings", "com.google.javascript.jscomp.AliasStrings");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Multiple entries with same key: constructor=NOT_IMPLEMENTED and constructor=CONSTRUCTOR
         //
         verifyException("com.google.common.collect.ImmutableMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test022()  throws Throwable  {
      MockFile mockFile0 = new MockFile("com.google.jiascript.jscomp.AiasStrings");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode("prototype");
      Node node1 = new Node(154, node0, node0, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // STRING_KEY does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test023()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("com.google.jvascriptVjscomp.AiasStrings");
      Node node1 = new Node(152, node0, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test024()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("com.google.jvascript.jscomp.AiasStrings");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode("prototype");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("prototype");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("prototype", codingConvention_AssertionFunctionSpec0);
      Node node1 = new Node(151, 2, 36);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 151
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test025()  throws Throwable  {
      MockFile mockFile0 = new MockFile("com.google.jvascriptVjscomp.AiasStrings", "com.google.jvascriptVjscomp.AiasStrings");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode("vb xOe+p|;lC");
      Node node1 = new Node(150, node0, node0, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, true);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("I]D'vS-");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("com.google.jvascriptVjscomp.AiasStrings", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test026()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("com.google.jvascript.jscomp.AiasStrings");
      Node node1 = new Node(149, node0, node0, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // CONST does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test027()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("com.googl.jvascriptVjscomp.AiaStrings");
      Node node1 = new Node(148, node0, node0, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.googl.jvascriptVjscomp.AiaStrings");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("uyDY$ NEac", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createGlobalScope(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SETTER_DEF does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test028()  throws Throwable  {
      MockFile mockFile0 = new MockFile("com.google.jvascript.jscomp.AiasStrings", "com.google.jvascript.jscomp.AiasStrings");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode("");
      Node node1 = new Node(147, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, true, true);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("prototype");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("prototype", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createGlobalScope(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, flowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test029()  throws Throwable  {
      MockFile mockFile0 = new MockFile("com.google.jvascript.jscomp.AiasStrings", "com.google.jvascript.jscomp.AiasStrings");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode("p.2Uc.");
      Node node1 = new Node(146, node0, node0, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("p.2Uc.");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("x90d X4]@y", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertTrue(flowScope0.equals((Object)linkedFlowScope0));
  }

  @Test(timeout = 4000)
  public void test030()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("com.google.jvascript.jscomp.AiaStrings");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode("com.google.jvascript.jscomp.AiaStrings");
      Node node1 = new Node(145, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, true);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.jvascript.jscomp.AiaStrings");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("5w1-zHZ*Y9.z9", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, flowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test031()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("com.googl.jvascriptVjscomp.AiaStrings");
      Node node1 = new Node(143, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 143
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test032()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("com.google.jvascript.jscomp.AiasStrings");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      // Undeclared exception!
      try { 
        compiler0.parseSyntheticCode("(ScfN)+,wg", "9");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Multiple entries with same key: constructor=NOT_IMPLEMENTED and constructor=CONSTRUCTOR
         //
         verifyException("com.google.common.collect.ImmutableMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test033()  throws Throwable  {
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(302);
      MockPrintStream mockPrintStream0 = new MockPrintStream(byteArrayOutputStream0, true);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode("com.google.javascript.jscomp.ConcreteType$ConcreteFunctionType");
      Node node1 = new Node(141, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, true, false);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test034()  throws Throwable  {
      MockFile mockFile0 = new MockFile("com.google.jvascript.jscomp.AiasStrings", "com.google.jvascript.jscomp.AiasStrings");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode(":Q-O{2\"a&;i&G");
      Node node1 = new Node(140, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.jvascript.jscomp.AiasStrings");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("JSC_FUNCTIO{_LITERAL_UNDEFINED_THIS", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 140
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test035()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      // Undeclared exception!
      try { 
        compiler0.parseSyntheticCode("com.google.jvascript.jcomp.yiasStrings", "com.google.jvascript.jcomp.yiasStrings");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Multiple entries with same key: constructor=NOT_IMPLEMENTED and constructor=CONSTRUCTOR
         //
         verifyException("com.google.common.collect.ImmutableMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test036()  throws Throwable  {
      MockFile mockFile0 = new MockFile("com.google.jvascript.jscomp.AiasStrings", "com.google.jvascript.jscomp.AiasStrings");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      // Undeclared exception!
      try { 
        compiler0.parseSyntheticCode("com.google.javascript.jscomp.ProcessCommonJSModules", "");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Multiple entries with same key: constructor=NOT_IMPLEMENTED and constructor=CONSTRUCTOR
         //
         verifyException("com.google.common.collect.ImmutableMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test037()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("com.google.jvascript.jscomp.AiaStrings");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode("com.google.jvascript.jscomp.AiaStrings");
      Node node1 = new Node(137, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, true);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.jvascript.jscomp.AiaStrings");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("JSC_FUNCTION_LITERAL_UNDEFINED_THIS", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, flowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test038()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("com.google.jvascript.jscomp.AiaStrings");
      Node node1 = new Node(135, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test039()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("com.wogle.jvasriptVjscomp.AiasStrings");
      Node node1 = new Node(133, node0, node0, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, true);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.wogle.jvasriptVjscomp.AiasStrings");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("com.wogle.jvasriptVjscomp.AiasStrings", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, flowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test040()  throws Throwable  {
      MockFile mockFile0 = new MockFile("com.google.jvascriptVjscomp.AiasStrings", "com.google.jvascriptVjscomp.AiasStrings");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode("com.google.jvascriptVjscomp.AiasStrings");
      Node node1 = new Node(129, node0, node0, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("vb xOe+p|;lC");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("I]D'vS-", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 129
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test041()  throws Throwable  {
      MockFile mockFile0 = new MockFile("com.google.jvascript.jscomp.AiasStrings", "com.google.jvascript.jscomp.AiasStrings");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode("com.google.jvascript.jscomp.AiasStrings");
      Node node1 = new Node(128, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.javascript.jscomp.ProcessTweaks$CollectTweaksResult");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("MwLldpPIw4-;k!", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 128
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test042()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("com.google.javascript.jscomp.AliasStrings");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode("com.google.javascript.jscomp.AliasStrings");
      Node node1 = new Node(127, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, true);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.javascript.jscomp.AliasStrings");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test043()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      // Undeclared exception!
      try { 
        compiler0.parseSyntheticCode("com.google.jiascript.jscomp.AiasStrings", "com.google.jiascript.jscomp.AiasStrings");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Multiple entries with same key: constructor=NOT_IMPLEMENTED and constructor=CONSTRUCTOR
         //
         verifyException("com.google.common.collect.ImmutableMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test044()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      // Undeclared exception!
      try { 
        compiler0.parseSyntheticCode("com.google.jvascript.jscomp.AiasStrings", "com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Multiple entries with same key: constructor=NOT_IMPLEMENTED and constructor=CONSTRUCTOR
         //
         verifyException("com.google.common.collect.ImmutableMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test045()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("com.wogle.jvasriptVjscomp.AiasStrings");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(124, node0, node0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // EMPTY does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test046()  throws Throwable  {
      MockFile mockFile0 = new MockFile("com.googl.jvascriptVjscomp.AiaStrings", "com.googl.jvascriptVjscomp.AiaStrings");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode("com.googl.jvascriptVjscomp.AiaStrings");
      Node node1 = new Node(122, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, true);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Sk/{Q`#sgr");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("O", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test047()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      // Undeclared exception!
      try { 
        compiler0.parseSyntheticCode("com.google.jvascjipt.jscompHAisStrings", "JSC_FUNCTION_LITERAL_UNDEFINED_THIS");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Multiple entries with same key: constructor=NOT_IMPLEMENTED and constructor=CONSTRUCTOR
         //
         verifyException("com.google.common.collect.ImmutableMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test048()  throws Throwable  {
      MockFile mockFile0 = new MockFile("com.googwe.jvascript.jscomp.AiasStrings", "com.googwe.jvascript.jscomp.AiasStrings");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode("com.googwe.jvascript.jscomp.AiasStrings");
      Node node1 = new Node(118, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.common.collect.Multimaps$CustomSetMultimap");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("suXAiiF:iy]rZ#``-m", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, flowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test049()  throws Throwable  {
      MockFile mockFile0 = new MockFile("com.google.jvascript.jscomp.AiasStrings", "com.google.jvascript.jscomp.AiasStrings");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode(":Q-O{2\"a&;i&G");
      Node node1 = new Node(116, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(":Q-O{2\"a&;i&G");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("com.google.javascript.jscomp.DefaultPassConfig$39", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createGlobalScope(node1);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(linkedFlowScope0, flowScope0);
  }

  @Test(timeout = 4000)
  public void test050()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("com.googl.jvascriptVjscomp.AiaStrings");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(115);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // FOR does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test051()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("com.google.jvascript.jscomp.AiasStrings");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode("com.google.jvascript.jscomp.AiasStrings");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.jvascript.jscomp.AiasStrings");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("com.google.jvascript.jscomp.AiasStrings", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      Node node1 = new Node(114, node0, node0, node0, 30, 1037);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // DO 30 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test052()  throws Throwable  {
      MockFile mockFile0 = new MockFile("com.google.jvascri%t.jscomp.AiasStrings", "com.google.jvascri%t.jscomp.AiasStrings");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      // Undeclared exception!
      try { 
        compiler0.parseSyntheticCode("com.google.jvascri%t.jscomp.AiasStrings", "com.google.jvascri%t.jscomp.AiasStrings");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Multiple entries with same key: constructor=NOT_IMPLEMENTED and constructor=CONSTRUCTOR
         //
         verifyException("com.google.common.collect.ImmutableMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test053()  throws Throwable  {
      MockFile mockFile0 = new MockFile("com.googwe.jvascript.jscomp.AiasStrings", "com.googwe.jvascript.jscomp.AiasStrings");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode("prototype");
      Node node1 = new Node(112, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, true, true);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("prototype");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, flowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test054()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("g^]%QD(L?/Yk=f");
      Node node1 = new Node(111, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // CASE does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test055()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      // Undeclared exception!
      try { 
        compiler0.parseSyntheticCode("com.google.javascript.jscomp.TypeInference", "");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Multiple entries with same key: constructor=NOT_IMPLEMENTED and constructor=CONSTRUCTOR
         //
         verifyException("com.google.common.collect.ImmutableMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test056()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("Function literal argument refers to undefined this argument");
      Node node1 = new Node(109, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 109
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test057()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("com.google.javascript.jscomp.AliasStrings");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      // Undeclared exception!
      try { 
        compiler0.parseSyntheticCode("com.google.javascript.jscomp.AliasStrings", "goog.tweak.getBoolean");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Multiple entries with same key: constructor=NOT_IMPLEMENTED and constructor=CONSTRUCTOR
         //
         verifyException("com.google.common.collect.ImmutableMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test058()  throws Throwable  {
      MockFile mockFile0 = new MockFile("com.google.jvascript.jscomp.AiasStrings", "com.google.jvascript.jscomp.AiasStrings");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode("com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer");
      Node node1 = new Node(107, node0, node0, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("[hUgfa$HC-Z.PbPR");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("[hUgfa$HC-Z.PbPR", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 107
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test059()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      // Undeclared exception!
      try { 
        compiler0.parseSyntheticCode("cow.googl.jvascriptVjscomp.AiaStrings", "cow.googl.jvascriptVjscomp.AiaStrings");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Multiple entries with same key: constructor=NOT_IMPLEMENTED and constructor=CONSTRUCTOR
         //
         verifyException("com.google.common.collect.ImmutableMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test060()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("co.go;gevascjipt.jscompHAisStrings");
      Node node1 = new Node(99, node0, node0, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 99
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test061()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      // Undeclared exception!
      try { 
        compiler0.parseSyntheticCode("com.oogle.jvascript.jscomp.AiasStrings", "com.oogle.jvascript.jscomp.AiasStrings");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Multiple entries with same key: constructor=NOT_IMPLEMENTED and constructor=CONSTRUCTOR
         //
         verifyException("com.google.common.collect.ImmutableMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test062()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("co.go;gevascjipt.jscompHAisStrings");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode("co.go;gevascjipt.jscompHAisStrings");
      Node node1 = new Node(97, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertTrue(flowScope0.equals((Object)linkedFlowScope0));
  }

  @Test(timeout = 4000)
  public void test063()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("com.google.jvascjipt.jscompHAisStrings");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode("com.google.jvascjipt.jscompHAisStrings");
      Node node1 = new Node(95, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("yI:+7T*E@lr^'*");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("com.google.jvascjipt.jscompHAisStrings", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // ASSIGN_MUL : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test064()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      // Undeclared exception!
      try { 
        compiler0.parseSyntheticCode(";", "oWeT*VQqHfn");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Multiple entries with same key: constructor=NOT_IMPLEMENTED and constructor=CONSTRUCTOR
         //
         verifyException("com.google.common.collect.ImmutableMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test065()  throws Throwable  {
      MockFile mockFile0 = new MockFile("com.google.jvascript.jscomp.AiasStrings", "com.google.jvascript.jscomp.AiasStrings");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode(":Q-O{2\"a&;i&G");
      Node node1 = new Node(81, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("JSC_FUNCTIO{_LITERAL_UNDEFINED_THIS");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("JSC_FUNCTIO{_LITERAL_UNDEFINED_THIS", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 81
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test066()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("com.google.jvascript.jscomp.AiasStrings");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode("com.google.jvascript.jscomp.AiasStrings");
      Node node1 = new Node(79, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("4C=2");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("7nl+en", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 79
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test067()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("co.go;gevascjipt.jscompHAisStrings");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode("co.go;gevascjipt.jscompHAisStrings");
      Node node1 = new Node(78, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test068()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("com.google.jvascript.jscomp.AiasStrings");
      Node node1 = new Node(77, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // TRY does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test069()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("com.google.jascjipt.jscompHAisStrings");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode("com.google.jascjipt.jscompHAisStrings");
      Node node1 = new Node(71, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("yI:+7T*E@lr^'*");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("com.google.jascjipt.jscompHAisStrings", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 71
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test070()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("com.google8jas/jipt.jscompHAisStrings");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode("com.google8jas/jipt.jscompHAisStrings");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      node0.setType(69);
      Scope scope0 = Scope.createLatticeBottom(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test071()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      // Undeclared exception!
      try { 
        compiler0.parseSyntheticCode("com.Yoogle.jvascript.jocomp.A/asStrings", "com.google.jvascript.jscomp.AiasStrings");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Multiple entries with same key: constructor=NOT_IMPLEMENTED and constructor=CONSTRUCTOR
         //
         verifyException("com.google.common.collect.ImmutableMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test072()  throws Throwable  {
      MockFile mockFile0 = new MockFile("com.google.jvascript.jscomp.AiasStrings");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode("change_time");
      Node node1 = new Node(65, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("A\" k9K:kGdbu", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 65
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test073()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("com.google.jiascript.jscomp.AiasStrings");
      Node node1 = new Node(64, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.jiascript.jscomp.AiasStrings");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("com.google.jiascript.jscomp.AiasStrings", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node1, flowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test074()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("com.google8jas/jipt.jscompHAisStrings");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode("com.google8jas/jipt.jscompHAisStrings");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      node0.setType(60);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test075()  throws Throwable  {
      MockFile mockFile0 = new MockFile("com.google.jvascript.jscomp.AiasStrings", "com.google.jvascript.jscomp.AiasStrings");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      // Undeclared exception!
      try { 
        compiler0.parseSyntheticCode("com.google.jvascript.jscomp.AiasStrings", "com.google.jvascript.jscomp.AiasStrings");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Multiple entries with same key: constructor=NOT_IMPLEMENTED and constructor=CONSTRUCTOR
         //
         verifyException("com.google.common.collect.ImmutableMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test076()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("com.google.jvascript.jscomp.AiasStrings");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode("com.google.jvascript.jscomp.AiasStrings");
      Node node1 = new Node(56, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("4Q5");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("4Q5", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 56
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test077()  throws Throwable  {
      MockFile mockFile0 = new MockFile("com.google.jvascript.jscomp.AiasStrings", "com.google.jvascript.jscomp.AiasStrings");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode("^fe?87d8[mO`3=");
      Node node1 = new Node(55, node0, node0, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("fK*f\"&");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("fK*f\"&", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createGlobalScope(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 55
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test078()  throws Throwable  {
      MockFile mockFile0 = new MockFile("com.google.jvascript.jscomp.AiasStrings", "com.google.jvascript.jscomp.AiasStrings");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode("");
      Node node1 = new Node(54, node0, node0, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, true);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("BESY\"Un");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("[hUgfa$HC-Z.PbPR", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, flowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test079()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("com.google.jascript.jscop.AliasStrings");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      // Undeclared exception!
      try { 
        compiler0.parseSyntheticCode("com.google.jascript.jscop.AliasStrings", "com.google.jascript.jscop.AliasStrings");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Multiple entries with same key: constructor=NOT_IMPLEMENTED and constructor=CONSTRUCTOR
         //
         verifyException("com.google.common.collect.ImmutableMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test080()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("com.google.jvascript.jscomp.AiasStrings");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode(":Q-O{2\"a&;i&G");
      Node node1 = new Node(48, node0, node0, node0, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, true, true);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("JSC_FUNCTIO{_LITERAL_UNDEFINED_THIS");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of(":Q-O{2\"a&;i&G", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test081()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      // Undeclared exception!
      try { 
        compiler0.parseSyntheticCode("com.google.jascri%t.jscomp.AiasStrings", "com.google.jascri%t.jscomp.AiasStrings");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Multiple entries with same key: constructor=NOT_IMPLEMENTED and constructor=CONSTRUCTOR
         //
         verifyException("com.google.common.collect.ImmutableMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test082()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("BEFORE_CHECKS");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode("BEFORE_CHECKS");
      Node node1 = new Node(43, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, true, false);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("BEFORE_CHECKS");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("BEFORE_CHECKS", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test083()  throws Throwable  {
      MockFile mockFile0 = new MockFile("com.google.jvascript.jscomp.AiasStrings", "com.google.jvascript.jscomp.AiasStrings");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode(":Q-O{2\"a&;i&G");
      Node node1 = new Node(39, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, true);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.jvascript.jscomp.AiasStrings");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("com.google.jvascript.jscomp.AiasStrings", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, flowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test084()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("com.googl.jvascriptVjscomp.AiaStrings");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      node0.setType(37);
      Scope scope0 = Scope.createLatticeBottom(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test085()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("co.googevascjipt.jscompHAisStrings");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode("co.googevascjipt.jscompHAisStrings");
      Node node1 = new Node(36, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("yI:+7T*E@lr^'*");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("co.googevascjipt.jscompHAisStrings", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 36
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test086()  throws Throwable  {
      MockFile mockFile0 = new MockFile("g", "com.google.jvascript.jscomp.AiasStrings");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      // Undeclared exception!
      try { 
        compiler0.parseSyntheticCode("com.google.jvascript.jscomp.AiasStrings", "g");
       //  fail("Expecting exception: IllegalArgumentException");
       // Unstable assertion
      } catch(IllegalArgumentException e) {
         //
         // Multiple entries with same key: constructor=NOT_IMPLEMENTED and constructor=CONSTRUCTOR
         //
         verifyException("com.google.common.collect.ImmutableMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test087()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("com.google.jvascript.jscomp.AiasStrings");
      Node node1 = new Node(24, node0, node0, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // DIV : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test088()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      // Undeclared exception!
      try { 
        compiler0.parseSyntheticCode("<", "");
       //  fail("Expecting exception: IllegalArgumentException");
       // Unstable assertion
      } catch(IllegalArgumentException e) {
         //
         // Multiple entries with same key: constructor=NOT_IMPLEMENTED and constructor=CONSTRUCTOR
         //
         verifyException("com.google.common.collect.ImmutableMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test089()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode(" MH");
      Node node1 = new Node(17, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(linkedFlowScope0, flowScope0);
  }

  @Test(timeout = 4000)
  public void test090()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("com.google.jvascript.jscomp.AiasStrings");
      Node node1 = new Node(14, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test091()  throws Throwable  {
      MockFile mockFile0 = new MockFile("com.google.jiascript.jscomp.AiasStrings");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode("prototype");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      Node node1 = new Node(12, 40, 381);
      Scope scope0 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // EQ 40 : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test092()  throws Throwable  {
      MockFile mockFile0 = new MockFile("com.google.jascri%t.jscomp.AiasStrings", "com.google.jascri%t.jscomp.AiasStrings");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      // Undeclared exception!
      try { 
        compiler0.parseSyntheticCode("com.google.jascri%t.jscomp.AiasStrings", "com.google.jascri%t.jscomp.AiasStrings");
       //  fail("Expecting exception: IllegalArgumentException");
       // Unstable assertion
      } catch(IllegalArgumentException e) {
         //
         // Multiple entries with same key: constructor=NOT_IMPLEMENTED and constructor=CONSTRUCTOR
         //
         verifyException("com.google.common.collect.ImmutableMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test093()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("");
      Node node1 = new Node(9, node0, node0, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // BITOR : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test094()  throws Throwable  {
      MockFile mockFile0 = new MockFile("com.google.jvascript.jscomp.AiasStrings", "com.google.jvascript.jscomp.AiasStrings");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode("prototype");
      Node node1 = new Node(8, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, true, true);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("prototype");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("prototype", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createGlobalScope(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, flowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test095()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("com.google.jvascript.jscomp.AiasStrings");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode("com.google.jvascript.jscomp.AiasStrings");
      Node node1 = new Node(5, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.jvascript.jscomp.AiasStrings");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("wv", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 5
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test096()  throws Throwable  {
      MockFile mockFile0 = new MockFile("com.google.jvascript.jscomp.AiasStrings", "com.google.jvascript.jscomp.AiasStrings");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode("prototype");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("prototype");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("prototype", codingConvention_AssertionFunctionSpec0);
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.SYN_BLOCK;
      controlFlowGraph0.connect(node0, controlFlowGraph_Branch0, node0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
      assertFalse(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test097()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode(" MH");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createLatticeBottom(node0);
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_TRUE;
      controlFlowGraph0.connectToImplicitReturn(node0, controlFlowGraph_Branch0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SCRIPT 1 [synthetic: com.google.javascript.rhino.Node$IntPropListItem@0000000606] [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000000607] [input_id: com.google.javascript.rhino.Node$ObjectPropListItem@0000000608] does not have a condition.
         //
         verifyException("com.google.javascript.jscomp.NodeUtil", e);
      }
  }

  @Test(timeout = 4000)
  public void test098()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("BEFORE_CHECKS");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseTestCode("BEFORE_CHECKS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("BEFORE_CHECKS");
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_FALSE;
      controlFlowGraph0.connectToImplicitReturn(node0, controlFlowGraph_Branch0);
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("BEFORE_CHECKS", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SCRIPT 1 [synthetic: com.google.javascript.rhino.Node$IntPropListItem@0000000606] [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000000607] [input_id: com.google.javascript.rhino.Node$ObjectPropListItem@0000000608] does not have a condition.
         //
         verifyException("com.google.javascript.jscomp.NodeUtil", e);
      }
  }

  @Test(timeout = 4000)
  public void test099()  throws Throwable  {
      MockFile mockFile0 = new MockFile("com.google.jvascript.jscomp.AiasStrings");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      // Undeclared exception!
      try { 
        compiler0.parseSyntheticCode("com.google.jvascript.jscomp.AiasStrings", "com.google.jvascript.jscomp.AiasStrings");
       //  fail("Expecting exception: IllegalArgumentException");
       // Unstable assertion
      } catch(IllegalArgumentException e) {
         //
         // Multiple entries with same key: constructor=NOT_IMPLEMENTED and constructor=CONSTRUCTOR
         //
         verifyException("com.google.common.collect.ImmutableMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test100()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("prototype");
      Node node1 = new Node(63, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("prototype", codingConvention_AssertionFunctionSpec0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // ARRAYLIT : Array does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }
}
