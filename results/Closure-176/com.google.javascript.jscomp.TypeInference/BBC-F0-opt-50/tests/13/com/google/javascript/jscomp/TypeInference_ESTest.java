/*
 * This file was automatically generated by EvoSuite
 * Thu Oct 21 10:34:29 GMT 2021
 */

package com.google.javascript.jscomp;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.common.collect.ImmutableBiMap;
import com.google.common.collect.ImmutableSortedMap;
import com.google.javascript.jscomp.AbstractPeepholeOptimization;
import com.google.javascript.jscomp.ClosureCodingConvention;
import com.google.javascript.jscomp.CodingConvention;
import com.google.javascript.jscomp.CodingConventions;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerInput;
import com.google.javascript.jscomp.CompilerOptions;
import com.google.javascript.jscomp.ControlFlowGraph;
import com.google.javascript.jscomp.DataFlowAnalysis;
import com.google.javascript.jscomp.ExploitAssigns;
import com.google.javascript.jscomp.FindExportableNodes;
import com.google.javascript.jscomp.GoogleCodingConvention;
import com.google.javascript.jscomp.JqueryCodingConvention;
import com.google.javascript.jscomp.LinkedFlowScope;
import com.google.javascript.jscomp.LoggerErrorManager;
import com.google.javascript.jscomp.MemoizedScopeCreator;
import com.google.javascript.jscomp.MoveFunctionDeclarations;
import com.google.javascript.jscomp.NodeTraversal;
import com.google.javascript.jscomp.Normalize;
import com.google.javascript.jscomp.PeepholeCollectPropertyAssignments;
import com.google.javascript.jscomp.PeepholeFoldConstants;
import com.google.javascript.jscomp.PeepholeMinimizeConditions;
import com.google.javascript.jscomp.PeepholeRemoveDeadCode;
import com.google.javascript.jscomp.PeepholeReplaceKnownMethods;
import com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax;
import com.google.javascript.jscomp.Scope;
import com.google.javascript.jscomp.SyntacticScopeCreator;
import com.google.javascript.jscomp.TightenTypes;
import com.google.javascript.jscomp.Tracer;
import com.google.javascript.jscomp.TypeInference;
import com.google.javascript.jscomp.VarCheck;
import com.google.javascript.jscomp.VerboseMessageFormatter;
import com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.FlowScope;
import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;
import com.google.javascript.rhino.ErrorReporter;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.SimpleErrorReporter;
import com.google.javascript.rhino.jstype.BooleanLiteralSet;
import com.google.javascript.rhino.jstype.JSType;
import com.google.javascript.rhino.jstype.JSTypeNative;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import com.google.javascript.rhino.jstype.ModificationVisitor;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.SortedMap;
import java.util.Stack;
import java.util.TreeMap;
import java.util.Vector;
import java.util.function.Supplier;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.System;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class TypeInference_ESTest extends TypeInference_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test000()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Gmq2acO;yTo5Rm`c[K");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("SOURCELESS", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      Node node1 = new Node(61, node0, node0, node0, node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 61
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test001()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("SOlRCELESS", "SOlRCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Invalid delete operand.Only properties can be deleed.");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("Invalid delete operand.Only properties can be deleed.", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      Node node1 = Node.newString(14, "SOlRCELESS");
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LT SOlRCELESS : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test002()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getPropertyMap();
      FileSystemHandling.shouldAllThrowIOExceptions();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
      LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(13, 48, 38);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // NE 48 : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test003()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getPropertyMap();
      FileSystemHandling.shouldAllThrowIOExceptions();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newString(79, "v#PjF'W%j:Y7ovaxhb");
      Node.newString(42, "v#PjF'W%j:Y7ovaxhb");
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 79
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test004()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getReverseAbstractInterpreter();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      Node node1 = Node.newString(100, "SOURCELESS");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      tightenTypes0.getTypeRegistry();
      Node node2 = new Node(69, node1, node0, node1);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap1);
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node2, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 69
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test005()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseSyntheticCode("SOURCELESS", "SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(21);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test006()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getReverseAbstractInterpreter();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      Node node1 = Node.newString(100, "SOURCELESS");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      tightenTypes0.getTypeRegistry();
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      node1.addChildrenToFront(node1);
      typeInference0.createEntryLattice();
      typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: StackOverflowError");
      
      } catch(StackOverflowError e) {
      }
  }

  @Test(timeout = 4000)
  public void test007()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      Node node0 = compiler0.parseTestCode("DICT");
      boolean boolean0 = true;
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      compiler0.getState();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newString(154, "DICT", 4095, (-2678));
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope1, treeMap0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // STRING_KEY DICT does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test008()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getReverseAbstractInterpreter();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      Node node1 = Node.newString(100, "SOURCELESS");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      tightenTypes0.getTypeRegistry();
      JSType[] jSTypeArray0 = new JSType[0];
      node1.addChildrenToFront(node1);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: StackOverflowError");
      
      } catch(StackOverflowError e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void test009()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      Node node1 = Node.newString(91, "SOURCELESS");
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // ASSIGN_RSH SOURCELESS : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test010()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      Node node1 = Node.newString(19, "SOURCELESS");
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // RSH SOURCELESS : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test011()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Invalid delete operand. Only properties can be deleted.");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("Invalid delete operand. Only properties can be deleted.", codingConvention_AssertionFunctionSpec0);
      scope0.getTypeOfThis();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      Node node1 = Node.newString(44, "SOURCELESS");
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // TRUE SOURCELESS does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test012()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      logger0.fine("SOURCELESS");
      Node node1 = Node.newString(46, "SOURCELESS");
      Node node2 = new Node(98, node0, node1, node0);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node2, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test013()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("SOURCELESS");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("SOURCELESS", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      Node node1 = new Node(2, 36, 30);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      Node node2 = new Node(59, node1, node1, node1);
      FlowScope flowScope1 = typeInference0.flowThrough(node2, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test014()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseSyntheticCode("SOURCELESS", "SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
      LinkedFlowScope.createEntryLattice(scope0);
      compiler0.parseSyntheticCode("SOURCELESS", "SOURCELESS");
      Node node1 = Node.newString(99, "SOURCELESS");
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 99
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test015()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Invalid delete operand.Only properties can be deleed.");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("Invalid delete operand.Only properties can be deleed.", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      Node node1 = Node.newString(27, "SOURCELESS");
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // BITNOT SOURCELESS : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test016()  throws Throwable  {
      Logger logger0 = Logger.getAnonymousLogger();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("SOURCELESS");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("SOURCELESS", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      Node node1 = new Node(17, 12, 16);
      Node node2 = new Node(38, node1, node1, node1);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // GE 12 : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test017()  throws Throwable  {
      Logger logger0 = Logger.getAnonymousLogger();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, reverseAbstractInterpreter0, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(115);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // FOR does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test018()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getReverseAbstractInterpreter();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      Node node1 = Node.newString(100, "SOURCELESS");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      LinkedList<FlowScope> linkedList0 = new LinkedList<FlowScope>();
      tightenTypes0.getTypeRegistry();
      JSType[] jSTypeArray0 = new JSType[0];
      Node node2 = Node.newString("Object#Element");
      node1.addChildrenToFront(node2);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // STRING Object#Element does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test019()  throws Throwable  {
      Logger logger0 = Tracer.logger;
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      compiler0.getReverseAbstractInterpreter();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("F|mvVD[ZRjL", jSTypeNative0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("SOURCELESS", codingConvention_AssertionFunctionSpec0, "F|mvVD[ZRjL", codingConvention_AssertionFunctionSpec0, "com.google.javascript.jscomp.TypeInference$1", codingConvention_AssertionFunctionSpec0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap1 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newString(72, "com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer");
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap1);
      typeInference0.createEntryLattice();
      Node node2 = new Node(54, node1, node0, node0, node0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 72
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test020()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCE");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getReverseAbstractInterpreter();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newString(57, "SOURCE");
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      Node node2 = new Node(33, node0, node0, node0, node1);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // GETPROP : ? does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test021()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      int int0 = DataFlowAnalysis.MAX_STEPS;
      Node node1 = new Node(1, 32, 31);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      Node node2 = Node.newString(134, "SOURCELESS");
      LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 134
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test022()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Invalid delete operand. Only properties can be deleted.");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("Invalid delete operand. Only properties can be deleted.", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      Node node1 = Node.newString(20, "SOURCELESS");
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // URSH SOURCELESS : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test023()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node0);
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("SOURCELESS");
      compiler0.getReverseAbstractInterpreter();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(13, node0, node0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // NE : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test024()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newString(96, "");
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
      LinkedList<FlowScope> linkedList0 = new LinkedList<FlowScope>();
      typeInference0.createEntryLattice();
      LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // ASSIGN_DIV  : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test025()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, reverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      typeInference0.getCfg();
      Node node1 = Node.newString(108, ":|RUTDK?<0V49km");
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // IF :|RUTDK?<0V49km does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test026()  throws Throwable  {
      Logger logger0 = Logger.getAnonymousLogger();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(45, node0, node0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SHEQ : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test027()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELRSS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getReverseAbstractInterpreter();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      Node node1 = Node.newString(105, "SOURCELRSS");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      JSType[] jSTypeArray0 = new JSType[0];
      Node node2 = jSTypeRegistry0.createOptionalParameters(jSTypeArray0);
      node1.addChildrenToFront(node2);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test028()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope.createEntryLattice(scope0);
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      node0.isOnlyModifiesThisCall();
      typeInference0.createEntryLattice();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(67);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 67
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test029()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getReverseAbstractInterpreter();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      Node node1 = Node.newString(58, "O8%PS&o{?uw~eJQh$");
      typeInference0.createEntryLattice();
      LinkedList<FlowScope> linkedList0 = new LinkedList<FlowScope>();
      typeInference0.createEntryLattice();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 58
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test030()  throws Throwable  {
      Logger logger0 = Logger.getAnonymousLogger();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("HzQi");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createLatticeBottom(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("SOURCELESS");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("Fad(3>Q;3m<<", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      Node node1 = new Node(71, 33, 144);
      Node node2 = new Node(53);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope1);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      Node node3 = new Node(68, node1, node0, node2);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 71
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test031()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getReverseAbstractInterpreter();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      Node node1 = Node.newString(23, "O8%PS&o{?uw~eJQh$");
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      FlowScope flowScope1 = linkedFlowScope_FlowScopeJoinOp0.apply((FlowScope) linkedFlowScope0, flowScope0);
      typeInference0.branchedFlowThrough(node0, flowScope1);
      FlowScope flowScope2 = typeInference0.flowThrough(node1, flowScope1);
      assertNotSame(flowScope2, flowScope1);
  }

  @Test(timeout = 4000)
  public void test032()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      Scope scope1 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("SOURCELESS");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("com.google.javascript.jscomp.CustomPassExecutionTime", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      Node node1 = Node.newString(92, "1XCaOnAfl>");
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope1, immutableBiMap0);
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // ASSIGN_URSH 1XCaOnAfl> : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test033()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter1 = closureReverseAbstractInterpreter0.append(chainableReverseAbstractInterpreter0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter1, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "SOURCELESS");
      loggerErrorManager0.printSummary();
      compiler0.initCompilerOptionsIfTesting();
      Node.newString((-37), "Object#Element");
      typeInference0.createInitialEstimateLattice();
      Node node1 = Node.newString(63, "SOURCELESS");
      typeInference0.flowThrough(node1, linkedFlowScope0);
      System.setCurrentTimeMillis(47);
  }

  @Test(timeout = 4000)
  public void test034()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap2 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap3 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap2);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope1);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = Node.newString(34, "");
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap2);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      typeInference0.branchedFlowThrough(node0, flowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 34
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test035()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newString(4462, "jc7#e8AwqUR,+kyRS");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      node1.isOnlyModifiesThisCall();
      Node node2 = new Node(93, node0, node1, node0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test036()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getReverseAbstractInterpreter();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap2 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap3 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap1);
      ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap2);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = Node.newString(22, "");
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope1, treeMap0);
      PeepholeCollectPropertyAssignments peepholeCollectPropertyAssignments0 = new PeepholeCollectPropertyAssignments();
      Node node2 = peepholeCollectPropertyAssignments0.optimizeSubtree(node1);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SUB  : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test037()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Invalid delete ]peranB.ZOnly properties can be deleted.");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("Function literal argument refers to undefined this argument", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      Node node1 = Node.newString(81, "wqmJr:o2\"/T2=8");
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 81
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test038()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getReverseAbstractInterpreter();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      Node node1 = Node.newString(25, "O8%PS&o{?uw~eJQh$");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      typeInference0.branchedFlowThrough(node0, flowScope0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      JSType[] jSTypeArray0 = new JSType[0];
      Node node2 = jSTypeRegistry0.createOptionalParameters(jSTypeArray0);
      node1.addChildrenToFront(node2);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node1, flowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test039()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      Scope scope1 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope1, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node.newString(46, "SOURCELESS");
      Node node1 = Node.newString(62, "0)$Y!'");
      Node node2 = new Node(36, node1, node0, node0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 62
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test040()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      int int0 = DataFlowAnalysis.MAX_STEPS;
      Node node1 = new Node(54, 4095, (-3151));
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(110, node1, node1, node0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SWITCH does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test041()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      boolean boolean0 = true;
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
      Node node1 = Node.newString(125, "\"DWl)++)");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      FlowScope flowScope1 = linkedFlowScope_FlowScopeJoinOp0.apply(flowScope0, flowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // BLOCK \"DWl)++) does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test042()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      PeepholeMinimizeConditions peepholeMinimizeConditions0 = new PeepholeMinimizeConditions(true);
      Node node1 = peepholeMinimizeConditions0.optimizeSubtree(node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createGlobalScope(node1);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      int int0 = DataFlowAnalysis.MAX_STEPS;
      Node node2 = new Node(97, (-4936), 32);
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope1);
      typeInference0.flowThrough(node2, linkedFlowScope0);
      Node node3 = new Node(51, node0, node1, node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compilerOptions0.getCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = null;
      try {
        semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter((CodingConvention) null, jSTypeRegistry0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test043()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("kY");
      Node node1 = Node.newString(54, "SOURCELESS", 31, 147);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node1);
      compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope1, treeMap1);
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0, false);
      JSType jSType0 = modificationVisitor0.caseNullType();
      MoveFunctionDeclarations moveFunctionDeclarations0 = new MoveFunctionDeclarations(compiler0);
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0, (SyntacticScopeCreator.RedeclarationHandler) null);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, moveFunctionDeclarations0, syntacticScopeCreator0);
      nodeTraversal0.getInput();
      scope0.declare("kY", (Node) null, jSType0, (CompilerInput) null, true);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = Node.newString(147, "com.google.javascript.jscomp.graph.Graph$GraphAnnotationState");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      node1.isOnlyModifiesThisCall();
      Node node3 = new Node(100, node2, node0, node0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node3, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // OR does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test044()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newString((-1451), "^EpN");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      typeInference0.branchedFlowThrough(node0, flowScope0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      JSType[] jSTypeArray0 = new JSType[1];
      JSTypeNative jSTypeNative0 = JSTypeNative.NO_RESOLVED_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("E78O:.xRk&kef+!n", jSTypeNative0);
      JSType jSType0 = codingConvention_AssertionFunctionSpec0.getAssertedType(node1, jSTypeRegistry0);
      jSTypeArray0[0] = jSType0;
      Node node2 = jSTypeRegistry0.createOptionalParameters(jSTypeArray0);
      node1.addChildrenToFront(node0);
      FlowScope flowScope1 = typeInference0.flowThrough(node2, linkedFlowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // -1451
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test045()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("SOURCELESS");
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("SOURCELESS");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("", codingConvention_AssertionFunctionSpec1);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      JqueryCodingConvention jqueryCodingConvention1 = new JqueryCodingConvention(jqueryCodingConvention0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention1, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, immutableBiMap0);
      Node node1 = new Node(149, 3733, 789);
      Stack<FlowScope> stack0 = new Stack<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, treeMap0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // CONST 3733 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test046()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      compiler0.newCompilerOptions();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = Node.newString(138, "SOURCELESS");
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap1);
      typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 138
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test047()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter1 = closureReverseAbstractInterpreter0.append(chainableReverseAbstractInterpreter0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter1, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      compiler0.initCompilerOptionsIfTesting();
      Node node1 = Node.newString((-37), "Object#Element");
      Node node2 = new Node(28, node1, node1, node0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // POS : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test048()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter1 = compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Invalid delete ]peranB.ZOnly properties can be deleted.");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("Invalid delete ]peranB.ZOnly properties can be deleted.", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope1, immutableBiMap0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter1, scope0, immutableBiMap0);
      Node node1 = Node.newString(98, "wqmJr:o2\"/T2=8");
      FlowScope flowScope0 = typeInference1.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test049()  throws Throwable  {
      Logger.getGlobal();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node0);
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("SOURCELESS");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("Invalid delete operand. Only properties can be deleted.", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      Node node1 = Node.newString(153, "SOURCELESS");
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LABEL_NAME SOURCELESS does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test050()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      Node node1 = Node.newString(93, "SOURCELESS");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test051()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = Node.newString(104, "SOURCELESS");
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 104
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test052()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, reverseAbstractInterpreter0, scope0, treeMap0);
      LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(43);
      Node node2 = Node.newString((-953), "SOURCELESS");
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      Node node3 = new Node(37, node2, node2);
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node3, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // CALL does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test053()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.javascript.jscomp.TypeInference$1");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("com.google.javascript.jscomp.FunctionRewriter$GetterReducer", codingConvention_AssertionFunctionSpec0);
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      typeInference0.createEntryLattice();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope1);
      Node node1 = new Node(144, node0, node0, node0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 144
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test054()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, reverseAbstractInterpreter0, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(92, node0, node0, node0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // ASSIGN_URSH : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test055()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node0);
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("SOURCELESS");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("JSC_UNRAImEBLE_WARNING", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      Node node1 = Node.newString(57, "wqmJr:o2\"/T2=8");
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      Node node2 = new Node(147, node0, node0, node1);
      FlowScope flowScope1 = typeInference0.flowThrough(node2, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test056()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("F");
      compiler0.getTypeRegistry();
      controlFlowGraph0.getNodeDegree(node0);
      Node node1 = new Node(1, 32, (-2136));
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      Node node2 = new Node(73, node0, node1, node1);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 73
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test057()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      Scope scope1 = Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      Scope.createGlobalScope(node0);
      ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope1);
      Node node1 = new Node(6);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 6
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test058()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom((Node) null);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope1, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newString(46, "SOURCELESS");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      Node node2 = new Node(95, node0, node1, node1);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // ASSIGN_MUL : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test059()  throws Throwable  {
      Logger.getGlobal();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("x$Re8pdTFKCFr");
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("", codingConvention_AssertionFunctionSpec0);
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(151, node0, node0, node0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 151
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test060()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter1 = compiler0.getReverseAbstractInterpreter();
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Invalid delete peran. OnlyJroperties can be deleted.");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("Invalid delete peran. OnlyJroperties can be deleted.", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      Node node1 = new Node(85, node0, node0, node0);
      Scope.createGlobalScope(node1);
      Node node2 = new Node(2, 36, 30);
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter1, scope0, immutableBiMap0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSType[] jSTypeArray0 = new JSType[0];
      Node node3 = jSTypeRegistry0.createParametersWithVarArgs(jSTypeArray0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node3, flowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test061()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap1);
      scope0.resolveTypes();
      LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newString(135, "SOURCELESS");
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      Node node2 = new Node(37, node1, node1);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test062()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getReverseAbstractInterpreter();
      compiler0.getTopScope();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      Node node1 = new Node(6);
      node0.addChildrenToFront(node1);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 6
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test063()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("SOURCELESS");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("SOURCELESS", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      Node node1 = new Node(33, 38, 67);
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node1, flowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test064()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("SOURCELESS");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("com.google.javascript.jscomp.TypeInference$2", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      Node node1 = new Node(123, 47, 47);
      Node node2 = new Node(123);
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      typeInference0.createEntryLattice();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      VarCheck varCheck0 = new VarCheck(compiler0, true);
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      PeepholeFoldConstants peepholeFoldConstants0 = new PeepholeFoldConstants(false);
      peepholeFoldConstants0.optimizeSubtree(node1);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 123
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test065()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newString(12, "FQx|1,+B(f");
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      Node node2 = new Node(30, node0, node0, node1, 52, 54);
      typeInference0.flowThrough(node2, linkedFlowScope0);
      FlowScope flowScope2 = typeInference0.flowThrough(node0, flowScope1);
      assertNotSame(flowScope2, flowScope0);
  }

  @Test(timeout = 4000)
  public void test066()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      Node node1 = Node.newString(118, "SOURCELESS");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      typeInference0.branchedFlowThrough(node0, flowScope0);
      assertNotSame(flowScope0, flowScope1);
  }

  @Test(timeout = 4000)
  public void test067()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      boolean boolean0 = true;
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("Function literal argument refers to undefined this argument", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      Scope scope1 = Scope.createLatticeBottom(node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope1);
      Node node1 = Node.newNumber((double) 57);
      Node node2 = new Node(37, node0, node1, node1, node0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // NUMBER 57.0 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test068()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope1, treeMap1);
      LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(126);
      List<FlowScope> list0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test069()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap1);
      HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node((-402));
      Node node2 = compiler0.parseTestCode("SOURCELESS");
      Node node3 = new Node(137, node0, node0, node2, 54, (-793));
      FlowScope flowScope0 = typeInference0.flowThrough(node3, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test070()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Invalid delete operand. Only properties can be deleted.");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("Invalid delete operand. Only properties can be deleted.", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      Node node1 = new Node(2, 36, 30);
      Node node2 = Node.newString(94, "SOURCELESS");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      LinkedFlowScope linkedFlowScope0 = (LinkedFlowScope)typeInference0.createEntryLattice();
      typeInference0.createEntryLattice();
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      Node node3 = new Node(70, node1, node2, node1);
      typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      LinkedFlowScope linkedFlowScope3 = (LinkedFlowScope)typeInference0.flowThrough(node3, linkedFlowScope0);
      assertNotSame(linkedFlowScope3, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test071()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, reverseAbstractInterpreter0, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newString(116, "J,3@7rc>^>e1");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // BREAK J,3@7rc>^>e1 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test072()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter1 = compiler0.getReverseAbstractInterpreter();
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Invalid delete peran. Onlyproperties can be deleted.");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("Invalid delete peran. Onlyproperties can be deleted.", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      Node node1 = new Node(84, node0, node0, node0);
      Scope.createGlobalScope(node1);
      Node node2 = new Node(2, 36, 30);
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      typeInference0.createEntryLattice();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter1, scope0, immutableBiMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference1.flowThrough(node1, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test073()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      Scope scope1 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, reverseAbstractInterpreter0, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope1);
      Node.newString(75, "SOURCELESS");
      Node node1 = Node.newString(143, "SOURCELESS");
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 143
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test074()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getReverseAbstractInterpreter();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      Node node1 = Node.newString(100, "O8%PS&o{?uw~eJQh$");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      typeInference0.branchedFlowThrough(node0, flowScope0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      JSType[] jSTypeArray0 = new JSType[0];
      Node node2 = jSTypeRegistry0.createOptionalParameters(jSTypeArray0);
      node1.addChildrenToFront(node2);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node1, flowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test075()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Invalid delete operand. Only properties can be deleted.");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("Invalid delete operand. Only properties can be deleted.", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      Node node1 = new Node(2, 36, 30);
      Node node2 = Node.newString(94, "SOURCELESS");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node2, flowScope0);
      assertNotSame(flowScope1, flowScope0);
      
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.TRUE;
      BooleanLiteralSet booleanLiteralSet1 = BooleanLiteralSet.EMPTY;
      BooleanLiteralSet booleanLiteralSet2 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet1, true);
      assertEquals(BooleanLiteralSet.EMPTY, booleanLiteralSet2);
  }

  @Test(timeout = 4000)
  public void test076()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope1, immutableSortedMap0);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph1, reverseAbstractInterpreter0, scope0, treeMap0);
      ControlFlowGraph<Node> controlFlowGraph2 = typeInference1.getCfg();
      TypeInference typeInference2 = new TypeInference(compiler0, controlFlowGraph2, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      Node node1 = Node.newString(155, "");
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // CAST  does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test077()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      Scope scope1 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, reverseAbstractInterpreter0, scope0, treeMap0);
      LinkedFlowScope.createEntryLattice(scope1);
      Node node1 = Node.newString(75, "SOURCELESS");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node0, flowScope0);
      Node node2 = new Node(122, node1, node0, node1, 2, 29);
      FlowScope flowScope2 = typeInference0.flowThrough(node2, flowScope1);
      assertNotSame(flowScope2, flowScope1);
  }

  @Test(timeout = 4000)
  public void test078()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      Scope.createGlobalScope(node0);
      Scope scope1 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope1, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newString(129, "SOURCELESS");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      typeInference0.flowThrough(node1, flowScope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test079()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter1 = compiler0.getReverseAbstractInterpreter();
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Invalid delete peran. Onlyproperties can be deleted.");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("Invalid delete peran. Onlyproperties can be deleted.", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      Node node1 = new Node(85, node0, node0, node0);
      Scope.createGlobalScope(node1);
      Node node2 = new Node(2, 36, 30);
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter1, scope0, immutableBiMap0);
      FlowScope flowScope1 = typeInference0.createEntryLattice();
      FlowScope flowScope2 = typeInference1.flowThrough(node1, flowScope1);
      assertNotSame(flowScope2, flowScope0);
  }

  @Test(timeout = 4000)
  public void test080()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("D5Jhh?j1Ik@VmcLvkf");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("SOURCELESS", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope1);
      linkedFlowScope0.getTypeOfThis();
      LinkedFlowScope linkedFlowScope1 = LinkedFlowScope.createEntryLattice(scope1);
      Node node1 = new Node(119);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // WITH does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test081()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Invalid delete operand. Only properties can be deleted.");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("Invalid delete operand. Only properties can be deleted.", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      Node.newString(142, "Invalid delete operand. Only properties can be deleted.");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      Node node1 = Node.newString(154, "SOURCELESS");
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      FlowScope flowScope0 = typeInference1.createEntryLattice();
      FlowScope flowScope1 = typeInference1.flowThrough(node0, flowScope0);
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node1, flowScope1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // STRING_KEY SOURCELESS does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test082()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getReverseAbstractInterpreter();
      compiler0.getTopScope();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      Node node1 = new Node(101, node0, node0, node0, node0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // AND does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test083()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      Node node1 = new Node(1185, node0, node0, node0);
      Scope.createGlobalScope(node0);
      Node node2 = new Node(120, (-309), 54);
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      typeInference0.createEntryLattice();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node2, flowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test084()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      Scope scope1 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, reverseAbstractInterpreter0, scope0, treeMap0);
      LinkedFlowScope.createEntryLattice(scope1);
      Node node1 = Node.newString(75, "SOURCELESS");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node0, flowScope0);
      Node node2 = new Node(117, node1, node0, node1, 2, 29);
      FlowScope flowScope2 = typeInference0.flowThrough(node2, flowScope1);
      assertNotSame(flowScope2, flowScope1);
  }

  @Test(timeout = 4000)
  public void test085()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      ReverseAbstractInterpreter reverseAbstractInterpreter1 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newString(134, "");
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter1, scope0, treeMap1);
      typeInference0.flowThrough(node0, linkedFlowScope0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 134
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test086()  throws Throwable  {
      Logger.getGlobal();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("G.");
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("SOURCELESS");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("G.", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newNumber((-1477.8873975122378));
      Node node2 = new Node(139, node0, node0, node1, node1);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 139
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test087()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getReverseAbstractInterpreter();
      Scope.createLatticeBottom((Node) null);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      Node.newString(15, "SOURCELESS");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
      Node node1 = new Node(109);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap1);
      typeInference1.flowThrough(node1, flowScope0);
      typeInference1.createEntryLattice();
      ExploitAssigns exploitAssigns0 = new ExploitAssigns();
      // Undeclared exception!
      try { 
        AbstractPeepholeOptimization.validateResult(node1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test088()  throws Throwable  {
      Logger logger0 = Tracer.logger;
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter1 = compiler0.getReverseAbstractInterpreter();
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("SOURCELESS");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("'vTh:O}%@ScM!-;%-", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      ControlFlowGraph<Node> controlFlowGraph1 = typeInference0.getCfg();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph1, reverseAbstractInterpreter1, scope0, immutableBiMap0);
      Node node1 = new Node(122, node0, node0, node0);
      Scope scope1 = Scope.createGlobalScope(node1);
      Node node2 = new Node(150, 50, 53);
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      TypeInference typeInference2 = new TypeInference(compiler0, controlFlowGraph1, reverseAbstractInterpreter0, scope1, immutableBiMap0);
      typeInference0.createEntryLattice();
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, (JSTypeRegistry) null);
      TypeInference typeInference3 = new TypeInference(compiler0, controlFlowGraph1, closureReverseAbstractInterpreter0, scope0, immutableBiMap0);
      // Undeclared exception!
      try { 
        typeInference3.branchedFlowThrough(node2, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 150
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test089()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      PeepholeReplaceKnownMethods peepholeReplaceKnownMethods0 = new PeepholeReplaceKnownMethods(false);
      Node node1 = peepholeReplaceKnownMethods0.optimizeSubtree(node0);
      Node node2 = new Node(137, node0, node0, node1, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, false, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node2);
      ReverseAbstractInterpreter reverseAbstractInterpreter1 = compiler0.getReverseAbstractInterpreter();
      Node node3 = Normalize.parseAndNormalizeTestCode(compiler0, "k7ehxW|37$;V|+vkZ]");
      Scope.createGlobalScope(node3);
      Scope scope0 = Scope.createGlobalScope(node1);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, true);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, reverseAbstractInterpreter1, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      Node.newString(1190, "k7ehxW|37$;V|+vkZ]");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph1, reverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      FlowScope flowScope0 = typeInference1.createEntryLattice();
      scope0.resolveTypes();
      PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
      Node node4 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
      typeInference1.flowThrough(node4, flowScope0);
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node2, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 137
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test090()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Invalid delete operand. Only properties can be deleted.");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("Invalid delete operand. Only properties can be deleted.", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      Node node1 = new Node(2, 36, 30);
      Node node2 = Node.newString(111, "Invalid delete operand. Only properties can be deleted.");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      Vector<FlowScope> vector1 = new Vector<FlowScope>();
      CodingConvention codingConvention0 = compiler0.getCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(codingConvention0, jSTypeRegistry0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableBiMap0);
      FlowScope flowScope0 = typeInference1.createEntryLattice();
      FlowScope flowScope1 = typeInference1.flowThrough(node2, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test091()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "F^@0*");
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope1, immutableSortedMap0);
      LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newString(42, "");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      Vector<FlowScope> vector1 = new Vector<FlowScope>();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope1, immutableSortedMap0);
      typeInference0.createEntryLattice();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope1);
      typeInference0.flowThrough(node1, linkedFlowScope0);
      typeInference1.createEntryLattice();
      System.setCurrentTimeMillis(1663L);
  }

  @Test(timeout = 4000)
  public void test092()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter1 = compiler0.getReverseAbstractInterpreter();
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Invalid delete operand. Only properties can be deleted.");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("Invalid delete operand. Only properties can be deleted.", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      Node node1 = new Node(85, node0, node0, node0);
      Scope.createGlobalScope(node1);
      Node node2 = new Node(2, 36, 30);
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      typeInference0.createEntryLattice();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter1, scope0, immutableBiMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // COMMA : ? does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test093()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node0);
      Node node1 = compiler0.parseSyntheticCode("SOURCELESS");
      Scope scope0 = Scope.createGlobalScope(node1);
      compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("SOURCELESS");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope1, immutableBiMap0);
      Node node2 = Node.newString(133, "");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      FlowScope flowScope1 = typeInference1.flowThrough(node0, flowScope0);
      typeInference0.branchedFlowThrough(node0, flowScope1);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;
      BooleanLiteralSet booleanLiteralSet1 = BooleanLiteralSet.BOTH;
      BooleanLiteralSet booleanLiteralSet2 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet1, false);
      assertEquals(BooleanLiteralSet.BOTH, booleanLiteralSet2);
      
      FlowScope flowScope2 = typeInference0.flowThrough(node2, flowScope1);
      assertNotSame(flowScope2, flowScope1);
      
      BooleanLiteralSet booleanLiteralSet3 = BooleanLiteralSet.TRUE;
      BooleanLiteralSet booleanLiteralSet4 = BooleanLiteralSet.EMPTY;
      BooleanLiteralSet booleanLiteralSet5 = TypeInference.getBooleanOutcomes(booleanLiteralSet3, booleanLiteralSet4, false);
      assertEquals(BooleanLiteralSet.TRUE, booleanLiteralSet5);
  }

  @Test(timeout = 4000)
  public void test094()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("G.");
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("'vah:O}w@2ScM!-;%-");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("", codingConvention_AssertionFunctionSpec1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(36);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 36
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test095()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("G.");
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("'vah:O}w@2ScM!-;%-");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("", codingConvention_AssertionFunctionSpec1);
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      typeInference0.flowThrough(node0, flowScope0);
      Node node1 = new Node(33, node0, node0, node0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // SCRIPT 1 [synthetic: com.google.javascript.rhino.Node$IntPropListItem@0000000619] [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000000620] [input_id: com.google.javascript.rhino.Node$ObjectPropListItem@0000000621] is not a string node
         //
         verifyException("com.google.javascript.rhino.Node", e);
      }
  }

  @Test(timeout = 4000)
  public void test096()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      boolean boolean0 = true;
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      compiler0.getTypeRegistry();
      controlFlowGraph0.getNodeDegree(node0);
      Node node1 = new Node((-26), 47, 123);
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node0, flowScope0);
      Node node2 = new Node(4, node1, node0, node1);
      PeepholeRemoveDeadCode peepholeRemoveDeadCode0 = new PeepholeRemoveDeadCode();
      Node node3 = peepholeRemoveDeadCode0.optimizeSubtree(node2);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node3, flowScope1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // RETURN does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test097()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Invalid delete operand. Only properties can be deleted.");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("Invalid delete operand. Only properties can be deleted.", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      Node node1 = Node.newString(142, "Invalid delete operand. Only properties can be deleted.");
      Node node2 = new Node(57);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = reverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node2, linkedFlowScope0, false);
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      typeInference0.branchedFlowThrough(node0, flowScope1);
      FlowScope flowScope2 = typeInference0.flowThrough(node0, flowScope1);
      Node node3 = new Node(42, node0, 957, (-1847));
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node3, flowScope2);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // THIS does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test098()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Invalid delete operand. Only properties can be deleted.");
      ImmutableBiMap.of("Invalid delete operand. Only properties can be deleted.", codingConvention_AssertionFunctionSpec0);
      Level level0 = Level.ALL;
      logger0.setLevel(level0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      linkedFlowScope0.getTypeOfThis();
      Scope scope1 = Scope.createGlobalScope(node0);
      Node node1 = Node.newString(15, "SOURCELESS");
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope1, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LE SOURCELESS : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test099()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      Scope.createGlobalScope(node0);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      Node node1 = Node.newString(145, "SOURCELESS");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      typeInference0.flowThrough(node1, flowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 145
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test100()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter1 = compiler0.getReverseAbstractInterpreter();
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("SOURCELESS");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("'vTh:O}%@ScM!-;%-", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      ControlFlowGraph<Node> controlFlowGraph1 = typeInference0.getCfg();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph1, reverseAbstractInterpreter1, scope0, immutableBiMap0);
      Node node1 = new Node(106, (-2261), (-317));
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference1.flowThrough(node1, flowScope0);
      Node node2 = new Node((-2784), node0, node1, node1);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough((Node) null, flowScope1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test101()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("F");
      compiler0.getTypeRegistry();
      controlFlowGraph0.getNodeDegree(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("", codingConvention_AssertionFunctionSpec0);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(131);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 131
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test102()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getReverseAbstractInterpreter();
      compiler0.getTopScope();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      immutableSortedMap0.subMap("JSC_FUNCTION_LITERAL_UNDEFINED_THIS", "SOURCELESS");
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("n@A1?$*h~b\"aXQGPP");
      ImmutableBiMap.of("9Yg(cflPuOfB", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
      Node.newString("TZk=1%#2!BBUZ9");
      Node node1 = new Node(89, 723, 147);
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      typeInference0.flowThrough(node1, flowScope0);
      Node node2 = new Node(16, node1, node1, node1);
      FlowScope flowScope1 = typeInference0.createEntryLattice();
      FlowScope flowScope2 = typeInference0.flowThrough(node1, flowScope0);
      assertNotSame(flowScope2, flowScope1);
  }

  @Test(timeout = 4000)
  public void test103()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap2 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap3 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap2);
      ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap3);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newString(152, "com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      Stack<FlowScope> stack0 = new Stack<FlowScope>();
      Node node2 = new Node(130, node1, node1, node0, 1, 15);
      node2.isOnlyModifiesArgumentsCall();
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      FlowScope flowScope1 = reverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node1, flowScope0, true);
      FlowScope flowScope2 = typeInference0.flowThrough(node2, flowScope1);
      assertNotSame(flowScope2, flowScope1);
  }

  @Test(timeout = 4000)
  public void test104()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Invalid delete operand. Only properties can be deleted.");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("Invalid delete operand. Only properties can be deleted.", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      Node node1 = new Node(2, 36, 30);
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      Node node2 = new Node(111, node1, node0, node1);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // CASE does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test105()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("F");
      compiler0.getTypeRegistry();
      controlFlowGraph0.getNodeDegree(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer");
      Node node1 = new Node(1, 32, (-2136));
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node0, flowScope0);
      Node node2 = new Node(73, node0, node1, node1);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 73
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test106()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom((Node) null);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope1, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newString(113, "O8%PS&o{?uw~eJQh$");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      Vector<FlowScope> vector1 = new Vector<FlowScope>();
      typeInference0.createEntryLattice();
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test107()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node0);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, reverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      Node node1 = Node.newString(8, "SOURCELESS");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      Scope scope1 = Scope.createGlobalScope(node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope1);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = linkedFlowScope0.createChildFlowScope();
      typeInference0.branchedFlowThrough(node0, flowScope0);
      System.setCurrentTimeMillis((-1168L));
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 8
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test108()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getReverseAbstractInterpreter();
      compiler0.getTopScope();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap1);
      immutableSortedMap0.subMap("JSC_FUNCTION_LITERAL_UNDEFINED_THIS", "SOURCELESS");
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("n@A1?$*h~b\"aXQGPP");
      ImmutableBiMap.of("9Yg(cflPuOfB", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
      Node.newString("TZk=1%#2!BBUZ9");
      Node node1 = new Node(112, 723, 147);
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      Node node2 = new Node(16, node1, node1, node1);
      typeInference0.branchedFlowThrough(node0, flowScope1);
      typeInference0.createInitialEstimateLattice();
      FlowScope flowScope2 = typeInference0.createEntryLattice();
      assertNotSame(flowScope2, flowScope1);
  }

  @Test(timeout = 4000)
  public void test109()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("F");
      compiler0.getTypeRegistry();
      controlFlowGraph0.getNodeDegree(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("SOURCELESS");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("com.google.javascript.jscomp.TypeInference$BooleanOutcomePair", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(148);
      typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      typeInference0.branchedFlowThrough(node0, flowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
      assertNotSame(linkedFlowScope0, flowScope0);
  }

  @Test(timeout = 4000)
  public void test110()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("F");
      compiler0.getTypeRegistry();
      controlFlowGraph0.getNodeDegree(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer");
      controlFlowGraph0.getEdges();
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("com.google.javascript.jscomp.TypeInference$BooleanOutcomePair", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      Node node1 = Node.newString(29, "qDkR,cz2+Gr(");
      immutableBiMap0.toString();
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node1, flowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test111()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap1);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = Node.newString(141, "SOURCELESS");
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;
      TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      typeInference0.createEntryLattice();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      FlowScope flowScope2 = typeInference0.flowThrough(node0, flowScope1);
      assertNotSame(flowScope2, flowScope0);
  }

  @Test(timeout = 4000)
  public void test112()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getReverseAbstractInterpreter();
      compiler0.getTopScope();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap1);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap1 = immutableSortedMap0.subMap("JSC_FUNCTION_LITERAL_UNDEFINED_THIS", "SOURCELESS");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap2 = immutableSortedMap1.headMap("SOURCELESS", true);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap2);
      LinkedFlowScope.createEntryLattice((Scope) null);
      Node node1 = Node.newString(127, "d`KB_");
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;
      TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      typeInference0.createEntryLattice();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      FlowScope flowScope2 = typeInference0.flowThrough(node1, flowScope0);
      assertNotSame(flowScope2, flowScope1);
  }

  @Test(timeout = 4000)
  public void test113()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Invalid delete operand. Only properties can be deleted.");
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, reverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope.createEntryLattice(scope1);
      Node node1 = Node.newString(8, "SOURCELESS");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      typeInference0.flowThrough(node0, flowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 8
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test114()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getTopScope();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Supplier<String> supplier0 = (Supplier<String>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      doReturn((Object) null).when(supplier0).get();
      logger0.finer(supplier0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      Node node1 = Node.newString(43, "3KJI&!\"_p]B7");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      Stack<FlowScope> stack0 = new Stack<FlowScope>();
      Node node2 = new Node(136, node1, node1, node1, 8, 132);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test115()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope1, immutableSortedMap0);
      LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newString(136, "JSC_FUNCTION_LITERAL_UNDEFINED_THIS");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test116()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      Scope scope1 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, reverseAbstractInterpreter0, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope1);
      Node node1 = Node.newString(75, "SOURCELESS");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      Node node2 = new Node(49, node0, node0, node0, node1);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // THROW does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test117()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newString(152, "SOURCELESS");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      Vector<FlowScope> vector1 = new Vector<FlowScope>();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // DEBUGGER SOURCELESS does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test118()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newString(38, "Symbol not found in table ");
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;
      BooleanLiteralSet booleanLiteralSet1 = BooleanLiteralSet.BOTH;
      BooleanLiteralSet booleanLiteralSet2 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet1, true);
      assertEquals(BooleanLiteralSet.BOTH, booleanLiteralSet2);
      
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      typeInference0.createEntryLattice();
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test119()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Invalid delete operand. Only properties can be deleted.");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("Invalid delete operand. Only properties can be deleted.", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      Node node1 = Node.newString(142, "Invalid delete operand. Only properties can be deleted.");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      typeInference0.flowThrough(node1, flowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 142
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test120()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getReverseAbstractInterpreter();
      compiler0.getTopScope();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope.createEntryLattice((Scope) null);
      Node node1 = Node.newString(124, "3KJI&!\"_p]B7");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test121()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Invalid delete operand. Only properties can be deleted.");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("Invalid delete operand. Only properties can be deleted.", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      Node node1 = Node.newString(2, "%~");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      Node node2 = new Node(139, node1, node0, node1);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 139
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test122()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap1);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      linkedFlowScope1.getTypeOfThis();
      Node node1 = Node.newString(135, "SOURCELESS");
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 135
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test123()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      linkedFlowScope1.getTypeOfThis();
      Node node1 = Node.newString(107, "eV *o(~=~");
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 107
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test124()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom((Node) null);
      Scope scope1 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope1, immutableSortedMap0);
      LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newString(48, "O8%PS&o{?uw~eJQh$");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      FlowScope flowScope2 = typeInference0.flowThrough(node1, flowScope1);
      assertNotSame(flowScope2, flowScope1);
  }

  @Test(timeout = 4000)
  public void test125()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("G.");
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("'vah:O}w@2ScM!-;%-");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("", codingConvention_AssertionFunctionSpec1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope1, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(15, node0, node0, node0, node0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LE : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test126()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope1, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(32);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // TYPEOF : string does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test127()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter1 = compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Invalid delete operand. Only properties can be deleted.");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("com.google.javascript.jscomp.GatherCharacterEncodingBias", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter1, scope1, immutableBiMap0);
      Node node1 = Node.newString(30, "SOURCELESS");
      Node.newString(400000, "JSC_FUNCTION_LITERAL_UNDEFINED_THIS");
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test128()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createGlobalScope(node0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) immutableSortedMap0);
      scope0.getTypeOfThis();
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope1, immutableSortedMap0);
      LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newString(52, "SOURCELESS");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      typeInference0.flowThrough(node1, flowScope0);
      typeInference0.branchedFlowThrough(node0, flowScope0);
      FlowScope flowScope1 = typeInference0.createInitialEstimateLattice();
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test129()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Invalid delete operand. Only properties can be deleted.");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("com.google.javascript.jscomp.GatherCharacterEncodingBias", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      Node node1 = Node.newString(30, "SOURCELESS");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      FlowScope flowScope0 = typeInference1.createEntryLattice();
      Node node2 = new Node(38, node1, node1, 2, 40);
      // Undeclared exception!
      try { 
        typeInference1.flowThrough(node2, flowScope0);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // NAME 2 is not a string node
         //
         verifyException("com.google.javascript.rhino.Node", e);
      }
  }

  @Test(timeout = 4000)
  public void test130()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createGlobalScope((Node) null);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, reverseAbstractInterpreter0, scope0, treeMap1);
      LinkedFlowScope.createEntryLattice(scope1);
      Node node1 = Node.newString(75, "SOURCELESS");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      typeInference0.flowThrough(node0, flowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 75
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test131()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap1);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      linkedFlowScope0.getTypeOfThis();
      Node node1 = Node.newString(5, "goog.getCssName");
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap1 = ImmutableSortedMap.copyOf((Map<? extends String, ? extends CodingConvention.AssertionFunctionSpec>) immutableSortedMap0, (Comparator<? super String>) comparator0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap1);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 5
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test132()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap1);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      linkedFlowScope0.getTypeOfThis();
      Node node1 = Node.newString(5, "goog.getCssName");
      Node.newString(2, "SHP$");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
      typeInference0.createEntryLattice();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      FlowScope flowScope0 = linkedFlowScope0.createChildFlowScope();
      FlowScope flowScope1 = typeInference1.flowThrough(node1, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test133()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = (SemanticReverseAbstractInterpreter)compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(":5w}nt-|hj");
      ImmutableBiMap.of(".&", codingConvention_AssertionFunctionSpec0);
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.getCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter1 = (SemanticReverseAbstractInterpreter)closureReverseAbstractInterpreter0.append(semanticReverseAbstractInterpreter0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap1 = immutableSortedMap0.subMap(":5w}nt-|hj", false, "pAU02;=", false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter1, scope0, immutableSortedMap1);
      Node node1 = Node.newString(128, "7V\t*Qdq.");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      LinkedFlowScope linkedFlowScope0 = (LinkedFlowScope)typeInference0.createEntryLattice();
      typeInference0.flowThrough(node1, linkedFlowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, (FlowScope) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test134()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createGlobalScope((Node) null);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, reverseAbstractInterpreter0, scope0, treeMap1);
      LinkedFlowScope.createEntryLattice(scope1);
      Node node1 = Node.newString(128, "SOURCELESS");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      typeInference0.flowThrough(node0, flowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 128
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test135()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("-XkbX|`");
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      linkedFlowScope1.getTypeOfThis();
      Scope.createGlobalScope(node0);
      Node node1 = Node.newString(140, "JSC_FUNCTION_LITERAL_UNDEFINED_THIS");
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope1, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 140
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test136()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom((Node) null);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope1, immutableSortedMap0);
      LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newString(103, "O8%PS&o{?uw~eJQh$");
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.TRUE;
      TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough((Node) null, flowScope1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test137()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("F");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      codingConvention_AssertionFunctionSpec0.getAssertedType(node0, jSTypeRegistry0);
      controlFlowGraph0.getNodeDegree(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("com.google.javascript.jscomp.TypeInference$BooleanOutcomePair", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(146);
      typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test138()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getReverseAbstractInterpreter();
      Node node1 = null;
      Scope scope0 = Scope.createLatticeBottom((Node) null);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope1, immutableSortedMap0);
      LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = Node.newString(100, "O8%PS&o{?uw~eJQh$");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node2, flowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void test139()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Invalid delete operand. Only properties can be deleted.");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("Invalid delete operand. Only properties can be deleted.", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      Node node1 = Node.newString(16, "^.@au6-EE#");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      typeInference0.flowThrough(node1, flowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // GT ^.@au6-EE# : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test140()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom((Node) null);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope1, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(56);
      typeInference0.createEntryLattice();
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test141()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(",");
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("NKq~[?qZXkN&'[?F$|");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      codingConvention_AssertionFunctionSpec0.getAssertedType(node0, jSTypeRegistry0);
      ImmutableBiMap.of("Mm[}Rou./", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope1);
      Node node1 = new Node(47);
      typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test142()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter1 = compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter1, scope1, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newString(40, "3KJI&!\"_p]B7");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap1);
      typeInference1.createEntryLattice();
      FlowScope flowScope0 = typeInference1.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
      
      System.setCurrentTimeMillis(54);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      BooleanLiteralSet booleanLiteralSet1 = BooleanLiteralSet.EMPTY;
      BooleanLiteralSet booleanLiteralSet2 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet1, false);
      assertEquals(BooleanLiteralSet.TRUE, booleanLiteralSet2);
  }

  @Test(timeout = 4000)
  public void test143()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap1);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      linkedFlowScope1.getTypeOfThis();
      Node node1 = Node.newString(37, "Not declared as a constructor");
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap1);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test144()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getReverseAbstractInterpreter();
      Node node1 = null;
      Scope scope0 = Scope.createLatticeBottom((Node) null);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope1, immutableSortedMap0);
      LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = Node.newString(101, "O8%PS&o{?uw~eJQh$");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node2, flowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void test145()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("SOURCELESS", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope1);
      Node node1 = Node.newString(49, "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      typeInference0.createEntryLattice();
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test146()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("'vah:O}w@2ScM!-;%-");
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("`jQ0:");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("`jQ0:", codingConvention_AssertionFunctionSpec1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(43);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // FALSE does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test147()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("D5Jhh?j1Ik@VmcLvkf");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope1);
      linkedFlowScope0.getTypeOfThis();
      Node node1 = Node.newString(121, "CX&%;Y+AqSTL3m7TY");
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 121
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test148()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom((Node) null);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope1, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newString(46, "JavaImporter");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      typeInference0.createEntryLattice();
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough((Node) null, flowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test149()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "");
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      boolean boolean0 = true;
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("C=zbuQJoU xhW$Ocm");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(57);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 57
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test150()  throws Throwable  {
      Logger logger0 = Logger.getAnonymousLogger();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      Node node0 = compiler0.parseTestCode("com.google.javascript.jscomp.TypeInference$1");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      Node node1 = new Node(817);
      Scope.createGlobalScope(node1);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.javascript.jscomp.TypeInference$1");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("'vah:O}w@2ScM!-;%-", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(54);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 54
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test151()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("'vah:O}w@2ScM!-;%-");
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("SOURCELESS");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("SOURCELESS", codingConvention_AssertionFunctionSpec1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(4);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // RETURN does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test152()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter1 = compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("Function literal argument refers to undefined this argument", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter1, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      linkedFlowScope0.getTypeOfThis();
      Node node1 = Node.newString(12, "JSC_FUNCTION_LITERAL_UNDEFINED_THIS");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope1, immutableBiMap0);
      FlowScope flowScope0 = typeInference1.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test153()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
      LinkedFlowScope.createEntryLattice(scope1);
      Node node1 = Node.newString(39, "SOURCELESS");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test154()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("'vah:O}w@2ScM!-;%-");
      ImmutableBiMap.of("", codingConvention_AssertionFunctionSpec0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope1, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newString(114, "3KJI&!\"_p]B7");
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      typeInference0.createEntryLattice();
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test155()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("Function literal argument refers to undefined this argument", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      linkedFlowScope0.getTypeOfThis();
      linkedFlowScope0.inferSlotType((String) null, (JSType) null);
      Node node1 = new Node(55);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 55
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test156()  throws Throwable  {
      Logger logger0 = Logger.getAnonymousLogger();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      Node node0 = compiler0.parseTestCode("com.google.javascript.jscomp.TypeInference$1");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.javascript.jscomp.TypeInference$1");
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
      codingConvention_AssertionFunctionSpec0.getAssertedType(node0, jSTypeRegistry0);
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_TRUE;
      controlFlowGraph0.connect(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SCRIPT 1 [synthetic: com.google.javascript.rhino.Node$IntPropListItem@0000000639] [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000000640] [input_id: com.google.javascript.rhino.Node$ObjectPropListItem@0000000641] does not have a condition.
         //
         verifyException("com.google.javascript.jscomp.NodeUtil", e);
      }
  }

  @Test(timeout = 4000)
  public void test157()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      Scope scope1 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("");
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("/n2z]>LP^po:827Vn");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("43P%9w:a|V?1", codingConvention_AssertionFunctionSpec1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      Compiler.setLoggingLevel((Level) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope1);
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      codingConvention_AssertionFunctionSpec1.getAssertedType(node0, jSTypeRegistry0);
      Node node1 = new Node(51);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // IN : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test158()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("SOURCELESS");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("'vah:O}w@2ScM!-;%-", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope1, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(50);
      typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test159()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("'vah:O}w@2ScM!-;%-");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("'vah:O}w@2ScM!-;%-", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope1, immutableBiMap0);
      LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newString(31, "SOURCELESS");
      List<FlowScope> list0 = new Vector<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test160()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      compiler0.getReverseAbstractInterpreter();
      Scope scope1 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("'vah:O}w@2ScM!-;%-");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("'vah:O}w@2ScM!-;%-", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope1, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(53);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 53
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test161()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      JSTypeNative jSTypeNative0 = JSTypeNative.NO_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("SOURCELESS", jSTypeNative0);
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("SOURCELESS", codingConvention_AssertionFunctionSpec0);
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_FALSE;
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      codingConvention_AssertionFunctionSpec0.getAssertedType(node0, jSTypeRegistry0);
      controlFlowGraph0.connect(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SCRIPT 1 [synthetic: com.google.javascript.rhino.Node$IntPropListItem@0000000619] [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000000620] [input_id: com.google.javascript.rhino.Node$ObjectPropListItem@0000000621] does not have a condition.
         //
         verifyException("com.google.javascript.jscomp.NodeUtil", e);
      }
  }

  @Test(timeout = 4000)
  public void test162()  throws Throwable  {
      Logger logger0 = Logger.getLogger("?Vu)]tJBt%V`=M2_", (String) null);
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      loggerErrorManager0.getErrors();
      Node node0 = compiler0.parseTestCode("OBJECT_PROTOTYPE");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      JSTypeNative jSTypeNative0 = JSTypeNative.ALL_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("SOURCELESS", jSTypeNative0);
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("R/pL z*ZUKqAixQ", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newString(1165, "SOURCELESS", 302, 55);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 1165
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test163()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      JSTypeNative jSTypeNative0 = JSTypeNative.UNKNOWN_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("|KD@A4:)0JHL", jSTypeNative0);
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("q*O_*Czx._RlXk?a(WF", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableBiMap0);
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node0, (FlowScope) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test164()  throws Throwable  {
      Logger logger0 = Logger.getLogger("|KD@A4:)0JHL");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      JSTypeNative jSTypeNative0 = JSTypeNative.ALL_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("aliasStrings", jSTypeNative0);
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("SOURCELESS", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      FlowScope flowScope0 = null;
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node0, (FlowScope) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test165()  throws Throwable  {
      Logger logger0 = Tracer.logger;
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      tightenTypes0.getTopScope();
      TightenTypes.ConcreteScope tightenTypes_ConcreteScope0 = tightenTypes0.new ConcreteScope((TightenTypes.ConcreteScope) null);
      tightenTypes_ConcreteScope0.getRootNode();
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      JSTypeNative jSTypeNative0 = JSTypeNative.DATE_FUNCTION_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("", jSTypeNative0);
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("?:Mvs?&TX-I.Y2!", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SCRIPT 1 [synthetic: com.google.javascript.rhino.Node$IntPropListItem@0000000619] [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000000620] [input_id: com.google.javascript.rhino.Node$ObjectPropListItem@0000000621] does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test166()  throws Throwable  {
      Logger logger0 = Tracer.logger;
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Supplier<String> supplier0 = (Supplier<String>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      logger0.finest(supplier0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      JSTypeNative jSTypeNative0 = JSTypeNative.FUNCTION_INSTANCE_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("SOURCELESS", jSTypeNative0);
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
      FlowScope flowScope1 = linkedFlowScope_FlowScopeJoinOp0.apply(flowScope0, flowScope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope1);
      assertTrue(list0.isEmpty());
      
      FlowScope flowScope2 = typeInference0.flowThrough(node0, flowScope0);
      assertSame(flowScope2, flowScope0);
  }

  @Test(timeout = 4000)
  public void test167()  throws Throwable  {
      Logger logger0 = Tracer.logger;
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      JSTypeNative jSTypeNative0 = JSTypeNative.FUNCTION_INSTANCE_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("SOURCELESS", jSTypeNative0);
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
      typeInference0.branchedFlowThrough(node0, flowScope0);
      FlowScope flowScope1 = typeInference0.createInitialEstimateLattice();
      assertSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test168()  throws Throwable  {
      Logger logger0 = Tracer.logger;
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      JSTypeNative jSTypeNative0 = JSTypeNative.FUNCTION_INSTANCE_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("SOURCELESS", jSTypeNative0);
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      codingConvention_AssertionFunctionSpec0.getAssertedType(node0, jSTypeRegistry0);
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      System.setCurrentTimeMillis(2597L);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      CodingConventions.Proxy codingConventions_Proxy0 = new CodingConventions.Proxy(googleCodingConvention0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(codingConventions_Proxy0, jSTypeRegistry0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = closureReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node0, flowScope0, true);
      FlowScope flowScope2 = typeInference0.flowThrough(node0, flowScope1);
      FlowScope flowScope3 = typeInference0.createEntryLattice();
      assertNotSame(flowScope3, flowScope2);
  }

  @Test(timeout = 4000)
  public void test169()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      byte[] byteArray0 = new byte[9];
      byteArray0[0] = (byte)124;
      byteArray0[1] = (byte)68;
      byteArray0[2] = (byte)33;
      byteArray0[3] = (byte) (-81);
      byteArray0[4] = (byte)113;
      byteArray0[5] = (byte)1;
      byteArray0[6] = (byte)121;
      byteArray0[7] = (byte)113;
      byteArray0[8] = (byte)56;
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.UNCOND;
      controlFlowGraph0.connect(node0, controlFlowGraph_Branch0, node0);
      JSTypeNative jSTypeNative0 = JSTypeNative.ALL_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("SOURCELESS", jSTypeNative0);
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("SOURCELESS", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void test170()  throws Throwable  {
      Logger logger0 = Logger.getLogger("|KD@4:)0JL");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      JSTypeNative jSTypeNative0 = JSTypeNative.FUNCTION_INSTANCE_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("N5=p", jSTypeNative0);
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      System.setCurrentTimeMillis(38);
      FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test171()  throws Throwable  {
      Logger logger0 = Logger.getLogger("|KD@A4:)0JHL");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("SOURCELESS");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      JSTypeNative jSTypeNative0 = JSTypeNative.FUNCTION_INSTANCE_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("N5=p", jSTypeNative0);
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test172()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.TRUE;
      TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, true);
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("throw");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      Scope scope0 = Scope.createGlobalScope(node0);
      JSTypeNative jSTypeNative0 = JSTypeNative.BOOLEAN_OBJECT_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("c_GjJQ:H;-", jSTypeNative0);
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("throw", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = null;
      try {
        typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test173()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.TRUE;
      TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, true);
      Logger logger0 = Tracer.logger;
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode("throw");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      compiler0.getTopScope();
      JSTypeNative jSTypeNative0 = JSTypeNative.BOOLEAN_OBJECT_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("c_GjJQ:H;-", jSTypeNative0);
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("throw", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = null;
      try {
        typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, (Scope) null, immutableBiMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test174()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;
      boolean boolean0 = true;
      TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, true);
      BooleanLiteralSet booleanLiteralSet1 = BooleanLiteralSet.TRUE;
      TypeInference.getBooleanOutcomes(booleanLiteralSet1, booleanLiteralSet0, true);
      Compiler compiler0 = new Compiler();
      boolean boolean1 = false;
      FindExportableNodes findExportableNodes0 = new FindExportableNodes(compiler0, false);
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      MemoizedScopeCreator memoizedScopeCreator0 = new MemoizedScopeCreator(syntacticScopeCreator0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, findExportableNodes0, memoizedScopeCreator0);
      // Undeclared exception!
      try { 
        nodeTraversal0.getControlFlowGraph();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.NodeTraversal", e);
      }
  }

  @Test(timeout = 4000)
  public void test175()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
      Compiler compiler0 = new Compiler();
      VerboseMessageFormatter verboseMessageFormatter0 = new VerboseMessageFormatter(compiler0);
      // Undeclared exception!
      try { 
        Logger.getAnonymousLogger("KCBG^6>D(,uSYw");
        fail("Expecting exception: MissingResourceException");
      
      } catch(MissingResourceException e) {
         //
         // Can't find KCBG^6>D(,uSYw bundle
         //
         verifyException("java.util.logging.Logger", e);
      }
  }
}
