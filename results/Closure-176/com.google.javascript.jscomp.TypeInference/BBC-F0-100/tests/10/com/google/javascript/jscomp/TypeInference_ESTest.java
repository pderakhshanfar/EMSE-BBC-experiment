/*
 * This file was automatically generated by EvoSuite
 * Mon Mar 01 22:53:53 GMT 2021
 */

package com.google.javascript.jscomp;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSortedMap;
import com.google.javascript.jscomp.CleanupPasses;
import com.google.javascript.jscomp.CodingConvention;
import com.google.javascript.jscomp.CodingConventions;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerInput;
import com.google.javascript.jscomp.CompilerOptions;
import com.google.javascript.jscomp.ControlFlowAnalysis;
import com.google.javascript.jscomp.ControlFlowGraph;
import com.google.javascript.jscomp.GoogleCodingConvention;
import com.google.javascript.jscomp.JqueryCodingConvention;
import com.google.javascript.jscomp.LinkedFlowScope;
import com.google.javascript.jscomp.Normalize;
import com.google.javascript.jscomp.PeepholeFoldConstants;
import com.google.javascript.jscomp.PeepholeFoldWithTypes;
import com.google.javascript.jscomp.PeepholeRemoveDeadCode;
import com.google.javascript.jscomp.PrintStreamErrorManager;
import com.google.javascript.jscomp.ReferenceCollectingCallback;
import com.google.javascript.jscomp.Scope;
import com.google.javascript.jscomp.StatementFusion;
import com.google.javascript.jscomp.TightenTypes;
import com.google.javascript.jscomp.TypeInference;
import com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.FlowScope;
import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.SimpleErrorReporter;
import com.google.javascript.rhino.jstype.BooleanLiteralSet;
import com.google.javascript.rhino.jstype.BooleanType;
import com.google.javascript.rhino.jstype.EnumType;
import com.google.javascript.rhino.jstype.FunctionType;
import com.google.javascript.rhino.jstype.JSType;
import com.google.javascript.rhino.jstype.JSTypeNative;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import com.google.javascript.rhino.jstype.NamedType;
import com.google.javascript.rhino.jstype.NoType;
import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Stack;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.Vector;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.System;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.mock.java.io.MockFile;
import org.evosuite.runtime.mock.java.io.MockPrintStream;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class TypeInference_ESTest extends TypeInference_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test000()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(12, node0, node0, node0, 0, 37);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      Scope scope0 = Scope.createGlobalScope(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      ImmutableSortedMap.of();
      controlFlowGraph0.pushEdgeAnnotations();
      node0.setType(147);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(86, 1231, 30);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Node node3 = new Node(15, 57, 123);
      HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test001()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("<)5sI;\"Jlf!_/C");
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      node0.addChildrenToBack(node0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      GoogleCodingConvention googleCodingConvention1 = new GoogleCodingConvention();
      scope0.getTypeOfThis();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node1 = new Node(117, 1088, 117);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope.createEntryLattice(scope0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(65, 8, 2);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      FlowScope flowScope0 = typeInference1.flowThrough(node2, linkedFlowScope0);
      typeInference1.branchedFlowThrough(node0, flowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
      assertNotSame(linkedFlowScope0, flowScope0);
  }

  @Test(timeout = 4000)
  public void test002()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode(";u2R1B");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(44, node0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      Node node2 = new Node(3, 56, 1419);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      FlowScope flowScope0 = typeInference1.createEntryLattice();
      FlowScope flowScope1 = typeInference1.flowThrough(node1, flowScope0);
      typeInference1.createEntryLattice();
      typeInference0.branchedFlowThrough(node0, flowScope0);
      ControlFlowGraph<Node> controlFlowGraph1 = typeInference0.getCfg();
      TypeInference typeInference2 = new TypeInference(compiler0, controlFlowGraph1, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 3
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test003()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(49, node0, node0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      Scope scope0 = Scope.createLatticeBottom(node1);
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "JSC_FUNCTION_LITERAL_UNDEFINED_THIS");
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Node node2 = new Node(149, 77, (-1880));
      node0.addChildrenToBack(node2);
      node2.setOptionalArg(true);
      Scope scope1 = Scope.createLatticeBottom(node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention1 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention1, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      immutableSortedMap0.tailMap("Object#Key", false);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter1 = closureReverseAbstractInterpreter0.append(chainableReverseAbstractInterpreter0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter1, scope0, treeMap0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope1, immutableSortedMap0);
      FlowScope flowScope0 = typeInference1.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node2, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // CONST [opt_arg: com.google.javascript.rhino.Node$IntPropListItem@0000000631] does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test004()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      node0.addChildrenToBack(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = null;
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      compiler0.getTypeRegistry();
      Node node1 = new Node(64, 1, 107);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      linkedFlowScope_FlowScopeJoinOp0.apply((FlowScope) linkedFlowScope0, (FlowScope) linkedFlowScope1);
      // Undeclared exception!
      try { 
        typeInference1.flowThrough(node1, linkedFlowScope1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test005()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("h)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(49, node0, node0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, treeMap0);
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter1 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      closureReverseAbstractInterpreter0.getFirst();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeMap0);
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      Node node2 = new Node(124, 112, 0);
      typeInference0.branchedFlowThrough(node0, flowScope0);
      System.setCurrentTimeMillis(0L);
      FlowScope flowScope1 = typeInference1.createEntryLattice();
      LinkedFlowScope linkedFlowScope1 = LinkedFlowScope.createEntryLattice(scope0);
      typeInference1.flowThrough(node1, flowScope1);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // EMPTY 112 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test006()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      node0.getDirectives();
      Node node1 = new Node(110, 15, 149);
      node0.addChildrenToBack(node1);
      node1.setOptionalArg(false);
      Scope scope0 = Scope.createLatticeBottom(node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap1 = immutableSortedMap0.tailMap("Object#Element", false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap1);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test007()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(49, node0, node0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, treeMap0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeMap0);
      node0.getDirectives();
      compiler0.getTypeRegistry();
      FlowScope flowScope0 = typeInference1.createEntryLattice();
      Node node2 = new Node(57, 57, 1447);
      Node node3 = new Node(100, 2, 40);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node3, flowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test008()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("<)5sI;\"JlN!_/C");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"JlN!_/C");
      ControlFlowAnalysis.computeFollowNode(node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node.newString("<)5sI;\"JlN!_/C");
      node0.addChildrenToBack(node0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope2 = LinkedFlowScope.createEntryLattice(scope0);
      linkedFlowScope0.createChildFlowScope();
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      typeInference0.createEntryLattice();
      Node node1 = new Node(33, 2185, 149);
      typeInference0.branchedFlowThrough(node0, flowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test009()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(49, node0, node0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createGlobalScope(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      GoogleCodingConvention googleCodingConvention1 = new GoogleCodingConvention();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node2 = new Node(119, 37, 0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // WITH 37 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test010()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(12, node0, node0, node0, 0, 37);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      Scope scope0 = Scope.createGlobalScope(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ImmutableSortedMap.of();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node2 = new Node(52, 1, (-3226));
      node0.setType(147);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter1 = closureReverseAbstractInterpreter0.append(chainableReverseAbstractInterpreter0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter1, scope0, immutableSortedMap0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // EQ 0 : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test011()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "UN+@]'*S$~Z8@J");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      Node node1 = new Node(96, 50, (-17));
      node0.addChildrenToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      compiler0.getTypeRegistry();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(8, node0, node0, node0, 56, 39);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 8
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test012()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      node0.addChildrenToBack(node0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(17, 55, 8);
      typeInference0.createInitialEstimateLattice();
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      typeInference0.getCfg();
      LinkedList<FlowScope> linkedList0 = new LinkedList<FlowScope>();
      FlowScope flowScope0 = typeInference1.createEntryLattice();
      typeInference1.flowThrough(node1, linkedFlowScope0);
      typeInference1.branchedFlowThrough(node0, flowScope0);
      FlowScope flowScope1 = typeInference0.flowThrough(node0, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test013()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(49, node0, node0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, treeMap0);
      node0.toString(false, false, false);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(43, 54, 40);
      compiler0.setTypeRegistry(jSTypeRegistry0);
      typeInference0.flowThrough(node2, linkedFlowScope0);
      typeInference0.createEntryLattice();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      typeInference0.flowThrough(node2, flowScope0);
      typeInference0.createEntryLattice();
      Node node3 = new Node(106, 37, 36);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node3, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 106
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test014()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(56, node0, node0);
      Node node2 = new Node(137, 52, 29);
      node0.addChildrenToBack(node2);
      StatementFusion statementFusion0 = new StatementFusion(false);
      Node node3 = new Node(40, node1);
      Node node4 = statementFusion0.tryFuseStatementsAggressively(node3);
      controlFlowGraph0.hasNode(node4);
      node1.setOptionalArg(false);
      Scope scope0 = Scope.createLatticeBottom(node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap1 = ImmutableSortedMap.copyOf((Map<? extends String, ? extends CodingConvention.AssertionFunctionSpec>) immutableSortedMap0);
      compiler0.getTypeRegistry();
      compiler0.getTypeRegistry();
      Node node5 = new Node(1, (-42), 4095);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap1);
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      linkedFlowScope_FlowScopeJoinOp0.apply((FlowScope) linkedFlowScope0, (FlowScope) linkedFlowScope0);
      typeInference0.flowThrough(node5, linkedFlowScope0);
      Node node6 = new Node(117, 101, 31);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test015()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "UN+@]'*S$~Z8@J");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      Node node1 = new Node(96, 50, (-17));
      node0.addChildrenToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      compiler0.getTypeRegistry();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(8, node0, node0, node0, 56, 39);
      typeInference0.flowThrough(node2, linkedFlowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // ASSIGN_DIV : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test016()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      node0.addChildrenToBack(node0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      Node node1 = new Node(48, 1, 125);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      Node node2 = new Node(120, 3554, 1);
      LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = linkedFlowScope0.createChildFlowScope();
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      typeInference1.createEntryLattice();
      Node node3 = new Node(111, (-2544), 137);
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node3, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // CASE does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test017()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream("<)5sI;\"Jlf!_/C");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      Node node1 = new Node(140, node0, node0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = null;
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      typeInference0.flowThrough(node1, linkedFlowScope0);
      compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      typeInference0.createEntryLattice();
      Node node2 = new Node(29, 1753, 4);
      typeInference0.createInitialEstimateLattice();
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      typeInference0.getCfg();
      LinkedList<FlowScope> linkedList0 = new LinkedList<FlowScope>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 140
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test018()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      Node node1 = peepholeFoldWithTypes0.optimizeSubtree(node0);
      node0.addChildrenToBack(node0);
      node1.setOptionalArg(true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      compiler0.getTypeRegistry();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      Node node2 = new Node(152, 0, 30);
      Node node3 = new Node(47, 145, (-634));
      typeInference0.branchedFlowThrough(node1, flowScope0);
      LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // DEBUGGER 0 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test019()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      ControlFlowAnalysis.computeFallThrough(node0);
      node0.addChildrenToBack(node0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(2, 38, (-1773));
      Node node2 = new Node(11, 47, 15);
      FlowScope flowScope0 = typeInference1.createInitialEstimateLattice();
      TypeInference typeInference2 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      typeInference2.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // BITAND 47 : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test020()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(49, node0, node0);
      node1.addChildrenToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node1);
      compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      byte[] byteArray0 = new byte[9];
      byteArray0[6] = (byte) (-36);
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      ArrayList<FlowScope> arrayList0 = new ArrayList<FlowScope>();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      linkedFlowScope0.completeScope(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      Node node2 = new Node(134, 32, 50);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope2);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 134
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test021()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(49, node0, node0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, treeMap0);
      node0.toString(false, false, false);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(135, 16, 52);
      Compiler compiler1 = new Compiler();
      compiler1.setTypeRegistry(jSTypeRegistry0);
      typeInference0.flowThrough(node2, linkedFlowScope0);
      typeInference0.createEntryLattice();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      typeInference0.flowThrough(node0, linkedFlowScope0);
      typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // THROW does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test022()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      node0.addChildrenToBack(node0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      compiler0.getTypeRegistry();
      Node node1 = new Node(66, 1, 107);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      FlowScope flowScope0 = linkedFlowScope_FlowScopeJoinOp0.apply((FlowScope) linkedFlowScope0, (FlowScope) linkedFlowScope1);
      typeInference1.flowThrough(node1, linkedFlowScope1);
      Node node2 = new Node(1, 2, 53);
      typeInference0.branchedFlowThrough(node0, flowScope0);
      FlowScope flowScope1 = typeInference1.flowThrough(node2, linkedFlowScope0);
      assertNotSame(linkedFlowScope0, flowScope1);
  }

  @Test(timeout = 4000)
  public void test023()  throws Throwable  {
      MockFile mockFile0 = new MockFile("_)5sIl\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "_)5sIl\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      Node node1 = peepholeFoldWithTypes0.optimizeSubtree(node0);
      node0.addChildrenToBack(node0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      compiler0.getTypeRegistry();
      Node node2 = new Node(55, 51, 57);
      node0.getDirectives();
      LinkedFlowScope linkedFlowScope0 = (LinkedFlowScope)typeInference0.createEntryLattice();
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = (LinkedFlowScope)typeInference0.flowThrough(node1, linkedFlowScope0);
      ArrayList<FlowScope> arrayList0 = new ArrayList<FlowScope>();
      LinkedFlowScope linkedFlowScope3 = new LinkedFlowScope(linkedFlowScope2);
      Node node3 = new Node(29, 132, 53);
      Node node4 = Node.newString(73, "parseInt", (-94), 132);
      typeInference0.flowThrough(node4, linkedFlowScope3);
      typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertNotSame(linkedFlowScope0, linkedFlowScope2);
  }

  @Test(timeout = 4000)
  public void test024()  throws Throwable  {
      Locale locale0 = Locale.TRADITIONAL_CHINESE;
      Compiler compiler0 = new Compiler();
      compiler0.getSourceLine("", (-62));
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      node0.getDirectives();
      Node node1 = new Node(114, 50, (-13));
      Node node2 = node1.copyInformationFrom(node0);
      node0.addChildrenToBack(node1);
      node0.setOptionalArg(true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node3 = new Node(115, 43, 167);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node2, linkedFlowScope0, true);
      Node node4 = new Node(39, 25, 904);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter1 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter1.getFirst();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node3, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // FOR 43 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test025()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(49, node0, node0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, treeMap0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeMap0);
      Node node2 = new Node(12, 135, 57);
      node2.getDirectives();
      FlowScope flowScope0 = typeInference1.createEntryLattice();
      LinkedFlowScope.createEntryLattice(scope0);
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      Node node3 = new Node((-1714), 57, 42);
      LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      flowScope0.createChildFlowScope();
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      TypeInference typeInference2 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, treeMap0);
      typeInference2.createEntryLattice();
      Node node4 = new Node(84, 40, 2396);
      // Undeclared exception!
      try { 
        typeInference2.branchedFlowThrough(node4, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 84
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test026()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(12, node0, node0, node0, 0, 37);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      Scope scope0 = Scope.createGlobalScope(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node2 = new Node(26, 52, 12);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      TypeInference typeInference2 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      FlowScope flowScope0 = typeInference1.createEntryLattice();
      Node node3 = new Node(62, 31, 2);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node3, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 62
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test027()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(49, node0, node0);
      node1.addChildrenToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node1);
      compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      byte[] byteArray0 = new byte[9];
      byteArray0[5] = (byte) (-36);
      byteArray0[4] = (byte)0;
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node2 = new Node(129, (-624), 31);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 129
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test028()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      node0.addChildrenToBack(node0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      typeInference0.createEntryLattice();
      compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      immutableSortedMap0.descendingMap();
      JSTypeNative jSTypeNative0 = JSTypeNative.VOID_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.javascript.jscomp.DefaultPassConfig$89", jSTypeNative0);
      ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("Object#Element", codingConvention_AssertionFunctionSpec0, "r7|nR[yK4<{hJ", codingConvention_AssertionFunctionSpec0, "com.google.javascript.jscomp.Normalize$DuplicateDeclarationHandler", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableMap0);
      Node node1 = new Node(9, 113, 15);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // BITOR 113 : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test029()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("<)5sI;\"Jlf!_/C");
      Compiler compiler0 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      node0.addChildrenToBack(node0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      JSTypeRegistry jSTypeRegistry1 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention1 = new GoogleCodingConvention();
      scope0.getTypeOfThis();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry1);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node1 = new Node(117, 1088, 117);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(153, 751619262, 4095);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node2, linkedFlowScope0, false);
      Node node3 = new Node(59, 8, 2);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node3, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 59
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test030()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(112, 50, 1);
      node0.addChildrenToBack(node1);
      Scope scope0 = Scope.createGlobalScope(node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = linkedFlowScope_FlowScopeJoinOp0.apply((FlowScope) linkedFlowScope0, (FlowScope) linkedFlowScope0);
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
      typeInference0.createEntryLattice();
      Node node2 = new Node(155, 2, 37);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // CAST 2 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test031()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(102, 50, 1);
      node0.addChildrenToBack(node1);
      Scope scope0 = Scope.createGlobalScope(node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = linkedFlowScope_FlowScopeJoinOp0.apply((FlowScope) linkedFlowScope0, (FlowScope) linkedFlowScope0);
      typeInference0.flowThrough(node1, flowScope0);
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
      typeInference0.createEntryLattice();
      Node node2 = new Node(155, 2, 37);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // CAST 2 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test032()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(49, node0, node0);
      node1.addChildrenToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node1);
      compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      byte[] byteArray0 = new byte[9];
      byteArray0[5] = (byte) (-36);
      byteArray0[4] = (byte)0;
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      ArrayList<FlowScope> arrayList0 = new ArrayList<FlowScope>();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      Node node2 = new Node(133, (-406), 50);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope2);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 133
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test033()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream("<)5sI;\"Jlf!_/C");
      Locale locale0 = Locale.TRADITIONAL_CHINESE;
      Compiler compiler0 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "6 Mk-3");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      node0.getDirectives();
      Node node1 = new Node(4, 50, (-31));
      node1.copyInformationFrom(node0);
      node0.addChildrenToBack(node1);
      node1.setOptionalArg(true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      GoogleCodingConvention googleCodingConvention1 = new GoogleCodingConvention();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(122, node0, node0, node0, 486, 39);
      typeInference0.flowThrough(node2, linkedFlowScope0);
      List<FlowScope> list0 = new Stack<FlowScope>();
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test034()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(112, 50, 1);
      node0.addChildrenToBack(node1);
      Scope scope0 = Scope.createGlobalScope(node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = linkedFlowScope_FlowScopeJoinOp0.apply((FlowScope) linkedFlowScope0, (FlowScope) linkedFlowScope0);
      typeInference0.flowThrough(node1, flowScope0);
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
      typeInference0.createEntryLattice();
      Node node2 = new Node(155, 2, 37);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // CAST 2 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test035()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<5sIk\"Jf!_DC", "<5sIk\"Jf!_DC");
      MockPrintStream mockPrintStream0 = new MockPrintStream("<5sIk\"Jf!_DC");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<5sIk\"Jf!_DC");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      node0.addChildrenToBack(node0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      compiler0.getTypeRegistry();
      Node node1 = new Node((-923), 57, 148);
      node0.getDirectives();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      typeInference0.createEntryLattice();
      treeMap0.values();
      Node node2 = new Node(119, 2, 149);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // WITH 2 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test036()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(49, node0, node0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, treeMap0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeMap0);
      Node node2 = new Node(12, 135, 57);
      node2.getDirectives();
      FlowScope flowScope0 = typeInference1.createEntryLattice();
      LinkedFlowScope.createEntryLattice(scope0);
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      Node node3 = new Node((-1714), 57, 42);
      LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      flowScope0.createChildFlowScope();
      Vector<FlowScope> vector0 = new Vector<FlowScope>();
      TypeInference typeInference2 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, treeMap0);
      typeInference2.createEntryLattice();
      Node node4 = new Node(128, 40, 2396);
      // Undeclared exception!
      try { 
        typeInference2.branchedFlowThrough(node4, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 128
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test037()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/)C");
      MockPrintStream mockPrintStream0 = new MockPrintStream("<)5sI;\"Jlf!_/)C");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/)C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      node0.getDirectives();
      Node node1 = new Node(42, 42, 52);
      node0.addChildrenToBack(node1);
      node0.setOptionalArg(false);
      Scope scope0 = Scope.createLatticeBottom(node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      GoogleCodingConvention googleCodingConvention1 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      GoogleCodingConvention googleCodingConvention2 = new GoogleCodingConvention();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      Node node2 = new Node(33, node0, node0, node0, 47, 56);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node2, linkedFlowScope0);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // SCRIPT [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000000618] [input_id: com.google.javascript.rhino.Node$ObjectPropListItem@0000000619] is not a string node
         //
         verifyException("com.google.javascript.rhino.Node", e);
      }
  }

  @Test(timeout = 4000)
  public void test038()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Node node1 = new Node(49, node0, node0);
      Node node2 = new Node(16, 4095, 126);
      node2.addChildrenToBack(node1);
      node0.setOptionalArg(true);
      Scope scope0 = Scope.createLatticeBottom(node2);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, false);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      ImmutableSortedMap.copyOf((Map<? extends String, ? extends CodingConvention.AssertionFunctionSpec>) immutableSortedMap0);
      compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention1 = new GoogleCodingConvention();
      compiler0.getTypeRegistry();
      Node node3 = new Node((-594), 2385, 43);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = linkedFlowScope_FlowScopeJoinOp0.apply((FlowScope) linkedFlowScope0, (FlowScope) linkedFlowScope0);
      FlowScope flowScope1 = typeInference0.flowThrough(node2, flowScope0);
      Node node4 = new Node(35, 48, 4261);
      typeInference0.branchedFlowThrough(node0, flowScope1);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node4, flowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test039()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream("<)5sI;\"Jlf!_/C");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(4, node0, node0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      closureReverseAbstractInterpreter0.getFirst();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      node1.toString(true, false, false);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(116, 122, 50);
      compiler0.setTypeRegistry(jSTypeRegistry0);
      PeepholeRemoveDeadCode peepholeRemoveDeadCode0 = new PeepholeRemoveDeadCode();
      Node node3 = peepholeRemoveDeadCode0.tryOptimizeBlock(node1);
      typeInference0.flowThrough(node3, linkedFlowScope0);
      typeInference0.createEntryLattice();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeMap0);
      FlowScope flowScope0 = typeInference1.createEntryLattice();
      typeInference0.flowThrough(node2, flowScope0);
      typeInference1.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node3, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // RETURN does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test040()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      Node node1 = peepholeFoldWithTypes0.optimizeSubtree(node0);
      node0.addChildrenToBack(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = null;
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      node1.setChangeTime(47);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      Node node2 = new Node((-50), 74, 54);
      Node node3 = new Node(109, 16, 1525);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node3, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 109
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test041()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Locale locale0 = Locale.TRADITIONAL_CHINESE;
      Compiler compiler0 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "6 Mk-3");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      node0.getDirectives();
      Node node1 = new Node(127, 144, 4095);
      node1.addChildrenToBack(node0);
      node1.setOptionalArg(true);
      Scope scope0 = Scope.createLatticeBottom(node1);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      Node node2 = new Node((-2269), 0, 400000);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 127
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test042()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("<)5sI;\"Jlf!_/C");
      Node node1 = Node.newString(53, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      node0.getDirectives();
      Node node2 = Node.newString("<)5sI;\"Jlf!_/C");
      node0.addChildrenToBack(node2);
      Scope scope0 = Scope.createLatticeBottom(node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      JSTypeRegistry jSTypeRegistry1 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention1 = new GoogleCodingConvention();
      scope0.getTypeOfThis();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry1);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node3 = new Node(30, 37, 10);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node4 = new Node(51, 51, 2293);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention1, jSTypeRegistry0);
      semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node2, linkedFlowScope0, true);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node3, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test043()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/)C");
      MockPrintStream mockPrintStream0 = new MockPrintStream("<)5sI;\"Jlf!_/)C");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/)C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      node0.getDirectives();
      Node node1 = new Node(42, 42, 52);
      node0.addChildrenToBack(node1);
      node0.setOptionalArg(false);
      Scope scope0 = Scope.createLatticeBottom(node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      ImmutableSortedMap.of();
      Node node2 = new Node(42, 54, 12);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      node0.setType(30);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      typeInference0.analyze(111);
      TypeInference typeInference2 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      typeInference2.branchedFlowThrough(node0, linkedFlowScope0);
      FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;
      BooleanLiteralSet booleanLiteralSet1 = BooleanLiteralSet.TRUE;
      BooleanLiteralSet booleanLiteralSet2 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet1, false);
      assertEquals(BooleanLiteralSet.TRUE, booleanLiteralSet2);
      
      FlowScope flowScope1 = typeInference0.flowThrough(node0, flowScope0);
      assertSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test044()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<5sIk\"Jf!_DC", "<5sIk\"Jf!_DC");
      MockPrintStream mockPrintStream0 = new MockPrintStream("<5sIk\"Jf!_DC");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<5sIk\"Jf!_DC");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      node0.addChildrenToBack(node0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      compiler0.getTypeRegistry();
      Node node1 = new Node((-923), 57, 148);
      node0.getDirectives();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      typeInference0.createEntryLattice();
      Node node2 = new Node(122, 2, 149);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // VOID 2 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test045()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream("<)5sI;\"Jlf!_/C");
      Compiler compiler0 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      node0.getDirectives();
      Node node1 = Node.newString("<)5sI;\"Jlf!_/C");
      node0.addChildrenToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      JSTypeRegistry jSTypeRegistry1 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention1 = new GoogleCodingConvention();
      scope0.getTypeOfThis();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry1);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node2 = new Node(117, 1088, 117);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node3 = new Node(153, 751619276, 120);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      FlowScope flowScope0 = semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node3, linkedFlowScope0, false);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node3, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LABEL_NAME 838860 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test046()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "");
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, false);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      Node node1 = new Node(114, 50, 1);
      node0.addChildrenToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      GoogleCodingConvention googleCodingConvention1 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention1, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node2 = new Node(139, 48, 2641);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope.createEntryLattice(scope0);
      Node node3 = linkedFlowScope0.getRootNode();
      node2.setSourceEncodedPositionForTree(0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      FlowScope flowScope0 = typeInference0.flowThrough(node3, linkedFlowScope0);
      LinkedFlowScope.createEntryLattice(scope0);
      PeepholeRemoveDeadCode peepholeRemoveDeadCode0 = new PeepholeRemoveDeadCode();
      Node node4 = peepholeRemoveDeadCode0.tryOptimizeBlock(node2);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node4, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 139
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test047()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      peepholeFoldWithTypes0.optimizeSubtree(node0);
      node0.addChildrenToBack(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = null;
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      typeInference1.createEntryLattice();
      Node node1 = new Node(2, 38, (-1764));
      Node node2 = new Node(20, 47, 15);
      FlowScope flowScope0 = typeInference1.createInitialEstimateLattice();
      TypeInference typeInference2 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      typeInference2.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // URSH 47 : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test048()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      node0.addChildrenToBack(node0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      compiler0.getTypeRegistry();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      compiler0.getTypeRegistry();
      Node node1 = new Node(146, 38, 57);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      typeInference0.flowThrough(node0, flowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 146
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test049()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      node0.addChildrenToBack(node0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = null;
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      typeInference0.createEntryLattice();
      Node node1 = new Node(38, 40, 103);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      Node node2 = new Node(112, 2135, 119);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // NAME 40 is not a string node
         //
         verifyException("com.google.javascript.rhino.Node", e);
      }
  }

  @Test(timeout = 4000)
  public void test050()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(49, node0, node0);
      Node node2 = new Node(16, 4095, 126);
      node2.addChildrenToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node2);
      compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      byte[] byteArray0 = new byte[9];
      byteArray0[1] = (byte)22;
      byteArray0[2] = (byte) (-36);
      byteArray0[4] = (byte) (-36);
      compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention1 = new GoogleCodingConvention();
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node3 = new Node(123, 53, 133);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node3, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 123
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test051()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      peepholeFoldWithTypes0.optimizeSubtree(node0);
      node0.addChildrenToBack(node0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      TypeInference typeInference2 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      FlowScope flowScope0 = typeInference2.createEntryLattice();
      Node node1 = new Node(148, 1616, 40);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope1 = typeInference1.flowThrough(node1, flowScope0);
      typeInference0.flowThrough(node0, flowScope1);
      typeInference1.branchedFlowThrough(node0, linkedFlowScope0);
      typeInference0.createEntryLattice();
      typeInference2.createInitialEstimateLattice();
      typeInference0.createInitialEstimateLattice();
      typeInference2.createInitialEstimateLattice();
  }

  @Test(timeout = 4000)
  public void test052()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<5sIk\"Jf!_DC", "<5sIk\"Jf!_DC");
      MockPrintStream mockPrintStream0 = new MockPrintStream("<5sIk\"Jf!_DC");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<5sIk\"Jf!_DC");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Node node1 = Node.newString("<5sIk\"Jf!_DC");
      node1.addChildrenToBack(node0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      node0.isQualifiedName();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      compiler0.getTypeRegistry();
      Node node2 = new Node(150, 2889, 29);
      node0.getDirectives();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node2, flowScope0);
      typeInference0.createEntryLattice();
      Node node3 = new Node(32, 29, 4);
      Node node4 = new Node(149, node1, 15, 1);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node4, flowScope1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // CONST 15 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test053()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("<)5sI;\"JlN!_/C");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"JlN!_/C");
      ControlFlowAnalysis.computeFollowNode(node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      node0.addChildrenToBack(node0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      compiler0.getTypeRegistry();
      Node node1 = new Node(131, 131, 50);
      node1.getDirectives();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      typeInference0.createEntryLattice();
      Node node2 = new Node(153, 15, 51);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, flowScope1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SCRIPT [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000000618] [input_id: com.google.javascript.rhino.Node$ObjectPropListItem@0000000619] does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test054()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(49, node0, node0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      closureReverseAbstractInterpreter0.getFirst();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeMap1);
      compiler0.getTypeRegistry();
      Node node2 = new Node(12, 135, 57);
      node2.getDirectives();
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry1 = tightenTypes0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry1);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      Node node3 = new Node(12, 120, 56);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node3, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // EQ 120 : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test055()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(49, node0, node0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, treeMap0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeMap1);
      compiler0.getTypeRegistry();
      Node node2 = new Node(12, 135, 57);
      node2.getDirectives();
      typeInference0.createEntryLattice();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry1 = tightenTypes0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry1);
      FlowScope flowScope1 = semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node1, flowScope0, false);
      FlowScope flowScope2 = typeInference0.flowThrough(node2, flowScope1);
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node1, flowScope2);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // THROW does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test056()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      node0.addChildrenToBack(node0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = (LinkedFlowScope)typeInference0.createEntryLattice();
      Node node1 = new Node(38, 40, 103);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      Node node2 = new Node(136, (-81), 137);
      LinkedFlowScope linkedFlowScope1 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope3 = (LinkedFlowScope)linkedFlowScope1.createChildFlowScope();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope3);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 136
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test057()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      node0.addChildrenToBack(node0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = (LinkedFlowScope)typeInference0.createEntryLattice();
      Node node1 = new Node(38, 40, 103);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      Node node2 = new Node(141, (-95), 137);
      LinkedFlowScope linkedFlowScope1 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope3 = (LinkedFlowScope)linkedFlowScope1.createChildFlowScope();
      scope0.resolveTypes();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope3);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 141
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test058()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      peepholeFoldWithTypes0.optimizeSubtree(node0);
      node0.addChildrenToBack(node0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap1 = immutableSortedMap0.descendingMap();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap1);
      Node node1 = new Node(121, (-1), 48);
      LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 121
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test059()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("<)5sI;\"JlN!_/C");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"JlN!_/C");
      ControlFlowAnalysis.computeFollowNode(node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node.newString("eb8JV!(Mgs&0HYo");
      node0.addChildrenToBack(node0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      Node node1 = new Node(40, 32, 55);
      Node node2 = new Node(107, 145, 36);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 107
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test060()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/)C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/)C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      Node node1 = peepholeFoldWithTypes0.optimizeSubtree(node0);
      node1.addChildrenToBack(node0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      compiler0.getTypeRegistry();
      Node node2 = new Node(4, 42, 149);
      node1.getDirectives();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node0, flowScope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // RETURN 42 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test061()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(49, node0, node0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node2 = new Node(26, 52, 12);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      Node node3 = new Node(51, 252, 144);
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node3, linkedFlowScope1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // IN 252 : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test062()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("<)5sI;\"JlN!_/C");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"JlN!_/C");
      Node node1 = new Node(46, node0, node0, node0, node0);
      ControlFlowAnalysis.computeFollowNode(node1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node.newString("%eub8JV!(Mgs0HYo");
      node0.addChildrenToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      Node node2 = new Node(40, 32, 55);
      Node node3 = new Node(107, 145, 36);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeMap0);
      FlowScope flowScope1 = typeInference1.flowThrough(node2, flowScope0);
      Node node4 = new Node(342, 120, 1);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node3, flowScope1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 107
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test063()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream("<)5sI;\"Jlf!_/C");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(4, node0, node0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(47, 52, 15);
      LinkedFlowScope linkedFlowScope1 = (LinkedFlowScope)typeInference0.flowThrough(node1, linkedFlowScope0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention1 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention1, jSTypeRegistry0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeMap0);
      LinkedFlowScope.createEntryLattice(scope0);
      Node node3 = new Node(48, (-412), 50);
      typeInference1.flowThrough(node2, linkedFlowScope1);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      linkedFlowScope2.createChildFlowScope();
      ArrayList<FlowScope> arrayList0 = new ArrayList<FlowScope>();
      assertTrue(arrayList0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test064()  throws Throwable  {
      MockFile mockFile0 = new MockFile("_)5sIl\"Jlf!_/C", "_)5sIl\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "_)5sIl\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      Node node1 = peepholeFoldWithTypes0.optimizeSubtree(node0);
      Node node2 = new Node(54, node1);
      Scope scope0 = Scope.createLatticeBottom(node2);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      compiler0.getTypeRegistry();
      Node node3 = new Node(46, 471, 49);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.createEntryLattice();
      ControlFlowGraph<Node> controlFlowGraph1 = typeInference0.getCfg();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph1, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      typeInference1.flowThrough(node2, flowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node3, flowScope1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SHNE 471 : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test065()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream("<)5sI;\"Jlf!_/C");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(4, node0, node0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(47, 52, 15);
      typeInference0.flowThrough(node1, linkedFlowScope0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention1 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention1, jSTypeRegistry0);
      Node node3 = new Node(30, 134, 4095);
      FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
      node1.isOnlyModifiesArgumentsCall();
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      linkedFlowScope_FlowScopeJoinOp0.apply(flowScope0, (FlowScope) linkedFlowScope0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node3, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test066()  throws Throwable  {
      Locale locale0 = Locale.TRADITIONAL_CHINESE;
      Compiler compiler0 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      node0.getDirectives();
      Node node1 = new Node(101, 50, (-18));
      node1.copyInformationFrom(node0);
      node0.addChildrenToBack(node1);
      node1.setOptionalArg(true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap1 = ImmutableSortedMap.copyOf((Map<? extends String, ? extends CodingConvention.AssertionFunctionSpec>) immutableSortedMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap1);
      compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention1 = new GoogleCodingConvention();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      Node node2 = new Node(126, (-1655), (-44));
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap1);
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node2, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LABEL does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test067()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream("<)5sI;\"Jlf!_/C");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      node0.getDirectives();
      Node node1 = new Node(42, 42, 3);
      node0.addChildrenToBack(node1);
      node0.setOptionalArg(false);
      Scope scope0 = Scope.createLatticeBottom(node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      Node node2 = new Node(43, 47, 146);
      Node node3 = new Node(88);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node3, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // ASSIGN_BITXOR : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test068()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("<)5sI;\"JlN!_/C");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"JlN!_/C");
      ControlFlowAnalysis.computeFollowNode(node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Node node1 = Node.newString("<)5sI;\"JlN!_/C");
      node1.addChildrenToBack(node0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      Node node2 = new Node(36, 1, 15);
      Node node3 = new Node(145, 55, 432);
      FlowScope flowScope1 = typeInference0.flowThrough(node3, flowScope0);
      Node node4 = new Node(15, 31, 48);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough((Node) null, flowScope1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test069()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Locale locale0 = Locale.TRADITIONAL_CHINESE;
      PrintStream printStream0 = mockPrintStream0.format(locale0, "", (Object[]) null);
      Compiler compiler0 = new Compiler(printStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      node0.getDirectives();
      Node node1 = new Node(101, 50, 4095);
      node0.addChildrenToBack(node1);
      node1.setOptionalArg(true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap1 = ImmutableSortedMap.copyOf((Map<? extends String, ? extends CodingConvention.AssertionFunctionSpec>) immutableSortedMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap1);
      compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention1 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter1 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(144, 4095, 54);
      FlowScope flowScope0 = linkedFlowScope0.createChildFlowScope();
      Node node3 = new Node(154, node0, node2, 139, 29);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node3, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // STRING_KEY 139 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test070()  throws Throwable  {
      Locale locale0 = Locale.TRADITIONAL_CHINESE;
      Compiler compiler0 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      node0.getDirectives();
      Node node1 = new Node(101, 50, (-18));
      node1.copyInformationFrom(node0);
      node0.addChildrenToBack(node1);
      node1.setOptionalArg(true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap1 = ImmutableSortedMap.copyOf((Map<? extends String, ? extends CodingConvention.AssertionFunctionSpec>) immutableSortedMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap1);
      compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention1 = new GoogleCodingConvention();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      Node node2 = new Node(32, node0, node0, node0, 486, 39);
      typeInference0.flowThrough(node2, linkedFlowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test071()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(2, node0, node0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(46, 0, 116);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      typeInference1.createEntryLattice();
      FlowScope flowScope1 = typeInference0.createEntryLattice();
      assertTrue(flowScope1.equals((Object)flowScope0));
  }

  @Test(timeout = 4000)
  public void test072()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(49, node0, node0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      Node node2 = new Node(38, (-1185), 4095);
      JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("", jSTypeNative0);
      treeMap0.put("", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      typeInference1.createEntryLattice();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      FlowScope flowScope0 = linkedFlowScope1.createChildFlowScope();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope0);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // NAME is not a string node
         //
         verifyException("com.google.javascript.rhino.Node", e);
      }
  }

  @Test(timeout = 4000)
  public void test073()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jf!_/C", "<)5sI;\"Jf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jf!_/C");
      boolean boolean0 = true;
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      node0.getDirectives();
      Node node1 = Node.newString("<)5sI;\"Jf!_/C");
      node1.addChildrenToBack(node0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention1 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node2 = new Node(113, 39, 8);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // WHILE 39 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test074()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream("<)5sI;\"Jlf!_/C");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(4, node0, node0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = null;
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(47, 52, 15);
      typeInference0.flowThrough(node1, linkedFlowScope0);
      // Undeclared exception!
      try { 
        ReferenceCollectingCallback.Reference.createRefForTest((CompilerInput) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.ReferenceCollectingCallback$Reference", e);
      }
  }

  @Test(timeout = 4000)
  public void test075()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      PeepholeFoldConstants peepholeFoldConstants0 = new PeepholeFoldConstants(false);
      Node node1 = peepholeFoldConstants0.optimizeSubtree(node0);
      controlFlowGraph0.createNode(node1);
      Node node2 = new Node(49, node0, node0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      Scope scope0 = Scope.createLatticeBottom(node2);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      Node node3 = new Node(13, (-1185), 4095);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node4 = new Node(26, 52, 12);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node4, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // NOT 52 : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test076()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(49, node0, node0);
      Node node2 = new Node(16, 4095, 126);
      node2.addChildrenToBack(node1);
      node0.setOptionalArg(true);
      Scope scope0 = Scope.createLatticeBottom(node2);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap1 = ImmutableSortedMap.copyOf((Map<? extends String, ? extends CodingConvention.AssertionFunctionSpec>) immutableSortedMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      compiler0.getTypeRegistry();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap2 = ImmutableSortedMap.of();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap3 = ImmutableSortedMap.copyOf((Map<? extends String, ? extends CodingConvention.AssertionFunctionSpec>) immutableSortedMap2);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap4 = immutableSortedMap3.descendingMap();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap4);
      JSTypeRegistry jSTypeRegistry1 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention1 = new GoogleCodingConvention();
      compiler0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter1 = new ClosureReverseAbstractInterpreter(googleCodingConvention1, jSTypeRegistry1);
      TypeInference typeInference2 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap1);
      CompilerOptions compilerOptions0 = compiler0.getOptions();
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      Scope scope1 = cleanupPasses0.topScope;
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      Node node3 = new Node(15, 30, 42);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node3, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LE 30 : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test077()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(49, node0, node0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, treeMap0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(5, (-5289), 40);
      typeInference0.flowThrough(node2, linkedFlowScope0);
      typeInference1.createEntryLattice();
      TypeInference typeInference2 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeMap0);
      typeInference2.createEntryLattice();
      System.setCurrentTimeMillis(4294967295L);
  }

  @Test(timeout = 4000)
  public void test078()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jl-!_/C", "<)5sI;\"Jl-!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream("<)5sI;\"Jl-!_/C");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jl-!_/C");
      boolean boolean0 = false;
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      node0.getDirectives();
      Node node1 = new Node(143, (-1272), 57);
      node1.addChildrenToBack(node0);
      node1.setOptionalArg(false);
      Scope scope0 = Scope.createLatticeBottom(node1);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      GoogleCodingConvention googleCodingConvention1 = new GoogleCodingConvention();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(21, 347, 42);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      // Undeclared exception!
      try { 
        typeInference1.flowThrough(node2, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test079()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream("<)5sI;\"Jlf!_/C");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      node0.getDirectives();
      Node node1 = Node.newString("<)5sI;\"Jlf!_/C");
      node0.addChildrenToBack(node1);
      node0.setOptionalArg(false);
      Scope scope0 = Scope.createLatticeBottom(node0);
      compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention1 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node2 = new Node(117, 1088, 117);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // CONTINUE 1088 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test080()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      node0.getDirectives();
      Node node1 = new Node(101, 50, 1);
      node0.addChildrenToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node2 = new Node(31, 8, 43);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      linkedFlowScope2.createChildFlowScope();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      PeepholeRemoveDeadCode peepholeRemoveDeadCode0 = new PeepholeRemoveDeadCode();
      Node node3 = peepholeRemoveDeadCode0.optimizeSubtree(node1);
      Node node4 = Normalize.parseAndNormalizeSyntheticCode(compiler0, "<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      node3.addChildToBack(node4);
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "Object#Key");
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node3, linkedFlowScope1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // AND 50 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test081()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Locale locale0 = Locale.TRADITIONAL_CHINESE;
      PrintStream printStream0 = mockPrintStream0.format(locale0, "", (Object[]) null);
      Compiler compiler0 = new Compiler(printStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      node0.getDirectives();
      Node node1 = new Node(101, 50, (-18));
      node1.copyInformationFrom(node0);
      node0.addChildrenToBack(node1);
      node1.setOptionalArg(true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap1 = ImmutableSortedMap.copyOf((Map<? extends String, ? extends CodingConvention.AssertionFunctionSpec>) immutableSortedMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap1);
      compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention1 = new GoogleCodingConvention();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      Node node2 = new Node(138, node0, node0, node0, 486, 39);
      typeInference0.flowThrough(node2, linkedFlowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test082()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream("<)5sI;\"Jlf!_/C");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      node0.getDirectives();
      Node node1 = new Node(42, 152, 3);
      node0.addChildrenToBack(node1);
      node0.setOptionalArg(false);
      Scope scope0 = Scope.createLatticeBottom(node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "Object#Element");
      Node node2 = new Node(43, 47, 146);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // FALSE 47 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test083()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      node0.getDirectives();
      Node node1 = new Node(101, 50, 1);
      node0.addChildrenToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node2 = new Node(31, 8, 43);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // DELPROP 8 : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test084()  throws Throwable  {
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      Node node1 = new Node(112, 50, 1);
      node0.addChildrenToBack(node1);
      node1.setOptionalArg(false);
      Scope scope0 = Scope.createLatticeBottom(node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      Node node2 = new Node(37, (-3344), 47);
      LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // DEFAULT_CASE 50 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test085()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(49, node0, node0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      Node node2 = new Node(13, (-1185), 4095);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      typeInference1.createEntryLattice();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      FlowScope flowScope0 = linkedFlowScope1.createChildFlowScope();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // NE : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test086()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(48, node0, node0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = null;
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(114, (-412), 4095);
      typeInference0.flowThrough(node2, linkedFlowScope0);
      // Undeclared exception!
      try { 
        ReferenceCollectingCallback.Reference.createRefForTest((CompilerInput) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.ReferenceCollectingCallback$Reference", e);
      }
  }

  @Test(timeout = 4000)
  public void test087()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream("<)5sI;\"Jlf!_/C");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      PeepholeFoldWithTypes peepholeFoldWithTypes1 = new PeepholeFoldWithTypes();
      node0.getDirectives();
      Node node1 = new Node((-1), 2966, 2582);
      node1.addChildrenToBack(node0);
      node0.setOptionalArg(false);
      Scope scope0 = Scope.createLatticeBottom(node1);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap1 = ImmutableSortedMap.copyOf((Map<? extends String, ? extends CodingConvention.AssertionFunctionSpec>) immutableSortedMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap1);
      compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention1 = new GoogleCodingConvention();
      compiler0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter1 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph1, closureReverseAbstractInterpreter1, scope0, immutableSortedMap1);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(56, 2147, 31);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 56
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test088()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(49, node0, node0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = null;
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      Node node2 = new Node(13, (-1185), 4095);
      FlowScope flowScope1 = typeInference0.flowThrough(node0, flowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // NE : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test089()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(49, node0, node0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, treeMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      Node node2 = new Node(53, 4, 32);
      FlowScope flowScope1 = typeInference0.flowThrough(node2, flowScope0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter1 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter1 = closureReverseAbstractInterpreter1.append(chainableReverseAbstractInterpreter0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter1, scope0, treeMap0);
      typeInference1.branchedFlowThrough(node0, flowScope1);
      typeInference1.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node2, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 53
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test090()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      Node node1 = peepholeFoldWithTypes0.optimizeSubtree(node0);
      node0.addChildrenToBack(node0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      Node node2 = new Node(38, 40, 103);
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope1);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // NAME 40 is not a string node
         //
         verifyException("com.google.javascript.rhino.Node", e);
      }
  }

  @Test(timeout = 4000)
  public void test091()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      Node node1 = peepholeFoldWithTypes0.optimizeSubtree(node0);
      node0.addChildrenToBack(node0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      compiler0.getTypeRegistry();
      Node node2 = new Node(55, 51, 57);
      node0.getDirectives();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.createEntryLattice();
      FlowScope flowScope2 = typeInference0.flowThrough(node1, flowScope0);
      typeInference0.branchedFlowThrough(node1, flowScope1);
      FlowScope flowScope3 = typeInference0.createEntryLattice();
      Node node3 = new Node(29, 132, 53);
      typeInference0.branchedFlowThrough(node0, flowScope3);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node3, flowScope2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test092()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream("<)5sI;\"Jlf!_/C");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      boolean boolean0 = false;
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      node0.getDirectives();
      Node node1 = new Node(143, (-1272), 57);
      node1.addChildrenToBack(node0);
      node1.setOptionalArg(false);
      Scope scope0 = Scope.createLatticeBottom(node1);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "Q");
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      TypeInference typeInference2 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      // Undeclared exception!
      try { 
        typeInference2.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 143
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test093()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(48, node0, node0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      Node node2 = new Node((-5289), 16, 221);
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // -5289
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test094()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      Node node1 = peepholeFoldWithTypes0.optimizeSubtree(node0);
      node0.addChildrenToBack(node0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      compiler0.getTypeRegistry();
      Node node2 = new Node(55, 51, 57);
      node0.getDirectives();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.createEntryLattice();
      FlowScope flowScope2 = typeInference0.flowThrough(node1, flowScope0);
      typeInference0.branchedFlowThrough(node1, flowScope1);
      typeInference0.createEntryLattice();
      typeInference0.flowThrough(node2, flowScope0);
      typeInference0.branchedFlowThrough(node1, flowScope2);
      typeInference0.createInitialEstimateLattice();
  }

  @Test(timeout = 4000)
  public void test095()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      node0.getDirectives();
      Node node1 = new Node(80, 50, 1);
      node0.addChildrenToBack(node1);
      node1.setOptionalArg(true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      FlowScope flowScope0 = typeInference1.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 80
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test096()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      Node node1 = peepholeFoldWithTypes0.optimizeSubtree(node0);
      node0.addChildrenToBack(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = null;
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      compiler0.getTypeRegistry();
      Node node2 = new Node(55, 51, 57);
      node0.getDirectives();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      typeInference0.flowThrough(node0, flowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 55
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test097()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream("<)5sI;\"Jlf!_/C");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      node0.getDirectives();
      Node node1 = new Node(42, 152, 3);
      node0.addChildrenToBack(node1);
      node0.setOptionalArg(false);
      Scope scope0 = Scope.createLatticeBottom(node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "Object#Element");
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // THIS 152 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test098()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("<)5sI;\"JlN!_/C");
      Compiler compiler0 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"JlN!_/C");
      ControlFlowAnalysis.computeFollowNode(node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      MockPrintStream mockPrintStream1 = new MockPrintStream("<)5sI;\"JlN!_/C");
      Node node1 = Node.newString("<)5sI;\"JlN!_/C");
      node1.addChildrenToBack(node0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      Node node2 = new Node(100, 118, 46);
      FlowScope flowScope1 = typeInference1.createEntryLattice();
      FlowScope flowScope2 = typeInference0.flowThrough(node1, flowScope0);
      typeInference1.flowThrough(node0, flowScope2);
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node2, flowScope1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test099()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream("<)5sI;\"Jlf!_/C");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowAnalysis.computeFollowNode(node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      Node node1 = Node.newString("<)5sI;\"Jlf!_/C");
      node1.addChildrenToBack(node0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      compiler0.getTypeRegistry();
      Node node2 = new Node(150, 2889, 29);
      node0.getDirectives();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node2, flowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 150
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test100()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("<)5sI;\"JlN!_/C");
      Compiler compiler0 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"JlN!_/C");
      ControlFlowAnalysis.computeFollowNode(node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      MockPrintStream mockPrintStream1 = new MockPrintStream("<)5sI;\"JlN!_/C");
      Node node1 = Node.newString("<)5sI;\"JlN!_/C");
      node1.addChildrenToBack(node0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      Node node2 = new Node(8, (-302), 119);
      typeInference0.createEntryLattice();
      typeInference0.flowThrough(node2, flowScope0);
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node2, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 8
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test101()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream("<)5sI;\"Jlf!_/C");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowAnalysis.computeFollowNode(node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      Node node1 = Node.newString("<)5sI;\"Jlf!_/C");
      node1.addChildrenToBack(node0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      typeInference0.createEntryLattice();
      TypeInference typeInference2 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      Node node2 = new Node(50);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference2.branchedFlowThrough(node2, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 50
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test102()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(57, node0, node0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      node1.setOptionalArg(false);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node1, false, false);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph1, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      typeInference1.createEntryLattice();
      Node node2 = new Node((-4096), 1736, 53);
      FlowScope flowScope0 = typeInference1.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 57
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test103()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Node node1 = new Node(49, node0, node0);
      TreeSet<String> treeSet0 = new TreeSet<String>();
      Node node2 = new Node(16, 4095, 126);
      node2.addChildrenToBack(node1);
      node0.setOptionalArg(true);
      Scope scope0 = Scope.createLatticeBottom(node2);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap1 = ImmutableSortedMap.copyOf((Map<? extends String, ? extends CodingConvention.AssertionFunctionSpec>) immutableSortedMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention1 = new GoogleCodingConvention();
      compiler0.getTypeRegistry();
      JSTypeRegistry jSTypeRegistry1 = compiler0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter1 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry1);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter1, scope0, immutableSortedMap1);
      FlowScope flowScope0 = typeInference1.createEntryLattice();
      Node node3 = new Node((-1206), 8, 38);
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node2, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // GT 4095 : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test104()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Locale locale0 = Locale.TRADITIONAL_CHINESE;
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      Node node1 = new Node(120, node0, node0);
      node0.isEquivalentToShallow(node1);
      node0.getDirectives();
      Node node2 = new Node(16, 41, 37);
      node0.addChildrenToBack(node2);
      node0.setOptionalArg(false);
      Scope scope0 = Scope.createLatticeBottom(node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      jSTypeRegistry0.forwardDeclareType("<)5sI;\"Jlf!_/C");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      FlowScope flowScope0 = typeInference1.createEntryLattice();
      Node node3 = new Node(8, 403, 129);
      TypeInference typeInference2 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      typeInference2.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // GT 41 : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test105()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Locale locale0 = Locale.TRADITIONAL_CHINESE;
      PrintStream printStream0 = mockPrintStream0.format(locale0, "", (Object[]) null);
      Compiler compiler0 = new Compiler(printStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      node0.getDirectives();
      Node node1 = new Node(101, 50, (-18));
      node0.addChildrenToBack(node1);
      node1.setOptionalArg(true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap1 = ImmutableSortedMap.copyOf((Map<? extends String, ? extends CodingConvention.AssertionFunctionSpec>) immutableSortedMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap1);
      compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention1 = new GoogleCodingConvention();
      JSTypeRegistry jSTypeRegistry1 = compiler0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter1 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry1);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      FlowScope flowScope0 = typeInference1.createEntryLattice();
      Node node2 = new Node(144, 4095, (-18));
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 144
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test106()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Locale locale0 = Locale.TRADITIONAL_CHINESE;
      PrintStream printStream0 = mockPrintStream0.format(locale0, "", (Object[]) null);
      Compiler compiler0 = new Compiler(printStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      node0.getDirectives();
      Node node1 = new Node(101, 50, (-18));
      node0.addChildrenToBack(node1);
      node1.setOptionalArg(true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      typeInference1.createEntryLattice();
      Node node2 = new Node(37, 967, 52);
      FlowScope flowScope0 = typeInference1.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test107()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"JlN!_/C", "<)5sI;\"JlN!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream("<)5sI;\"JlN!_/C");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"JlN!_/C");
      ControlFlowAnalysis.computeFollowNode(node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      MockPrintStream mockPrintStream1 = new MockPrintStream("<)5sI;\"JlN!_/C");
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      Node node1 = Node.newString("<)5sI;\"JlN!_/C");
      node1.addChildrenToBack(node0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      SimpleErrorReporter simpleErrorReporter1 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      Node node2 = new Node(36, 1, 15);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 36
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test108()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      Node node1 = Node.newString("<)5sI;\"Jlf!_/C");
      Node node2 = new Node((-11), node0, node0, node1, 1343, 37);
      node1.addChildrenToBack(node2);
      Scope scope0 = Scope.createLatticeBottom(node2);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      SimpleErrorReporter simpleErrorReporter1 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeMap0);
      FlowScope flowScope0 = typeInference1.createEntryLattice();
      Node node3 = new Node(52, 967, 4);
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node3, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // INSTANCEOF 967 : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test109()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockFile mockFile1 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Locale locale0 = Locale.TRADITIONAL_CHINESE;
      PrintStream printStream0 = mockPrintStream0.format(locale0, "", (Object[]) null);
      Compiler compiler0 = new Compiler(printStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, true);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      node0.getDirectives();
      Node node1 = new Node(101, 50, (-18));
      node0.addChildrenToBack(node1);
      node1.setOptionalArg(true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("<)5sI;\"Jlf!_/C");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("<)5sI;\"Jlf!_/C", codingConvention_AssertionFunctionSpec0, "", codingConvention_AssertionFunctionSpec0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap1 = immutableSortedMap0.tailMap("<)5sI;\"Jlf!_/C", true);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap1);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test110()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("<)5sI;\"Jlf!_/C");
      ControlFlowAnalysis.computeFollowNode(node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      Node node1 = new Node(49, node0, node0);
      node1.getDirectives();
      node0.addChildrenToBack(node1);
      node0.setOptionalArg(false);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter1 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // THROW does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test111()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      Node node1 = peepholeFoldWithTypes0.optimizeSubtree(node0);
      node0.addChildrenToBack(node0);
      node1.setOptionalArg(true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      SimpleErrorReporter simpleErrorReporter1 = new SimpleErrorReporter();
      SimpleErrorReporter simpleErrorReporter2 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter1, true);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeMap0);
      FlowScope flowScope0 = typeInference1.createEntryLattice();
      Node node2 = new Node((-3107), (-351), (-1104));
      TypeInference typeInference2 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      // Undeclared exception!
      try { 
        typeInference2.branchedFlowThrough(node2, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // -3107
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test112()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowAnalysis.computeFollowNode(node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      mockPrintStream0.append('L');
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      Node node1 = Node.newString("<)5sI;\"Jlf!_/C");
      node1.addChildrenToBack(node0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      SimpleErrorReporter simpleErrorReporter1 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      FlowScope flowScope0 = typeInference1.createEntryLattice();
      Node node2 = new Node(39, 32, 52);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Number node not created with Node.newNumber
         //
         verifyException("com.google.javascript.rhino.Node", e);
      }
  }

  @Test(timeout = 4000)
  public void test113()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowAnalysis.computeFollowNode(node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      Node node1 = peepholeFoldWithTypes0.optimizeSubtree(node0);
      node0.addChildrenToBack(node1);
      node0.setOptionalArg(true);
      peepholeFoldWithTypes0.optimizeSubtree(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      Iterator<NoType> iterator0 = (Iterator<NoType>) mock(Iterator.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(iterator0).hasNext();
      ImmutableList.copyOf((Iterator<? extends JSType>) iterator0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      closureReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node0, flowScope0, false);
      FlowScope flowScope1 = typeInference0.flowThrough(node0, flowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, flowScope1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SCRIPT [opt_arg: com.google.javascript.rhino.Node$IntPropListItem@0000000635] [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000000618] [input_id: com.google.javascript.rhino.Node$ObjectPropListItem@0000000619] does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test114()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream("<)5sI;\"Jlf!_/C");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowAnalysis.computeFollowNode(node0);
      boolean boolean0 = true;
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      MockPrintStream mockPrintStream1 = new MockPrintStream("<)5sI;\"Jlf!_/C");
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      Node node1 = Node.newString("<)5sI;\"Jlf!_/C");
      node1.addChildrenToBack(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = null;
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      FlowScope flowScope0 = typeInference1.createInitialEstimateLattice();
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node0, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SCRIPT [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000000618] [input_id: com.google.javascript.rhino.Node$ObjectPropListItem@0000000619] does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test115()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      Node node1 = peepholeFoldWithTypes0.optimizeSubtree(node0);
      node0.addChildrenToBack(node0);
      node1.setOptionalArg(true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      SimpleErrorReporter simpleErrorReporter1 = new SimpleErrorReporter();
      SimpleErrorReporter simpleErrorReporter2 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter1, true);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeMap0);
      FlowScope flowScope0 = typeInference1.createEntryLattice();
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test116()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      Node node1 = compiler0.parseSyntheticCode("<)5sI;\"Jlf!_/C");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, true, true);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      Node node2 = peepholeFoldWithTypes0.optimizeSubtree(node0);
      node0.addChildrenToBack(node2);
      node0.setOptionalArg(false);
      node1.setOptionalArg(true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      Iterator<BooleanType> iterator0 = (Iterator<BooleanType>) mock(Iterator.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(iterator0).hasNext();
      ImmutableList.copyOf((Iterator<? extends JSType>) iterator0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, flowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test117()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      node0.getDirectives();
      Node node1 = new Node(101, 50, 1);
      node0.addChildrenToBack(node1);
      node1.setOptionalArg(true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      Node node2 = new Node(128, 38, 31);
      typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node1, flowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test118()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream("<)5sI;\"Jlf!_/C");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowAnalysis.computeFollowNode(node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      mockPrintStream0.append('L');
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      Node node1 = peepholeFoldWithTypes0.optimizeSubtree(node0);
      node0.addChildrenToBack(node1);
      node0.setOptionalArg(true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      Compiler compiler1 = new Compiler();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      Iterator<NoType> iterator0 = (Iterator<NoType>) mock(Iterator.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(iterator0).hasNext();
      ImmutableList<JSType> immutableList0 = ImmutableList.copyOf((Iterator<? extends JSType>) iterator0);
      Node node2 = jSTypeRegistry0.createParameters((List<JSType>) immutableList0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      closureReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node1, flowScope0, true);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node2, flowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test119()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowAnalysis.computeFollowNode(node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      mockPrintStream0.append('L');
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      Node node1 = peepholeFoldWithTypes0.optimizeSubtree(node0);
      node0.addChildrenToBack(node1);
      node0.setOptionalArg(true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      Compiler compiler1 = new Compiler();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      Iterator<NoType> iterator0 = (Iterator<NoType>) mock(Iterator.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(iterator0).hasNext();
      ImmutableList.copyOf((Iterator<? extends JSType>) iterator0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = closureReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node1, flowScope0, false);
      Node node2 = Node.newString("JSC_FUNCTION_LITERAL_UNDEFINED_THIS", 117, 47);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // STRING JSC_FUNCTION_LITERAL_UNDEFINED_THIS 117 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test120()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowAnalysis.computeFollowNode(node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      mockPrintStream0.append('L');
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      Node node1 = Node.newString("<)5sI;\"Jlf!_/C");
      node1.addChildrenToBack(node0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      SimpleErrorReporter simpleErrorReporter1 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      FlowScope flowScope0 = typeInference1.createEntryLattice();
      Node node2 = new Node(39, 32, 52);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // STRING <)5sI;\"Jlf!_/C does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test121()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowAnalysis.computeFollowNode(node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      Node node1 = peepholeFoldWithTypes0.optimizeSubtree(node0);
      node0.addChildrenToBack(node1);
      node0.setOptionalArg(true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      Compiler compiler1 = new Compiler();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      SimpleErrorReporter simpleErrorReporter1 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry1 = new JSTypeRegistry(simpleErrorReporter1, false);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry1);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      JSType[] jSTypeArray0 = new JSType[0];
      FlowScope flowScope1 = closureReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node0, flowScope0, false);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, flowScope1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SCRIPT [opt_arg: com.google.javascript.rhino.Node$IntPropListItem@0000000635] [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000000618] [input_id: com.google.javascript.rhino.Node$ObjectPropListItem@0000000619] does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test122()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowAnalysis.computeFollowNode(node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      mockPrintStream0.append('L');
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      Node node1 = peepholeFoldWithTypes0.optimizeSubtree(node0);
      node0.addChildrenToBack(node1);
      node0.setOptionalArg(true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      Compiler compiler1 = new Compiler();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
      Iterator<EnumType> iterator0 = (Iterator<EnumType>) mock(Iterator.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(iterator0).hasNext();
      ImmutableList<JSType> immutableList0 = ImmutableList.copyOf((Iterator<? extends JSType>) iterator0);
      jSTypeRegistry0.createParameters((List<JSType>) immutableList0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      closureReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node0, flowScope0, false);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SCRIPT [opt_arg: com.google.javascript.rhino.Node$IntPropListItem@0000000635] [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000000618] [input_id: com.google.javascript.rhino.Node$ObjectPropListItem@0000000619] does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test123()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowAnalysis.computeFollowNode(node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      mockPrintStream0.append('L');
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      node0.addChildrenToBack(node0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      SimpleErrorReporter simpleErrorReporter1 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter1 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      typeInference0.createInitialEstimateLattice();
      PeepholeRemoveDeadCode peepholeRemoveDeadCode0 = new PeepholeRemoveDeadCode();
      // Undeclared exception!
      try { 
        peepholeRemoveDeadCode0.tryFoldDo((Node) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.PeepholeRemoveDeadCode", e);
      }
  }

  @Test(timeout = 4000)
  public void test124()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowAnalysis.computeFollowNode(node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      mockPrintStream0.append('L');
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      Node node1 = peepholeFoldWithTypes0.optimizeSubtree(node0);
      node0.addChildrenToBack(node1);
      node0.setOptionalArg(true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      Compiler compiler1 = new Compiler();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      Iterator<NoType> iterator0 = (Iterator<NoType>) mock(Iterator.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(iterator0).hasNext();
      ImmutableList<JSType> immutableList0 = ImmutableList.copyOf((Iterator<? extends JSType>) iterator0);
      Node node2 = jSTypeRegistry0.createParameters((List<JSType>) immutableList0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      closureReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node2, linkedFlowScope0, true);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      typeInference0.createInitialEstimateLattice();
      FlowScope flowScope1 = closureReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node0, flowScope0, false);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test125()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      node0.getDirectives();
      Node node1 = new Node(101, 50, 1);
      node0.addChildrenToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node2 = new Node(31, 8, 43);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      Node node3 = new Node(37, node0, node2, node0, 2, (-1));
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      typeInference0.flowThrough(node3, linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope0);
      typeInference0.branchedFlowThrough(node0, linkedFlowScope2);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test126()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowAnalysis.computeFollowNode(node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      mockPrintStream0.append('L');
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      Node node1 = peepholeFoldWithTypes0.optimizeSubtree(node0);
      node0.addChildrenToBack(node1);
      node0.setOptionalArg(true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      ArrayDeque<FunctionType> arrayDeque0 = new ArrayDeque<FunctionType>();
      Iterator<FunctionType> iterator0 = arrayDeque0.iterator();
      ImmutableList<JSType> immutableList0 = ImmutableList.copyOf((Iterator<? extends JSType>) iterator0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      jSTypeRegistry0.createParameters((List<JSType>) immutableList0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      closureReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node1, flowScope0, true);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node1, (FlowScope) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test127()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowAnalysis.computeFollowNode(node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      mockPrintStream0.append('L');
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      Node node1 = peepholeFoldWithTypes0.optimizeSubtree(node0);
      node0.addChildrenToBack(node1);
      node0.setOptionalArg(true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
      jSTypeRegistry0.getType((String) null);
      scope0.declare("<)5sI;\"Jlf!_/C", node1, (JSType) null, (CompilerInput) null);
      Compiler compiler1 = new Compiler();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      SimpleErrorReporter simpleErrorReporter1 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry1 = new JSTypeRegistry(simpleErrorReporter1, true);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      BooleanLiteralSet booleanLiteralSet1 = BooleanLiteralSet.FALSE;
      BooleanLiteralSet booleanLiteralSet2 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet1, false);
      assertEquals(BooleanLiteralSet.FALSE, booleanLiteralSet2);
      
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SCRIPT [opt_arg: com.google.javascript.rhino.Node$IntPropListItem@0000000635] [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000000618] [input_id: com.google.javascript.rhino.Node$ObjectPropListItem@0000000619] does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test128()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowAnalysis.computeFollowNode(node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      mockPrintStream0.append('L');
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      Node node1 = peepholeFoldWithTypes0.optimizeSubtree(node0);
      node0.addChildrenToBack(node1);
      node0.setOptionalArg(true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      Compiler compiler1 = new Compiler();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ArrayList<JSType> arrayList0 = new ArrayList<JSType>();
      Iterator<JSType> iterator0 = arrayList0.iterator();
      ImmutableList.copyOf((Iterator<? extends JSType>) iterator0);
      jSTypeRegistry0.createParameters((List<JSType>) arrayList0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(googleCodingConvention0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
      typeInference0.createEntryLattice();
      boolean boolean0 = false;
      Node node2 = null;
      try {
        node2 = new Node(1, node0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // new child has existing parent
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test129()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowAnalysis.computeFollowNode(node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      mockPrintStream0.append('L');
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      Node node1 = Node.newString("<)5sI;\"Jlf!_/C");
      node0.addChildrenToBack(node1);
      node0.setOptionalArg(true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ArrayList<NamedType> arrayList0 = new ArrayList<NamedType>();
      Iterator<NamedType> iterator0 = arrayList0.iterator();
      ImmutableList<JSType> immutableList0 = ImmutableList.copyOf((Iterator<? extends JSType>) iterator0);
      Node node2 = jSTypeRegistry0.createParameters((List<JSType>) immutableList0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      closureReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node1, flowScope0, true);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test130()  throws Throwable  {
      MockFile mockFile0 = new MockFile("<)5sI;\"Jlf!_/C", "<)5sI;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "<)5sI;\"Jlf!_/C");
      ControlFlowAnalysis.computeFollowNode(node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      mockPrintStream0.append('L');
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      Node node1 = peepholeFoldWithTypes0.optimizeSubtree(node0);
      node0.addChildrenToBack(node1);
      node0.setOptionalArg(true);
      Scope scope0 = Scope.createLatticeBottom(node0);
      Compiler compiler1 = new Compiler();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      Iterator<NoType> iterator0 = (Iterator<NoType>) mock(Iterator.class, new ViolatedAssumptionAnswer());
      doReturn(false).when(iterator0).hasNext();
      ImmutableList<JSType> immutableList0 = ImmutableList.copyOf((Iterator<? extends JSType>) iterator0);
      Node node2 = jSTypeRegistry0.createParameters((List<JSType>) immutableList0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = closureReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node0, flowScope0, false);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test131()  throws Throwable  {
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      MockFile mockFile0 = new MockFile("<)5sj;\"Jlf!_/C", "<)5sj;\"Jlf!_/C");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "");
      ControlFlowAnalysis.computeFollowNode(node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      node0.setOptionalArg(true);
      mockPrintStream0.print((Object) null);
      Scope scope0 = Scope.createLatticeBottom(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Tb(q[JaaH~W3M$");
      String string0 = "com.google.javascript.jscomp.TypeInference$1";
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Tb(q[JaaH~W3M$", codingConvention_AssertionFunctionSpec0, "com.google.javascript.jscomp.TypeInference$1", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = null;
      try {
        typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test132()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;
      // Undeclared exception!
      try { 
        TypeInference.getBooleanOutcomes((BooleanLiteralSet) null, booleanLiteralSet0, false);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test133()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("ED");
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
      Compiler compiler0 = new Compiler(printStreamErrorManager0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      CodingConventions.Proxy codingConventions_Proxy0 = new CodingConventions.Proxy(googleCodingConvention0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(codingConventions_Proxy0, jSTypeRegistry0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("ED");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("C|gxI2%SRED ", codingConvention_AssertionFunctionSpec0, "ED", codingConvention_AssertionFunctionSpec0, "Object#Key", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = null;
      try {
        typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, (Scope) null, immutableSortedMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.Compiler", e);
      }
  }

  @Test(timeout = 4000)
  public void test134()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.TRUE;
      boolean boolean0 = true;
      BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, true);
      booleanLiteralSet1.intersection(booleanLiteralSet0);
      BooleanLiteralSet booleanLiteralSet2 = BooleanLiteralSet.TRUE;
      booleanLiteralSet1.union(booleanLiteralSet2);
      BooleanLiteralSet booleanLiteralSet3 = BooleanLiteralSet.BOTH;
      TypeInference.getBooleanOutcomes(booleanLiteralSet3, booleanLiteralSet1, false);
      BooleanLiteralSet booleanLiteralSet4 = BooleanLiteralSet.TRUE;
      TypeInference.getBooleanOutcomes(booleanLiteralSet2, booleanLiteralSet4, true);
      MockPrintStream mockPrintStream0 = null;
      try {
        mockPrintStream0 = new MockPrintStream("", "KUi");
        fail("Expecting exception: FileNotFoundException");
      
      } catch(Throwable e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.evosuite.runtime.mock.java.io.MockFileOutputStream", e);
      }
  }

  @Test(timeout = 4000)
  public void test135()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.TRUE;
      boolean boolean0 = false;
      TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
      Compiler compiler0 = new Compiler((PrintStream) null);
      // Undeclared exception!
      try { 
        compiler0.computeCFG();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.Compiler", e);
      }
  }
}
