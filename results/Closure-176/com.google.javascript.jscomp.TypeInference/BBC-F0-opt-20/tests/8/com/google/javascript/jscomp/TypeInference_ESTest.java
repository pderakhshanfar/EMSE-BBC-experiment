/*
 * This file was automatically generated by EvoSuite
 * Tue Oct 12 08:53:37 GMT 2021
 */

package com.google.javascript.jscomp;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSortedMap;
import com.google.javascript.jscomp.AbstractCompiler;
import com.google.javascript.jscomp.CleanupPasses;
import com.google.javascript.jscomp.ClosureCodingConvention;
import com.google.javascript.jscomp.CodingConvention;
import com.google.javascript.jscomp.CodingConventions;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerOptions;
import com.google.javascript.jscomp.ControlFlowGraph;
import com.google.javascript.jscomp.ExploitAssigns;
import com.google.javascript.jscomp.GoogleCodingConvention;
import com.google.javascript.jscomp.JqueryCodingConvention;
import com.google.javascript.jscomp.LinkedFlowScope;
import com.google.javascript.jscomp.LoggerErrorManager;
import com.google.javascript.jscomp.Normalize;
import com.google.javascript.jscomp.Scope;
import com.google.javascript.jscomp.SyntacticScopeCreator;
import com.google.javascript.jscomp.TightenTypes;
import com.google.javascript.jscomp.Tracer;
import com.google.javascript.jscomp.TypeInference;
import com.google.javascript.jscomp.TypedScopeCreator;
import com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.FlowScope;
import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;
import com.google.javascript.rhino.ErrorReporter;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.SimpleErrorReporter;
import com.google.javascript.rhino.jstype.BooleanLiteralSet;
import com.google.javascript.rhino.jstype.JSType;
import com.google.javascript.rhino.jstype.JSTypeNative;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import com.google.javascript.rhino.jstype.NamedType;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.logging.Logger;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.System;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class TypeInference_ESTest extends TypeInference_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      ExploitAssigns exploitAssigns0 = new ExploitAssigns();
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "i%OZL>2l");
      Node node1 = new Node(2, node0, node0, node0, node0);
      Node node2 = new Node(32, 4, 2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      compiler0.getTopScope();
      Scope scope0 = syntacticScopeCreator0.createScope(node1, (Scope) null);
      JSTypeNative jSTypeNative0 = JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("Object#Element");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Key", codingConvention_AssertionFunctionSpec0, "TightenTypes pass appears to be stuck in an infinite loop.", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      Node node3 = Node.newNumber(2637.08009);
      Node node4 = new Node(100, node3);
      NamedType namedType0 = jSTypeRegistry0.createNamedType("TightenTypes pass appears to be stuck in an infinite loop.", (String) null, 32, (-4507));
      namedType0.toMaybeEnumElementType();
      FlowScope flowScope0 = typeInference0.flowThrough(node3, linkedFlowScope0);
      typeInference0.flowThrough(node4, flowScope0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      BooleanLiteralSet booleanLiteralSet1 = BooleanLiteralSet.TRUE;
      BooleanLiteralSet booleanLiteralSet2 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet1, false);
      assertEquals(BooleanLiteralSet.TRUE, booleanLiteralSet2);
      
      FlowScope flowScope1 = typeInference0.flowThrough(node3, linkedFlowScope0);
      assertNotSame(flowScope1, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      Logger logger0 = Logger.getAnonymousLogger();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "i%OZL>@");
      Node node1 = new Node(48, node0, node0, node0, node0, 40, 47);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      compiler0.getTopScope();
      Scope scope0 = syntacticScopeCreator0.createScope(node1, (Scope) null);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Key");
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("Object#Element");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("i%OZL>@", codingConvention_AssertionFunctionSpec0, "Object#Element", codingConvention_AssertionFunctionSpec1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;
      LinkedFlowScope.createEntryLattice((Scope) null);
      LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(31, node1);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      ExploitAssigns exploitAssigns0 = new ExploitAssigns();
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "i%OZL>2@");
      Node node1 = new Node(4095, node0, node0, node0, 56, 57);
      Node node2 = new Node(61, 36, 43);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      ClosureCodingConvention closureCodingConvention1 = new ClosureCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter1 = new ClosureReverseAbstractInterpreter(closureCodingConvention1, jSTypeRegistry0);
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      compiler0.getTopScope();
      Scope scope0 = syntacticScopeCreator0.createScope(node1, (Scope) null);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("U4'3eZ", codingConvention_AssertionFunctionSpec0, "com.google.javascript.jscomp.AliasStrings", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      typeInference0.flowThrough(node2, linkedFlowScope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      assertTrue(linkedFlowScope1.equals((Object)linkedFlowScope0));
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      ExploitAssigns exploitAssigns0 = new ExploitAssigns();
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "i%OZL>2l");
      Node node1 = new Node(2, node0, node0, node0, node0);
      Node node2 = new Node(149, 4, 2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      node0.removeChildren();
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      compiler0.getTopScope();
      Scope scope0 = syntacticScopeCreator0.createScope(node1, (Scope) null);
      JSTypeNative jSTypeNative0 = JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("Object#Element");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Key", codingConvention_AssertionFunctionSpec0, "TightenTypes pass appears to be stuck in an infinite loop.", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      typeInference0.flowThrough(node2, linkedFlowScope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      FlowScope flowScope1 = typeInference0.createEntryLattice();
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      ExploitAssigns exploitAssigns0 = new ExploitAssigns();
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "i%OZL>2l");
      Node node1 = new Node(2, node0, node0, node0, node0);
      Node node2 = new Node(32, 4, 2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      compiler0.getTopScope();
      Scope scope0 = syntacticScopeCreator0.createScope(node1, (Scope) null);
      JSTypeNative jSTypeNative0 = JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("Object#Element");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Key", codingConvention_AssertionFunctionSpec0, "TightenTypes pass appears to be stuck in an infinite loop.", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      typeInference0.flowThrough(node2, linkedFlowScope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "i%OZL>#@");
      Node.newString("i%OZL>#@", 3338, 55);
      Node node1 = new Node(37, node0, node0, node0, node0);
      Node node2 = Node.newString("i%OZL>#@", 162, 1885);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, false, false);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      compiler0.getTopScope();
      Scope scope0 = syntacticScopeCreator0.createScope(node1, (Scope) null);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("i%OZL>#@");
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Element", codingConvention_AssertionFunctionSpec0, "", codingConvention_AssertionFunctionSpec1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      ExploitAssigns exploitAssigns0 = new ExploitAssigns();
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "i%OZL>2l");
      Node node1 = Node.newString("i%OZL>2l", 2, 55);
      Node node2 = new Node(2, node0, node1, node1, node1);
      Node node3 = new Node(149, 4, 2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      compiler0.getTopScope();
      Scope scope0 = syntacticScopeCreator0.createScope(node2, (Scope) null);
      JSTypeNative jSTypeNative0 = JSTypeNative.SYNTAX_ERROR_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("Object#Element");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Key", codingConvention_AssertionFunctionSpec0, "TightenTypes pass appears to be stuck in an infinite loop.", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      typeInference0.flowThrough(node3, linkedFlowScope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      assertTrue(linkedFlowScope1.equals((Object)linkedFlowScope0));
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      ExploitAssigns exploitAssigns0 = new ExploitAssigns();
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "h");
      Node.newString("i%OZL>2@", (-2777), 108);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      compiler0.getTopScope();
      Scope scope0 = syntacticScopeCreator0.createScope(node0, (Scope) null);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Invariant failed.  ");
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("h");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("", codingConvention_AssertionFunctionSpec0, "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      ImmutableList<JSType> immutableList0 = ImmutableList.of();
      jSTypeRegistry0.createParameters((List<JSType>) immutableList0);
      TypeInference typeInference1 = null;
      try {
        typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, (Scope) null, immutableSortedMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      ExploitAssigns exploitAssigns0 = new ExploitAssigns();
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "h");
      Node.newString("i%OZL>2@", (-2777), 108);
      Node node1 = new Node((-1568), node0, node0, node0, node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      compiler0.getTopScope();
      Scope scope0 = syntacticScopeCreator0.createScope(node1, (Scope) null);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Invariant failed.  ");
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("", codingConvention_AssertionFunctionSpec0, "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      ImmutableList<JSType> immutableList0 = ImmutableList.of();
      Node node2 = jSTypeRegistry0.createParameters((List<JSType>) immutableList0);
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node0, linkedFlowScope0, true);
      FlowScope flowScope1 = linkedFlowScope_FlowScopeJoinOp0.apply(flowScope0, flowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      ExploitAssigns exploitAssigns0 = new ExploitAssigns();
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "i%OZL>2@");
      Node node1 = new Node(48, node0, node0, node0, node0, 40, 47);
      Node node2 = new Node(36, 4, 2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      compiler0.getTopScope();
      Scope scope0 = syntacticScopeCreator0.createScope(node1, (Scope) null);
      JSTypeNative jSTypeNative0 = JSTypeNative.SYNTAX_ERROR_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("Object#Element");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("i%OZL>2@", codingConvention_AssertionFunctionSpec0, "Object#Element", codingConvention_AssertionFunctionSpec1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      LinkedFlowScope linkedFlowScope1 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      linkedFlowScope_FlowScopeJoinOp0.apply((FlowScope) linkedFlowScope0, (FlowScope) linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      Node node3 = new Node(55, node2);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node3, linkedFlowScope1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 55
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      String string0 = "i%OZL>(@";
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "i%OZL>(@");
      Node node1 = new Node(8, node0);
      Node node2 = new Node(46, 4, 2);
      loggerErrorManager0.printSummary();
      boolean boolean0 = false;
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, boolean0, boolean0);
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      Scope scope0 = compiler0.getTopScope();
      Scope scope1 = syntacticScopeCreator0.createScope(node1, scope0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(tightenTypes0.NON_HALTING_ERROR_MSG);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(string0, codingConvention_AssertionFunctionSpec0, jSTypeRegistry0.OBJECT_ELEMENT_TEMPLATE, codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope1, immutableSortedMap0);
      int int0 = 146;
      node2.setType(int0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope1);
      typeInference0.flowThrough(node2, linkedFlowScope0);
      typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
      System.setCurrentTimeMillis(node0.MAX_COLUMN_NUMBER);
      long long0 = (-1003L);
      System.setCurrentTimeMillis(long0);
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "i%OZL>2@");
      Node node1 = new Node(48, node0, node0, node0, node0, 40, 47);
      Node node2 = new Node(36, 4, 2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      compiler0.getTopScope();
      Scope scope0 = syntacticScopeCreator0.createScope(node1, (Scope) null);
      JSTypeNative jSTypeNative0 = JSTypeNative.SYNTAX_ERROR_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("Object#Element");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("i%OZL>2@", codingConvention_AssertionFunctionSpec0, "Object#Element", codingConvention_AssertionFunctionSpec1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      linkedFlowScope_FlowScopeJoinOp0.apply((FlowScope) linkedFlowScope0, (FlowScope) linkedFlowScope0);
      Node node3 = new Node(2480, node1);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      Node node4 = Node.newString(49, "", 46, 400000);
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node4, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // THROW  46 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      String string0 = "i%OZL>(@";
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "i%OZL>(@");
      Node node1 = new Node(8, node0);
      Node node2 = new Node(46, 4, 2);
      loggerErrorManager0.printSummary();
      boolean boolean0 = false;
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, boolean0, boolean0);
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      Scope scope0 = compiler0.getTopScope();
      Scope scope1 = syntacticScopeCreator0.createScope(node1, scope0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(tightenTypes0.NON_HALTING_ERROR_MSG);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(string0, codingConvention_AssertionFunctionSpec0, jSTypeRegistry0.OBJECT_ELEMENT_TEMPLATE, codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope1, immutableSortedMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      BooleanLiteralSet booleanLiteralSet1 = BooleanLiteralSet.EMPTY;
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope1);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedFlowScope linkedFlowScope3 = LinkedFlowScope.createEntryLattice(scope1);
      FlowScope flowScope0 = semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node0, linkedFlowScope3, boolean0);
      typeInference0.flowThrough(node1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      String string0 = "i%OZL>(@";
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "i%OZL>(@");
      Node node1 = new Node(8, node0);
      Node node2 = new Node(46, 4, 2);
      loggerErrorManager0.printSummary();
      boolean boolean0 = false;
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, boolean0, boolean0);
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      Scope scope0 = compiler0.getTopScope();
      Scope scope1 = syntacticScopeCreator0.createScope(node1, scope0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(tightenTypes0.NON_HALTING_ERROR_MSG);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(string0, codingConvention_AssertionFunctionSpec0, jSTypeRegistry0.OBJECT_ELEMENT_TEMPLATE, codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope1, immutableSortedMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope1);
      typeInference0.flowThrough(node2, linkedFlowScope0);
      typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
      System.setCurrentTimeMillis(node0.MAX_COLUMN_NUMBER);
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      ExploitAssigns exploitAssigns0 = new ExploitAssigns();
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "i%OZL>2@");
      Node node1 = new Node(48, node0, node0, node0, node0, 40, 47);
      Node node2 = new Node(36, 4, 2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      compiler0.getTopScope();
      Scope scope0 = syntacticScopeCreator0.createScope(node1, (Scope) null);
      JSTypeNative jSTypeNative0 = JSTypeNative.SYNTAX_ERROR_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("Object#Element");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("i%OZL>2@", codingConvention_AssertionFunctionSpec0, "Object#Element", codingConvention_AssertionFunctionSpec1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      linkedFlowScope_FlowScopeJoinOp0.apply((FlowScope) linkedFlowScope0, (FlowScope) linkedFlowScope0);
      typeInference0.flowThrough(node0, linkedFlowScope0);
      Node node3 = new Node(2480, node1);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      Node node4 = Node.newString(49, "", 46, 400000);
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node4, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // THROW  46 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      ExploitAssigns exploitAssigns0 = new ExploitAssigns();
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "i%OZL>2@");
      Node node1 = new Node(48, node0, node0, node0, node0, 40, 47);
      Node node2 = new Node(36, 4, 2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      compiler0.getTopScope();
      Scope scope0 = syntacticScopeCreator0.createScope(node1, (Scope) null);
      JSTypeNative jSTypeNative0 = JSTypeNative.SYNTAX_ERROR_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("Object#Element");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("i%OZL>2@", codingConvention_AssertionFunctionSpec0, "Object#Element", codingConvention_AssertionFunctionSpec1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      LinkedFlowScope linkedFlowScope1 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      linkedFlowScope_FlowScopeJoinOp0.apply((FlowScope) linkedFlowScope0, (FlowScope) linkedFlowScope0);
      Node node3 = new Node(108, node2);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node3, linkedFlowScope1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // IF does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      ExploitAssigns exploitAssigns0 = new ExploitAssigns();
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "i%OZL>2@");
      Node node1 = new Node(48, node0, node0, node0, node0, 40, 47);
      Node node2 = new Node(36, 4, 2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      compiler0.getTopScope();
      Scope scope0 = syntacticScopeCreator0.createScope(node1, (Scope) null);
      JSTypeNative jSTypeNative0 = JSTypeNative.SYNTAX_ERROR_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("Object#Element");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("i%OZL>2@", codingConvention_AssertionFunctionSpec0, "Object#Element", codingConvention_AssertionFunctionSpec1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      LinkedFlowScope linkedFlowScope1 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      FlowScope flowScope0 = linkedFlowScope_FlowScopeJoinOp0.apply((FlowScope) linkedFlowScope0, (FlowScope) linkedFlowScope0);
      typeInference0.flowThrough(node0, flowScope0);
      Node node3 = new Node(55, node2);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node3, linkedFlowScope1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 55
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      ExploitAssigns exploitAssigns0 = new ExploitAssigns();
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "i%OZL>@");
      Node node1 = new Node(52, node0, node0, 4, 46);
      Node node2 = compiler0.parseSyntheticCode("i%OZL>@");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      compiler0.getTopScope();
      Scope scope0 = syntacticScopeCreator0.createScope(node1, (Scope) null);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("TightenTypes pass appears to be stuck in an infinite loop.");
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("Object#Element");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("i%OZL>@", codingConvention_AssertionFunctionSpec0, "Object#Element", codingConvention_AssertionFunctionSpec1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      compiler0.getTopScope();
      Scope scope1 = syntacticScopeCreator0.createScope(node2, (Scope) null);
      JSTypeNative jSTypeNative0 = JSTypeNative.RANGE_ERROR_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec2 = new CodingConvention.AssertionFunctionSpec("", jSTypeNative0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope1);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      FlowScope flowScope0 = linkedFlowScope1.createChildFlowScope();
      FlowScope flowScope1 = semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node2, flowScope0, false);
      closureReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node0, flowScope1, false);
      JSTypeNative jSTypeNative1 = JSTypeNative.NO_OBJECT_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec3 = new CodingConvention.AssertionFunctionSpec("", jSTypeNative1);
      ImmutableSortedMap.of("", codingConvention_AssertionFunctionSpec0, "JSC_FUNCTION_LITERAL_UNDEFINED_THIS", codingConvention_AssertionFunctionSpec3);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope2 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope3 = new LinkedFlowScope(linkedFlowScope2);
      FlowScope flowScope2 = typeInference0.flowThrough(node1, linkedFlowScope2);
      assertNotSame(flowScope2, linkedFlowScope2);
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      ExploitAssigns exploitAssigns0 = new ExploitAssigns();
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "i%OZL>2@");
      Node node1 = Node.newString("i%OZL>2@", 30, 55);
      Node node2 = new Node(2, node0, node1, node1, node1);
      Node node3 = new Node(16, 4, 2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      compiler0.getTopScope();
      Scope scope0 = syntacticScopeCreator0.createScope(node2, (Scope) null);
      JSTypeNative jSTypeNative0 = JSTypeNative.SYNTAX_ERROR_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Key", codingConvention_AssertionFunctionSpec0, "TightenTypes pass appears to be stuck in an infinite loop.", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      BooleanLiteralSet.get(true);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node3, linkedFlowScope1);
      assertNotSame(flowScope0, linkedFlowScope1);
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      ExploitAssigns exploitAssigns0 = new ExploitAssigns();
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "i%OZL>2@");
      Node node1 = new Node(48, node0, node0, node0, node0, 40, 47);
      Node node2 = new Node(36, 4, 2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      compiler0.getTopScope();
      Scope scope0 = syntacticScopeCreator0.createScope(node1, (Scope) null);
      JSTypeNative jSTypeNative0 = JSTypeNative.SYNTAX_ERROR_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("Object#Element");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("i%OZL>2@", codingConvention_AssertionFunctionSpec0, "Object#Element", codingConvention_AssertionFunctionSpec1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      LinkedFlowScope linkedFlowScope1 = LinkedFlowScope.createEntryLattice(scope0);
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, true);
      LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      FlowScope flowScope0 = linkedFlowScope_FlowScopeJoinOp0.apply((FlowScope) linkedFlowScope0, (FlowScope) linkedFlowScope0);
      typeInference0.flowThrough(node0, flowScope0);
      Node node3 = new Node(31, node2);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node3, linkedFlowScope1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // DELPROP : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      ExploitAssigns exploitAssigns0 = new ExploitAssigns();
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "i%OZL>2@");
      Node node1 = Node.newString("i%OZL>2@", 3375, 55);
      Node node2 = new Node(2, node0, node1, node1, node1);
      Node node3 = new Node(56, 4, 2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      compiler0.getTopScope();
      Scope scope0 = syntacticScopeCreator0.createScope(node2, (Scope) null);
      JSTypeNative jSTypeNative0 = JSTypeNative.SYNTAX_ERROR_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("", jSTypeNative0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Key", codingConvention_AssertionFunctionSpec0, "TightenTypes pass appears to be stuck in an infinite loop.", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      BooleanLiteralSet.get(true);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      typeInference0.analyze(55);
      typeInference0.flowThrough(node3, linkedFlowScope1);
      typeInference0.createInitialEstimateLattice();
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      assertTrue(flowScope0.equals((Object)linkedFlowScope0));
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      ExploitAssigns exploitAssigns0 = new ExploitAssigns();
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "i%OZL>2@");
      Node node1 = Node.newString("i%OZL>2@", (-2609), (-3045));
      Node node2 = new Node(47, node1, node0, node0, node0);
      Node node3 = new Node(57, 36, 43);
      loggerErrorManager0.printSummary();
      boolean boolean0 = false;
      boolean boolean1 = false;
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, boolean0, boolean1);
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      ClosureCodingConvention closureCodingConvention1 = new ClosureCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter1 = new ClosureReverseAbstractInterpreter(closureCodingConvention1, jSTypeRegistry0);
      closureReverseAbstractInterpreter1.getFirst();
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      Scope scope0 = compiler0.getTopScope();
      Scope scope1 = syntacticScopeCreator0.createScope(node2, scope0);
      JSTypeNative jSTypeNative0 = JSTypeNative.BOOLEAN_OBJECT_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(tightenTypes0.NON_HALTING_ERROR_MSG, jSTypeNative0);
      String string0 = "[SdkP?I@tqjSU";
      String string1 = "com.google.javascript.jscomp.AliasStrings";
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(string0, codingConvention_AssertionFunctionSpec0, string1, codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope1, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      typeInference0.branchedFlowThrough(node1, flowScope0);
      typeInference0.flowThrough(node3, flowScope0);
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      ExploitAssigns exploitAssigns0 = new ExploitAssigns();
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "i%OZL>2@");
      Node node1 = new Node(48, node0, node0, node0, node0, 40, 47);
      Node node2 = new Node(36, 4, 2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      compiler0.getTopScope();
      Scope scope0 = syntacticScopeCreator0.createScope(node1, (Scope) null);
      JSTypeNative jSTypeNative0 = JSTypeNative.SYNTAX_ERROR_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("Object#Element");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("i%OZL>2@", codingConvention_AssertionFunctionSpec0, "Object#Element", codingConvention_AssertionFunctionSpec1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      LinkedFlowScope linkedFlowScope1 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      FlowScope flowScope0 = linkedFlowScope_FlowScopeJoinOp0.apply((FlowScope) linkedFlowScope0, (FlowScope) linkedFlowScope0);
      typeInference0.flowThrough(node0, flowScope0);
      Node node3 = new Node(108, node2);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node3, linkedFlowScope1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // IF does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      ExploitAssigns exploitAssigns0 = new ExploitAssigns();
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "i%OZL>2@");
      Node node1 = Node.newString("i%OZL>2@", (-2609), (-3045));
      Node node2 = new Node(3266, node1, node0, node0, node0);
      Node node3 = new Node(57, 36, 43);
      loggerErrorManager0.printSummary();
      boolean boolean0 = false;
      boolean boolean1 = false;
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, boolean0, boolean1);
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      ClosureCodingConvention closureCodingConvention1 = new ClosureCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter1 = new ClosureReverseAbstractInterpreter(closureCodingConvention1, jSTypeRegistry0);
      closureReverseAbstractInterpreter1.getFirst();
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      Scope scope0 = compiler0.getTopScope();
      Scope scope1 = syntacticScopeCreator0.createScope(node2, scope0);
      JSTypeNative jSTypeNative0 = JSTypeNative.BOOLEAN_OBJECT_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(tightenTypes0.NON_HALTING_ERROR_MSG, jSTypeNative0);
      String string0 = "[SdkP?I@tqjSU";
      String string1 = "com.google.javascript.jscomp.AliasStrings";
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of(string0, codingConvention_AssertionFunctionSpec0, string1, codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope1, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      typeInference0.branchedFlowThrough(node1, flowScope0);
      typeInference0.flowThrough(node3, flowScope0);
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      ExploitAssigns exploitAssigns0 = new ExploitAssigns();
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "i%OZL>2@");
      Node node1 = Node.newString("i%OZL>2@", 3375, 55);
      Node node2 = new Node(2, node0, node1, node1, node1);
      Node node3 = new Node(142, 4, 2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      compiler0.getTopScope();
      Scope scope0 = syntacticScopeCreator0.createScope(node2, (Scope) null);
      JSTypeNative jSTypeNative0 = JSTypeNative.SYNTAX_ERROR_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("", jSTypeNative0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("Object#Key", codingConvention_AssertionFunctionSpec0, "TightenTypes pass appears to be stuck in an infinite loop.", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      LinkedFlowScope linkedFlowScope1 = LinkedFlowScope.createEntryLattice(scope0);
      typeInference0.flowThrough(node3, linkedFlowScope1);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      assertFalse(linkedFlowScope2.equals((Object)linkedFlowScope0));
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      ExploitAssigns exploitAssigns0 = new ExploitAssigns();
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "i%OZL>2@");
      Node node1 = new Node(2, node0, node0, node0, node0);
      Node node2 = new Node(36, 4, 2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      compiler0.getTopScope();
      Scope scope0 = syntacticScopeCreator0.createScope(node1, (Scope) null);
      JSTypeNative jSTypeNative0 = JSTypeNative.SYNTAX_ERROR_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("TightenTypes pass appears to be stuck in an infinite loop.");
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      BooleanLiteralSet booleanLiteralSet1 = BooleanLiteralSet.EMPTY;
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter1 = closureReverseAbstractInterpreter0.append(chainableReverseAbstractInterpreter0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter1, scope0, treeMap0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope1);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 2
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      ExploitAssigns exploitAssigns0 = new ExploitAssigns();
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "i%OZL>2@");
      Node node1 = Node.newString("i%OZL>2@", 3375, 55);
      Node node2 = new Node(48, node0, node0, node1, node0, 40, 47);
      Node node3 = new Node(36, 4, 2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      compiler0.getTopScope();
      Scope scope0 = syntacticScopeCreator0.createScope(node2, (Scope) null);
      JSTypeNative jSTypeNative0 = JSTypeNative.SYNTAX_ERROR_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("ub1`Sl!`3C?#1_%");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("i%OZL>2@", codingConvention_AssertionFunctionSpec0, "Object#Element", codingConvention_AssertionFunctionSpec1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;
      LinkedFlowScope.createEntryLattice((Scope) null);
      LinkedFlowScope.createEntryLattice((Scope) null);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeMap0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node2, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 48
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      ExploitAssigns exploitAssigns0 = new ExploitAssigns();
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "i%OZL>2@");
      Node node1 = Node.newString("i%OZL>2@", 3375, 55);
      Node node2 = new Node(2, node0, node1, node1, node1);
      Node node3 = new Node(36, 4, 2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      compiler0.getTopScope();
      Scope scope0 = syntacticScopeCreator0.createScope(node2, (Scope) null);
      JSTypeNative jSTypeNative0 = JSTypeNative.SYNTAX_ERROR_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("ub1`Sl!`3C?#1_%");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("i%OZL>2@", codingConvention_AssertionFunctionSpec0, "Object#Element", codingConvention_AssertionFunctionSpec1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      LinkedFlowScope linkedFlowScope1 = LinkedFlowScope.createEntryLattice((Scope) null);
      typeInference0.flowThrough(node1, linkedFlowScope1);
      typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node3, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 36
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      ExploitAssigns exploitAssigns0 = new ExploitAssigns();
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "i%OZL>2@");
      Node node1 = Node.newString("i%OZL>2@", 155, 55);
      Node node2 = new Node(2, node0, node1, node1, node1);
      Node node3 = new Node(46, 4, 2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node2);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("\"~bU");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("i%OZL>2@", codingConvention_AssertionFunctionSpec0, "Object#Element", codingConvention_AssertionFunctionSpec0, "", codingConvention_AssertionFunctionSpec0, "TightenTypes pass appears to be stuck in an infinite loop.", codingConvention_AssertionFunctionSpec0, "_nT@9D+GrG?RGAvF", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node3, linkedFlowScope0);
      closureReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node0, flowScope0, true);
      closureReverseAbstractInterpreter0.getFirst();
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      compiler0.getTopScope();
      syntacticScopeCreator0.createScope(node2, (Scope) null);
      JSTypeNative jSTypeNative0 = JSTypeNative.SYNTAX_ERROR_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec2 = new CodingConvention.AssertionFunctionSpec("com.google.javascript.jscomp.TypeInference$2");
      // Undeclared exception!
      try { 
        ImmutableSortedMap.of("com.google.javascript.jscomp.TypeInference$2", codingConvention_AssertionFunctionSpec2, "com.google.javascript.jscomp.TypeInference$2", codingConvention_AssertionFunctionSpec1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Multiple entries with same key: com.google.javascript.jscomp.TypeInference$2=com.google.javascript.jscomp.CodingConvention$AssertionFunctionSpec@4b6 and com.google.javascript.jscomp.TypeInference$2=com.google.javascript.jscomp.CodingConvention$AssertionFunctionSpec@4b5
         //
         verifyException("com.google.common.collect.ImmutableMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      ExploitAssigns exploitAssigns0 = new ExploitAssigns();
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "i%OZL>2@");
      Node node1 = Node.newString("i%OZL>2@", 3375, 55);
      Node node2 = new Node(2, node0, node1, node1, node1);
      Node node3 = new Node(118, 4, 2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      compiler0.getTopScope();
      Scope scope0 = syntacticScopeCreator0.createScope(node2, (Scope) null);
      JSTypeNative jSTypeNative0 = JSTypeNative.SYNTAX_ERROR_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("", jSTypeNative0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec2 = new CodingConvention.AssertionFunctionSpec("Object#Element");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("com.google.javascript.jscomp.TypeInference$2", codingConvention_AssertionFunctionSpec0, "TightenTypes pass appears to be stuck in an infinite loop.", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      typeInference0.flowThrough(node3, linkedFlowScope1);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      typeInference0.branchedFlowThrough(node0, flowScope0);
  }

  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      ExploitAssigns exploitAssigns0 = new ExploitAssigns();
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "i%OZL>2@");
      Node node1 = Node.newString("i%OZL>2@", 3375, 55);
      Node node2 = new Node(2, node0, node1, node1, node1);
      Node node3 = new Node(46, 4, 2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      compiler0.getTopScope();
      Scope scope0 = syntacticScopeCreator0.createScope(node2, (Scope) null);
      JSTypeNative jSTypeNative0 = JSTypeNative.SYNTAX_ERROR_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("ub1`Sl!`3C?#1_%");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("i%OZL>2@", codingConvention_AssertionFunctionSpec0, "Object#Element", codingConvention_AssertionFunctionSpec1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      typeInference0.flowThrough(node1, linkedFlowScope1);
      typeInference0.createEntryLattice();
      typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      ExploitAssigns exploitAssigns0 = new ExploitAssigns();
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "i%OZL>2@");
      Node node1 = Node.newString("i%OZL>2@", 3375, 55);
      Node node2 = new Node(2, node0, node1, node1, node1);
      Node node3 = new Node(46, 4, 2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      compiler0.getTopScope();
      Scope scope0 = syntacticScopeCreator0.createScope(node2, (Scope) null);
      JSTypeNative jSTypeNative0 = JSTypeNative.SYNTAX_ERROR_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("ub1`Sl!`3C?#1_%");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("i%OZL>2@", codingConvention_AssertionFunctionSpec0, "Object#Element", codingConvention_AssertionFunctionSpec1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      typeInference0.flowThrough(node1, linkedFlowScope1);
      typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node3, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SHNE 4 : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test32()  throws Throwable  {
      ExploitAssigns exploitAssigns0 = new ExploitAssigns();
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "i%OZL>2@");
      Node node1 = Node.newString("i%OZL>2@", 3375, 55);
      Node node2 = new Node(2, node0, node1, node1, node1);
      Node node3 = new Node(118, 4, 2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      compiler0.getTopScope();
      Scope scope0 = syntacticScopeCreator0.createScope(node2, (Scope) null);
      JSTypeNative jSTypeNative0 = JSTypeNative.SYNTAX_ERROR_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("ub1`Sl`3C?#1_%");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("i%OZL>2@", codingConvention_AssertionFunctionSpec0, "Object#Element", codingConvention_AssertionFunctionSpec1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      codingConvention_AssertionFunctionSpec1.getAssertedType(node3, jSTypeRegistry0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      typeInference0.flowThrough(node1, linkedFlowScope1);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node3, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // VAR 4 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test33()  throws Throwable  {
      ExploitAssigns exploitAssigns0 = new ExploitAssigns();
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "i%OZL>2@");
      Node node1 = Node.newString("i%OZL>2@", 3375, 55);
      Node node2 = new Node(2, node0, node1, node1, node1);
      Node node3 = new Node(100, 4, 2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      compiler0.getTopScope();
      Scope scope0 = syntacticScopeCreator0.createScope(node2, (Scope) null);
      JSTypeNative jSTypeNative0 = JSTypeNative.SYNTAX_ERROR_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("ub1`Sl!`3C?#1_%");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("i%OZL>2@", codingConvention_AssertionFunctionSpec0, "Object#Element", codingConvention_AssertionFunctionSpec1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope.createEntryLattice((Scope) null);
      typeInference0.flowThrough(node2, linkedFlowScope0);
      typeInference0.createEntryLattice();
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 2
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test34()  throws Throwable  {
      ExploitAssigns exploitAssigns0 = new ExploitAssigns();
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "i%OZL>2@");
      Node node1 = Node.newString("i%OZL>2@", 3375, 55);
      Node node2 = new Node(2, node0, node1, node1, node1);
      Node node3 = new Node(100, 4, 2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      compiler0.getTopScope();
      Scope scope0 = syntacticScopeCreator0.createScope(node2, (Scope) null);
      JSTypeNative jSTypeNative0 = JSTypeNative.U2U_FUNCTION_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element", jSTypeNative0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec1 = new CodingConvention.AssertionFunctionSpec("Object#Element");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("", codingConvention_AssertionFunctionSpec1, "ub1`Sl`3C?#1_%", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      typeInference0.flowThrough(node0, linkedFlowScope1);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // STRING i%OZL>2@ 3375 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test35()  throws Throwable  {
      Logger logger0 = Logger.getAnonymousLogger();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Node.newString(0, "t@?s!PGR~T", (-1784), (-1784));
      compiler0.getErrorManager();
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      loggerErrorManager0.getWarnings();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, (JSTypeRegistry) null);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      cleanupPasses0.getTopScope();
      TypeInference typeInference0 = null;
      try {
        typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, (Scope) null, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test36()  throws Throwable  {
      Logger logger0 = Logger.getAnonymousLogger();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Node.newString(0, "t@?s!PGR~T", (-1784), (-1784));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention)compiler0.defaultCodingConvention;
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, (JSTypeRegistry) null);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      cleanupPasses0.getTopScope();
      TypeInference typeInference0 = null;
      try {
        typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, (Scope) null, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.Compiler", e);
      }
  }

  @Test(timeout = 4000)
  public void test37()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, true);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention((CodingConvention) null);
      CodingConventions.Proxy codingConventions_Proxy0 = new CodingConventions.Proxy(googleCodingConvention0);
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null, true);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(codingConventions_Proxy0, jSTypeRegistry0);
      Logger logger0 = Logger.getAnonymousLogger();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      compiler0.getTopScope();
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("t{Hy@I'W");
      ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("Object#Element", codingConvention_AssertionFunctionSpec0, "Object#Key", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = null;
      try {
        typeInference0 = new TypeInference((AbstractCompiler) null, (ControlFlowGraph<Node>) null, semanticReverseAbstractInterpreter0, (Scope) null, immutableMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.DataFlowAnalysis", e);
      }
  }

  @Test(timeout = 4000)
  public void test38()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      // Undeclared exception!
      try { 
        TypeInference.getBooleanOutcomes((BooleanLiteralSet) null, booleanLiteralSet0, false);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test39()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      BooleanLiteralSet booleanLiteralSet1 = BooleanLiteralSet.BOTH;
      TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet1, true);
      BooleanLiteralSet booleanLiteralSet2 = BooleanLiteralSet.EMPTY;
      TypeInference.getBooleanOutcomes(booleanLiteralSet2, booleanLiteralSet0, false);
      Compiler compiler0 = new Compiler();
      ControlFlowGraph<Node> controlFlowGraph0 = null;
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention(jqueryCodingConvention0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      closureReverseAbstractInterpreter0.getFirst();
      TypedScopeCreator typedScopeCreator0 = null;
      try {
        typedScopeCreator0 = new TypedScopeCreator(compiler0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.Compiler", e);
      }
  }

  @Test(timeout = 4000)
  public void test40()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      BooleanLiteralSet booleanLiteralSet1 = BooleanLiteralSet.EMPTY;
      boolean boolean0 = false;
      TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet1, false);
      Logger logger0 = Tracer.logger;
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      ControlFlowGraph<Node> controlFlowGraph0 = null;
      // Undeclared exception!
      try { 
        compiler0.getReverseAbstractInterpreter();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.Compiler", e);
      }
  }

  @Test(timeout = 4000)
  public void test41()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
      assertSame(booleanLiteralSet0, booleanLiteralSet1);
  }
}
