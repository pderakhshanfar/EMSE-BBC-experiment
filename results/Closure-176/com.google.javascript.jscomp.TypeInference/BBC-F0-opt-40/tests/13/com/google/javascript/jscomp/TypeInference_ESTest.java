/*
 * This file was automatically generated by EvoSuite
 * Thu Oct 21 10:32:43 GMT 2021
 */

package com.google.javascript.jscomp;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSortedMap;
import com.google.javascript.jscomp.CodingConvention;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerInput;
import com.google.javascript.jscomp.ControlFlowGraph;
import com.google.javascript.jscomp.GoogleCodingConvention;
import com.google.javascript.jscomp.JqueryCodingConvention;
import com.google.javascript.jscomp.JsAst;
import com.google.javascript.jscomp.LinkedFlowScope;
import com.google.javascript.jscomp.Normalize;
import com.google.javascript.jscomp.PeepholeMinimizeConditions;
import com.google.javascript.jscomp.Scope;
import com.google.javascript.jscomp.SourceFile;
import com.google.javascript.jscomp.StatementFusion;
import com.google.javascript.jscomp.TypeInference;
import com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.FlowScope;
import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.SimpleErrorReporter;
import com.google.javascript.rhino.jstype.BooleanLiteralSet;
import com.google.javascript.rhino.jstype.JSType;
import com.google.javascript.rhino.jstype.JSTypeNative;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import java.util.List;
import java.util.Map;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class TypeInference_ESTest extends TypeInference_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test000()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com-google.javascript.jscompTTypeInference");
      Node node1 = new Node(21, node0, 32, 38);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      Scope scope0 = Scope.createGlobalScope(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test001()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      // Undeclared exception!
      try { 
        TypeInference.getBooleanOutcomes((BooleanLiteralSet) null, booleanLiteralSet0, true);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test002()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      Node node1 = new Node(38, (-651), 4095);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // NAME is not a string node
         //
         verifyException("com.google.javascript.rhino.Node", e);
      }
  }

  @Test(timeout = 4000)
  public void test003()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      Scope scope0 = Scope.createLatticeBottom((Node) null);
      TypeInference typeInference0 = null;
      try {
        typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.Compiler", e);
      }
  }

  @Test(timeout = 4000)
  public void test004()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com-google.javascript.jscompTTypeInference");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createLatticeBottom(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com-google.javascript.jscompTTypeInference");
      ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("", codingConvention_AssertionFunctionSpec0, "jw", codingConvention_AssertionFunctionSpec0, "5G:\"Mt ^c*=O", codingConvention_AssertionFunctionSpec0, "java.lang.Short", codingConvention_AssertionFunctionSpec0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOf((Map<? extends String, ? extends CodingConvention.AssertionFunctionSpec>) immutableMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = node0.removeFirstChild();
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertTrue(flowScope0.equals((Object)linkedFlowScope0));
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test005()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      Node node1 = new Node(101, 1171, 1);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test006()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      Node node1 = Node.newString(4, "com.google.javascript.jscomp.TypeInference", 4909, 1);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      PeepholeMinimizeConditions peepholeMinimizeConditions0 = new PeepholeMinimizeConditions(true);
      Node node2 = StatementFusion.fuseExpressionIntoExpression(node1, node0);
      Node node3 = peepholeMinimizeConditions0.optimizeSubtree(node2);
      FlowScope flowScope0 = typeInference0.flowThrough(node3, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test007()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;
      BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
      assertSame(booleanLiteralSet0, booleanLiteralSet1);
  }

  @Test(timeout = 4000)
  public void test008()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      Normalize.parseAndNormalizeTestCode(compiler0, "");
      Node node0 = Node.newString("");
      Node node1 = new Node(33, node0, 52, 1429);
      Scope scope0 = Scope.createGlobalScope(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // GETPROP 52 : ? does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test009()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com-google.javascript.jscompTTypeInference");
      Node node1 = new Node(30, node0, 32, 38);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      Scope scope0 = Scope.createGlobalScope(node1);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test010()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com-google.javasc;ipt.jscompTTypeInferWnce");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createLatticeBottom(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("mHjrhWR");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("com-google.javasc;ipt.jscompTTypeInferWnce", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(37, node0, node0, node0, (-418), (-1686));
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // CALL does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test011()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("prototype", "prototype", "prototype");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      Node node1 = Node.newString(38, "prototype", 50, (-2294));
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      scope0.declare("prototype", (Node) null, (JSType) null, (CompilerInput) null);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // NAME prototype : ? does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test012()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      Node node1 = Node.newString(38, "com.google.javascript.jscomp.TypeInference", 50, (-2294));
      node1.addChildrenAfter(node0, (Node) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // NAME com.google.javascript.jscomp.TypeInference : ? does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test013()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com-google.javascrip.jscompTTypeInference");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createLatticeBottom(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com-google.javascrip.jscompTTypeInference");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(4, node0, node0, node0, 56, 56);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // RETURN 56 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test014()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com.google.javascript.jscomp.TypeInference");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("roybN~0U4VFM");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("com-google.javascrip.jscompTTypeInference", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = node0.removeFirstChild();
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
      assertTrue(flowScope0.equals((Object)linkedFlowScope0));
  }

  @Test(timeout = 4000)
  public void test015()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(1490, 4, 144);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 1490
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test016()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com-google.javasript.jscompTTyp1Inference");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("RcCd@@I4z");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("", codingConvention_AssertionFunctionSpec0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      Node node1 = Node.newString(155, "", 136, 31);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test017()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com-google.javasript.jscompTTyp1Inference");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("", codingConvention_AssertionFunctionSpec0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      Node node1 = Node.newString(154, ">c'^`q2Yenr&q-$zn.^", (-53), 12);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test018()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      Node node1 = new Node(153, 4095, 153);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LABEL_NAME 4095 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test019()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.javascript.jscomp.TypeInference");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("7/", codingConvention_AssertionFunctionSpec0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      Node node1 = Node.newString(152, "com.google.javascript.jscomp.SyntacticScopeCreator$DefaultRedeclarationHandler", 40, 127);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test020()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com-google.javascript.jscompTTypeInference", "com-google.javascript.jscompTTypeInference", "com-google.javascript.jscompTTypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      Node node1 = new Node(151, (-30), 239);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 151
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test021()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com-google.javascript.jscompTTypeInference", "com-google.javascript.jscompTTypeInference", "com-google.javascript.jscompTTypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Node node1 = new Node(150, (-3433), 31);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 150
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test022()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      Node node1 = Node.newString(149, "qAGY", 15, (-1153));
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // CONST qAGY does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test023()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newString(148, "com.google.javascript.jscomp.TypeInference", 47, 32);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SETTER_DEF com.google.javascript.jscomp.TypeInference 47 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test024()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com-google.javascript.jscompTTypeInference");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createLatticeBottom(node0);
      Node node1 = new Node(147, 2290, 43);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test025()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      Node node1 = new Node(146, 57, 129);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 146
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test026()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      Node node1 = new Node(145, 5, 49);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 145
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test027()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com-google.javascript.jscompTTypeInference", "com-google.javascript.jscompTTypeInference", "com-google.javascript.jscompTTypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Node node1 = new Node(144, 47, (-3389));
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test028()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com-google.javascript.jscompTTypeInference", "com-google.javascript.jscompTTypeInference", "com-google.javascript.jscompTTypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Node node1 = new Node(143, 47, (-3389));
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test029()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      Node node1 = new Node(142, 36, (-487));
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 142
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test030()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      Node node1 = new Node(141, 30, (-2067));
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 141
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test031()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "nj5&QUh");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(140, 1, 52);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test032()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      Node node1 = new Node(139, 24, 1);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test033()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com-google.javascript.jscompTTypeInference");
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com-google.javascript.jscompTTypeInference");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("|R/0#FiVo", codingConvention_AssertionFunctionSpec0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(138, (-5107), 43);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 138
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test034()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(137, 141, 47);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 137
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test035()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.javascript.jscomp.TypeInference");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("", codingConvention_AssertionFunctionSpec0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      Node node1 = Node.newString(136, "com.google.javascript.jscomp.TypeInference", 1, (-1593));
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 136
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test036()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com-google.javascript.jscompTTypeInference");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(135, node0, node0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 135
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test037()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("R){|l($WCE 8h6", "", "nj5&QUh");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(134, (-117), 54);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 134
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test038()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      Node node1 = new Node(133, 57, 104);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 133
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test039()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com-google.javasript.jscompTTyp1Inference", "com-google.javasript.jscompTTyp1Inference", "com-google.javasript.jscompTTyp1Inference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      Node node1 = new Node(131, (-319), 128);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 131
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test040()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(129, 39, 2);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 129
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test041()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(128, 2591, 7);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 128
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test042()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      Node node1 = new Node(127, 30, 87);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test043()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      Node node1 = new Node(126, node0, node0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LABEL does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test044()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com-google.javascript.jscompTTypeInference", "com-google.javascript.jscompTTypeInference", "com-google.javascript.jscompTTypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      Node node1 = new Node(125, 110, 52);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // BLOCK 110 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test045()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(124, 250, 1408);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // EMPTY 250 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test046()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com-google.javascript.jscompTTypeInference", "com-google.javascript.jscompTTypeInference", "com-google.javascript.jscompTTypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Node node1 = new Node(123, 49, 115);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test047()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("Unexpected call site type.", "%>%<9:O", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.javascript.jscomp.TypeInference");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("%>%<9:O", codingConvention_AssertionFunctionSpec0);
      Node node1 = new Node(122, (-1822), 1470);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test048()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(121, 46, 3207);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 121
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test049()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "nj5&QUh");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("nj5&QUh");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("e`F/6_%6i5MOL\"WOz", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = new Node(120, 30, (-1084));
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node1, flowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test050()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "nj5&QUh");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("nj5&QUh");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("e`F/6_%6i5MOL\"WOz", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = new Node(117, 1, (-1921));
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // CONTINUE does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test051()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(116, 42, (-621));
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test052()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "nj5&QUh");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("nj5&QUh");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("e`F/6_%6i5MOL\"WOz", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(115, 31, 115);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test053()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.javascript.jscomp.TypeInference");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("", codingConvention_AssertionFunctionSpec0);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, (JSTypeRegistry) null);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      Node node1 = new Node(114, 172, 33);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test054()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      Node node1 = new Node(113, 52, 4095);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // WHILE 52 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test055()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "nj5&QUh");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      node0.setType(112);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test056()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.[avascript.jscomp.TypeInference", "com.google.[avascript.jscomp.TypeInference", "nj5&QUh");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newString(111, "com.google.[avascript.jscomp.TypeInference", (-32), (-25));
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test057()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com-google.javascrip.jscompTTypeInference");
      Node node1 = new Node(110, node0, 122, 0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test058()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      Node node1 = new Node(109, 30, 87);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test059()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com-google.javascript.jscompTTypeInference");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createLatticeBottom(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com-google.javascript.jscompTTypeInference");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = Node.newString(108, ",LHswR''E`>oQLZU7X", 56, (-1));
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test060()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.[avascript.jscomp.TypeInference", "com.google.[avascript.jscomp.TypeInference", "nj5&QUh");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newString(107, "com.google.[avascript.jscomp.TypeInference", (-32), (-25));
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test061()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("R){|l($WCE 8h6", "", "nj5&QUh");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(106, (-117), 54);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 106
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test062()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("cow-google.jav&script.jscompTTypeInference", "cow-google.jav&script.jscompTTypeInference", "cow-google.jav&script.jscompTTypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(105, 15, (-60));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // FUNCTION <invalid> does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test063()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("R){|l($WCE 8h6", "", "dO&$tuMdN");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(104, (-117), 54);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 104
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test064()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.javascript.jscomp.TypeInference");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("", codingConvention_AssertionFunctionSpec0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(103, (-1627), (-3642));
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // DEC : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test065()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(97, 46, (-335));
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // ASSIGN_MOD : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test066()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(95);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // ASSIGN_MUL : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test067()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(94, 42, (-621));
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test068()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.javascript.jscomp.TypeInference");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("e`F/6%6i5MOL\"WOz", codingConvention_AssertionFunctionSpec0);
      Node node1 = new Node(93, 1, 55);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test069()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("uj5W&QUh", "\"IxpB", "O");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("e`F/6_%6i5MOL\"WOz");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("\"IxpB", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = new Node(91);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test070()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.javascript.jscomp.TypeInference");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("", codingConvention_AssertionFunctionSpec0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(90, 47, 4713);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test071()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(88);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // ASSIGN_BITXOR : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test072()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      Node node1 = Node.newString(4, "com.google.javascript.jscomp.TypeInference", 4890, 151);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = StatementFusion.fuseExpressionIntoExpression(node1, node0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // COMMA 1 [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000000987] : ? does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test073()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.[avascript.jscomp.TypeInference", "com.google.[avascript.jscomp.TypeInference", "nj5&QUh");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
      JSType[] jSTypeArray0 = new JSType[0];
      Node node1 = jSTypeRegistry0.createParametersWithVarArgs(jSTypeArray0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void test074()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(82);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 82
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test075()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(81);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 81
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test076()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      JSTypeNative jSTypeNative0 = JSTypeNative.OBJECT_NUMBER_STRING;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("W*= }", jSTypeNative0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(78, 638, 12);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 78
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test077()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.javascript.jscomp.TypeInference");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("", codingConvention_AssertionFunctionSpec0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(77, node0, node0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // TRY does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test078()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com-google.javascript.jscompTTyeInference", "com-google.javascript.jscompTTyeInference", "com-google.javascript.jscompTTyeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(76, 51, (-477));
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test079()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("R){|l($WCE 8h6", "", "dO&$tuMdN");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(74, 48, 30);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 74
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test080()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com.google.javascript.jscomp.TypeInference");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.javascript.jscomp.TypeInference");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("com-google.javascrip.jscompTTypeInference", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = Node.newString(73, "com-google.javascrip.jscompTTypeInference", 48, 2093);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 73
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test081()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("I2g", "I2g", "I2g");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("I2g");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("I2g", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(70, 70, 12);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 70
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test082()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "nj5&QUh");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("nj5&QUh");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("e`F/6_%6i5MOL\"WOz", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = Node.newString(68, "nj5&QUh", 117, (-1682));
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test083()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.javascript.jscomp.TypeInference");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("", codingConvention_AssertionFunctionSpec0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Node node1 = Node.newString(66, "j", 66, 2071);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test084()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("I2g", "I2g", "I2g");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("I2g");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("I2g", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(64, 64, 12);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test085()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("com-google.javascrip.jscompTTypeInference", "com-google.javascrip.jscompTTypeInference");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(60, 57, (-5363));
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 60
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test086()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com-google.javascript.jscompTTypeInference");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createLatticeBottom(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com-google.javascript.jscompTTypeInference");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(59, (-3383), (-699));
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 59
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test087()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com-google.javascript.jscompTTypeInference");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createLatticeBottom(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com-google.javascript.jscompTTypeInference");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(58, (-3383), (-699));
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 58
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test088()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "nj5&QUh");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("nj5&QUh");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("e`F/6_%6i5MOL\"WOz", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(57, node0, node0, node0, node0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test089()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      Node node1 = new Node(56);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test090()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("\"IxpB", "\"IxpB", "O");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      node0.setType(55);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 55
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test091()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      Node node1 = new Node(54, 30, 87);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test092()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("uj5W&QUh", "\"IxpB", "O");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("e`F/6_%6i5MOL\"WOz");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("\"IxpB", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = new Node(53, 1, (-739));
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 53
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test093()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "nj5&QUh");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("nj5&QUh");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("e`F/6_%6i5MOL\"WOz", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(52, 2, 31);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test094()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "nj5&QUh");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(51, 1, 52);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test095()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("\"IxpB", "\"IxpB", "O");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope((Node) null);
      Scope scope1 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope1, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      Node node1 = new Node(50, (-1876), 12);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 50
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test096()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(49, 4, 16);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // THROW 4 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test097()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      Node node1 = new Node(48, 12, (-2034));
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test098()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "nj5&QUh");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("nj5&QUh");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("e`F/6_%6i5MOL\"WOz", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(47, 4, (-1697));
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test099()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      Node node1 = new Node(46, 2, 148);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SHNE 2 : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test100()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascriptjscomp.TypeZnference", "com.google.javascriptjscomp.TypeZnference", "com.google.javascriptjscomp.TypeZnference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("|rQ");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("?>WRvf<!|u=pr", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = new Node(44, 50, 899);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // TRUE 50 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test101()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("_9", "_9", "_9");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(43, 150, 47);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // FALSE 150 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test102()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com-google.javascript.jscompTTypeInference");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createLatticeBottom(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com-google.javascript.jscompTTypeInference");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(42, 1063, (-699));
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // THIS does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test103()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com-google.javascript.jscompTTypeIference");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      Node node1 = new Node(41, 52, 37);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test104()  throws Throwable  {
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>((Node) null, true, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "nj5&QUh");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("nj5&QUh");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("e`F/6_%6i5MOL\"WOz", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newNumber((double) 40, 114, 137);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // NUMBER 40.0 114 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test105()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      Node node1 = new Node(37, 116, 2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, true, true);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      // Undeclared exception!
      try { 
        typeInference0.analyze();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test106()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("RT9", "com.google.javscript.jscomp.TypeInference");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.javscript.jscomp.TypeInference");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("RT9", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(27, 83, (-2875));
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // BITNOT : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test107()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com-google.javascript.jscompTTyeInference", "com-google.javascript.jscompTTyeInference", "com-google.javascript.jscompTTyeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = node0.removeFirstChild();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // EXPR_RESULT 1 [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000000614] does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test108()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com.google.javascript.jscomp.TypeInference");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("com-google.javascrip.jscompTTypeInference", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newString(21, "=_", 202, 37);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test109()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com-google.javascript.jscompTTypeInference");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      Node node1 = new Node(19, 52, 37);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test110()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com-google.javascript.jscompTTypeInference");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node0);
      Node node1 = new Node(17, 52, 37);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test111()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com-google.javascript.jscompTTypeInference");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com-google.javascript.jscompTTypeInference");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("com-google.javascript.jscompTTypeInference", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node1 = Node.newString(13, "Object#Element", 135, 33);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test112()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com-google.javascript.jscompTTypeInference", "com-google.javascript.jscompTTypeInference", "com-google.javascript.jscompTTypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      Node node1 = new Node(12, 100, 1);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, true, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test113()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com-google.javascript.jscompTTypeInference");
      Node node1 = new Node(5, node0, 32, 38);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      Scope scope0 = Scope.createLatticeBottom(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com-google.javascript.jscompTTypeInference");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test114()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com-google.javascript.jscompTTypeInference");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.UNCOND;
      controlFlowGraph0.connect(node0, controlFlowGraph_Branch0, (Node) null);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void test115()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com-google.javasc;ipt.jscompTTypeInferWnce");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_FALSE;
      controlFlowGraph0.connect(node0, controlFlowGraph_Branch0, node0);
      Scope scope0 = Scope.createGlobalScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SCRIPT 1 [synthetic: com.google.javascript.rhino.Node$IntPropListItem@0000000637] [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000000638] [input_id: com.google.javascript.rhino.Node$ObjectPropListItem@0000000639] does not have a condition.
         //
         verifyException("com.google.javascript.jscomp.NodeUtil", e);
      }
  }

  @Test(timeout = 4000)
  public void test116()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com-google.javascript.jscompTTypeInference", "com-google.javascript.jscompTTypeInference", "com-google.javascript.jscompTTypeInference");
      JsAst jsAst0 = new JsAst(sourceFile0);
      Node node0 = jsAst0.getAstRoot(compiler0);
      Scope scope0 = Scope.createGlobalScope(node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test117()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com-google.javascript.jscompTTypeInference");
      Node node1 = new Node(30, node0, 32, 38);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createGlobalScope(node1);
      Scope scope1 = new Scope(scope0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope1, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
  }
}
