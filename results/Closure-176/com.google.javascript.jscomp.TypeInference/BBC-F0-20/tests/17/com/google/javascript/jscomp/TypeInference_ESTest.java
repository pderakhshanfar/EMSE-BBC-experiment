/*
 * This file was automatically generated by EvoSuite
 * Fri Mar 05 21:49:46 GMT 2021
 */

package com.google.javascript.jscomp;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSortedMap;
import com.google.javascript.jscomp.CleanupPasses;
import com.google.javascript.jscomp.ClosureCodingConvention;
import com.google.javascript.jscomp.CodingConvention;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerOptions;
import com.google.javascript.jscomp.ControlFlowAnalysis;
import com.google.javascript.jscomp.ControlFlowGraph;
import com.google.javascript.jscomp.GoogleCodingConvention;
import com.google.javascript.jscomp.JqueryCodingConvention;
import com.google.javascript.jscomp.LinkedFlowScope;
import com.google.javascript.jscomp.MessageFormatter;
import com.google.javascript.jscomp.Normalize;
import com.google.javascript.jscomp.PeepholeFoldConstants;
import com.google.javascript.jscomp.PeepholeFoldWithTypes;
import com.google.javascript.jscomp.PeepholeMinimizeConditions;
import com.google.javascript.jscomp.PeepholeRemoveDeadCode;
import com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax;
import com.google.javascript.jscomp.PrintStreamErrorManager;
import com.google.javascript.jscomp.Scope;
import com.google.javascript.jscomp.SourceFile;
import com.google.javascript.jscomp.TightenTypes;
import com.google.javascript.jscomp.TypeInference;
import com.google.javascript.jscomp.TypedScopeCreator;
import com.google.javascript.jscomp.graph.GraphNode;
import com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.FlowScope;
import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.SimpleErrorReporter;
import com.google.javascript.rhino.jstype.BooleanLiteralSet;
import com.google.javascript.rhino.jstype.JSType;
import com.google.javascript.rhino.jstype.JSTypeNative;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import com.google.javascript.rhino.jstype.ModificationVisitor;
import java.io.File;
import java.io.PrintStream;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.NavigableMap;
import java.util.SortedMap;
import java.util.TreeMap;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.System;
import org.evosuite.runtime.mock.java.io.MockFile;
import org.evosuite.runtime.mock.java.io.MockFileOutputStream;
import org.evosuite.runtime.mock.java.io.MockPrintStream;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class TypeInference_ESTest extends TypeInference_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test000()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("DDj42");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("DDj42", "DDj42");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = null;
      Scope scope0 = Scope.createGlobalScope(node0);
      Compiler compiler1 = new Compiler();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = new Node(63, node0, 32, 55);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // ARRAYLIT 32 : Array does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test001()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("DD942");
      MockPrintStream mockPrintStream0 = new MockPrintStream("DD942");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("DD942", "DD942");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      Scope scope0 = Scope.createLatticeBottom(node0);
      Compiler compiler1 = new Compiler();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      PeepholeFoldConstants peepholeFoldConstants0 = new PeepholeFoldConstants(false);
      LinkedFlowScope linkedFlowScope2 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(80, node0, 37, 2);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope2);
      assertNotSame(flowScope0, linkedFlowScope2);
  }

  @Test(timeout = 4000)
  public void test002()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      PeepholeFoldConstants peepholeFoldConstants0 = new PeepholeFoldConstants(false);
      Node node1 = peepholeFoldConstants0.optimizeSubtree(node0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      jqueryCodingConvention0.identifyTypeDeclarationCall(node0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      treeMap0.headMap("", false);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope3 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope4 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope5 = new LinkedFlowScope(linkedFlowScope3);
      linkedFlowScope5.getSlot("^`y,KT;*4/9_a8 P");
      LinkedFlowScope linkedFlowScope6 = new LinkedFlowScope(linkedFlowScope5);
      Node node2 = new Node(133, node0, 1330, 216);
      typeInference0.branchedFlowThrough(node0, linkedFlowScope3);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope4);
      assertNotSame(flowScope0, linkedFlowScope4);
  }

  @Test(timeout = 4000)
  public void test003()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("Ed95");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = null;
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
      FlowScope flowScope0 = closureReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node0, linkedFlowScope0, false);
      typeInference0.join(flowScope0, flowScope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = new Node(149, node0, 8388608, (-2021));
      FlowScope flowScope1 = linkedFlowScope2.createChildFlowScope();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // CONST does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test004()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("DD942");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("DD942", "DD942");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
      Scope scope1 = typedScopeCreator0.createInitialScope(node0);
      scope1.getArgumentsVar();
      JqueryCodingConvention jqueryCodingConvention1 = new JqueryCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention1, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, treeMap0);
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("DD942");
      FileSystemHandling.createFolder(evoSuiteFile0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      closureReverseAbstractInterpreter0.append(chainableReverseAbstractInterpreter0);
      scope0.getArgumentsVar();
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      ArrayList<GraphNode<Node, ControlFlowGraph.Branch>> arrayList0 = new ArrayList<GraphNode<Node, ControlFlowGraph.Branch>>();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(101, node0, 30, 52);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: StackOverflowError");
      
      } catch(StackOverflowError e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void test005()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("DD942");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("DD942", "DD942");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
      Scope scope1 = typedScopeCreator0.createInitialScope(node0);
      scope1.getArgumentsVar();
      JqueryCodingConvention jqueryCodingConvention1 = new JqueryCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention1, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, treeMap0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      closureReverseAbstractInterpreter0.append(chainableReverseAbstractInterpreter0);
      scope0.getArgumentsVar();
      ArrayList<GraphNode<Node, ControlFlowGraph.Branch>> arrayList0 = new ArrayList<GraphNode<Node, ControlFlowGraph.Branch>>();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(101, node0, 30, 52);
      typeInference0.createEntryLattice();
      // Undeclared exception!
      typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test006()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("DD942");
      MockPrintStream mockPrintStream0 = new MockPrintStream("DD942");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("DD942", "DD942");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = null;
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      Scope scope0 = Scope.createLatticeBottom(node0);
      Compiler compiler1 = new Compiler();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = new Node(97, node0, 53, 104);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // ASSIGN_MOD 53 : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test007()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("com.google.javascript.jscomp.TypeInference$2");
      mockFileOutputStream0.flush();
      mockFileOutputStream0.write(100);
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("com.google.javascript.jscomp.TypeInference$2", "com.google.javascript.jscomp.TypeInference$2");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createLatticeBottom(node0);
      Compiler compiler1 = new Compiler();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_FALSE;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      typeInference0.createInitialEstimateLattice();
      LinkedFlowScope linkedFlowScope2 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(154, node0, 0, 2759);
      typeInference0.flowThrough(node1, linkedFlowScope2);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SCRIPT 1 [synthetic: com.google.javascript.rhino.Node$IntPropListItem@0000000637] [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000000638] [input_id: com.google.javascript.rhino.Node$ObjectPropListItem@0000000639] does not have a condition.
         //
         verifyException("com.google.javascript.jscomp.NodeUtil", e);
      }
  }

  @Test(timeout = 4000)
  public void test008()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("EOdd95");
      MockPrintStream mockPrintStream0 = new MockPrintStream("EOdd95");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("EOdd95", "EOdd95");
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = null;
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(117, node0, 2, 57);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // CONTINUE 2 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test009()  throws Throwable  {
      String string0 = "Td95e";
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOf((Map<? extends String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      Node node1 = new Node(152, node0, 47, 31);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // DEBUGGER 47 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test010()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("DD942");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("DD942", "DD942");
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      ControlFlowGraph<Node> controlFlowGraph1 = typeInference0.getCfg();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph1, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(123, node0, 54, 48);
      JSTypeNative jSTypeNative0 = JSTypeNative.BOOLEAN_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("DD942", jSTypeNative0);
      ControlFlowAnalysis.computeFollowNode(node1);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(linkedFlowScope0, flowScope0);
  }

  @Test(timeout = 4000)
  public void test011()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("DDj42");
      MockPrintStream mockPrintStream0 = new MockPrintStream("DDj42");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("DDj42", "DDj42");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = null;
      Scope scope0 = Scope.createGlobalScope(node0);
      Compiler compiler1 = new Compiler();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(70, node0, 32, 55);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 70
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test012()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("m9e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("m9e", "m9e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      compiler0.getOptions();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      Node node1 = new Node(123, node0, 57, 121);
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = linkedFlowScope_FlowScopeJoinOp0.apply((FlowScope) linkedFlowScope0, (FlowScope) linkedFlowScope0);
      FlowScope flowScope1 = typeInference0.flowThrough(node0, flowScope0);
      typeInference0.branchedFlowThrough(node0, flowScope1);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 123
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test013()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("Td95e");
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createLatticeBottom(node0);
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      Node node1 = new Node(25, node0, 1352, (-1986));
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      linkedFlowScope0.createChildFlowScope();
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
      
      typeInference0.createEntryLattice();
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      BooleanLiteralSet booleanLiteralSet1 = BooleanLiteralSet.TRUE;
      BooleanLiteralSet booleanLiteralSet2 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet1, false);
      assertEquals(BooleanLiteralSet.TRUE, booleanLiteralSet2);
  }

  @Test(timeout = 4000)
  public void test014()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("EOdd95");
      MockPrintStream mockPrintStream0 = new MockPrintStream("EOdd95");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("EOdd95", "EOdd95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compilerOptions0.prettyPrint = false;
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, false);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      Node node1 = new Node(90, node0, 2867, 50);
      typeInference0.flowThrough(node1, linkedFlowScope0);
      // Undeclared exception!
      try { 
        linkedFlowScope0.completeScope(flowScope0);
        fail("Expecting exception: ClassCastException");
      
      } catch(ClassCastException e) {
         //
         // com.google.javascript.jscomp.LinkedFlowScope cannot be cast to com.google.javascript.jscomp.Scope
         //
         verifyException("com.google.javascript.jscomp.LinkedFlowScope", e);
      }
  }

  @Test(timeout = 4000)
  public void test015()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("DD942");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("DD942", "DD942");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph2 = new ControlFlowGraph<Node>(node0, false, false);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph2, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(68, node0, 42, 57);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 68
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test016()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createLatticeBottom(node0);
      compiler0.getOptions();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(75, node0, 37, 32);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      closureReverseAbstractInterpreter0.append(semanticReverseAbstractInterpreter0);
      typeInference0.flowThrough(node1, linkedFlowScope1);
      Node node2 = null;
      try {
        node2 = new Node(31, node0, 2, 56);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // new child has existing parent
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test017()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("DD942");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("DD942", "DD942");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph2 = new ControlFlowGraph<Node>(node0, false, false);
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0, true);
      JSType jSType0 = modificationVisitor0.caseAllType();
      node0.setJSType(jSType0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph2, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      Node node1 = new Node(4, node0, 147, 51);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(linkedFlowScope0, flowScope0);
  }

  @Test(timeout = 4000)
  public void test018()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createLatticeBottom(node0);
      compiler0.getOptions();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      FileSystemHandling.shouldAllThrowIOExceptions();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(121, node0, 4095, 32);
      LinkedFlowScope linkedFlowScope2 = LinkedFlowScope.createEntryLattice(scope0);
      typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      Node node2 = new Node((-1682), node1, 108, 440);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope2);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 121
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test019()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("com.google.javascript.jscomp.TypeInference$2");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("com.google.javascript.jscomp.TypeInference$2", "com.google.javascript.jscomp.TypeInference$2");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      Scope scope0 = Scope.createLatticeBottom(node0);
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      FlowScope flowScope0 = linkedFlowScope0.createChildFlowScope();
      Node node1 = new Node(110, node0, (-921210296), 127);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SWITCH does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test020()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("DD942");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("DD942", "DD942");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph2 = new ControlFlowGraph<Node>(node0, false, false);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph2, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(67, node0, 42, 57);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 67
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test021()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap1);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      treeMap0.headMap("", true);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope.createEntryLattice((Scope) null);
      LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope3 = LinkedFlowScope.createEntryLattice((Scope) null);
      LinkedFlowScope linkedFlowScope4 = new LinkedFlowScope(linkedFlowScope3);
      LinkedFlowScope linkedFlowScope5 = LinkedFlowScope.createEntryLattice((Scope) null);
      typeInference0.flowThrough(node0, linkedFlowScope5);
      Node node1 = new Node(154, node0, 50, 4594);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope5);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // STRING_KEY 50 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test022()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      compiler0.getOptions();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_EX;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      Node node1 = new Node(114, node0, 524288, 4095);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      typeInference0.flowThrough(node1, flowScope0);
      PeepholeRemoveDeadCode peepholeRemoveDeadCode0 = new PeepholeRemoveDeadCode();
      // Undeclared exception!
      try { 
        peepholeRemoveDeadCode0.tryFoldFor(node1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test023()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      SimpleErrorReporter simpleErrorReporter1 = new SimpleErrorReporter();
      Scope scope1 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope1, treeMap1);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope1);
      Node node1 = new Node(26, node0, 47, 52);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      FlowScope flowScope1 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(linkedFlowScope0, flowScope0);
      assertNotSame(flowScope1, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test024()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      mockFileOutputStream0.flush();
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("HRh-iJ2VTDLCK#.*h>", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(126, node0, 3, 2528);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LABEL 3 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test025()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("DD942");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("DD942", "DD942");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph2 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope.createEntryLattice(scope0);
      typeInference0.flowThrough(node0, linkedFlowScope1);
      Node node1 = new Node(24, node0, 1693, (-609));
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(linkedFlowScope0, flowScope0);
  }

  @Test(timeout = 4000)
  public void test026()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("DD942");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("DD942", "DD942");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph2 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope.createEntryLattice(scope0);
      typeInference0.flowThrough(node0, linkedFlowScope1);
      Node node1 = new Node(95, node0, 2150, 134);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // ASSIGN_MUL 2150 : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test027()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("Td395e", "Td395e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      FileSystemHandling.shouldAllThrowIOExceptions();
      Node node1 = new Node(105, node0, 193, (-1999));
      LinkedList<FlowScope> linkedList0 = new LinkedList<FlowScope>();
      typeInference0.createEntryLattice();
      typeInference0.createEntryLattice();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node1, linkedFlowScope1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // FUNCTION <invalid> does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test028()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, (byte[]) null);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0, false);
      JSType jSType0 = modificationVisitor0.caseAllType();
      node0.setJSType(jSType0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      Node node1 = new Node(30, node0, 2680, 136);
      typeInference0.flowThrough(node1, linkedFlowScope0);
      System.setCurrentTimeMillis((-1795L));
  }

  @Test(timeout = 4000)
  public void test029()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("DD942");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("DD942", "DD942");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph2 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      Scope scope1 = Scope.createGlobalScope(node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope1);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = new Node(46, node0, 39, 43);
      typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope1);
      assertNotSame(flowScope0, linkedFlowScope1);
  }

  @Test(timeout = 4000)
  public void test030()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("dm95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("dm95e", "dm95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      compiler0.getOptions();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = LinkedFlowScope.createEntryLattice(scope0);
      typeInference0.flowThrough(node0, linkedFlowScope1);
      Node node1 = new Node(129, node0, 108, 38);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test031()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("DD942");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("DD942", "DD942");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph2 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      Node node1 = new Node((-63), node0, 130, 56);
      LinkedFlowScope linkedFlowScope3 = new LinkedFlowScope(linkedFlowScope1);
      PeepholeFoldConstants peepholeFoldConstants0 = new PeepholeFoldConstants(true);
      Node node2 = new Node(9, node1, 134, (-3624));
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope1);
      assertNotSame(flowScope0, linkedFlowScope1);
  }

  @Test(timeout = 4000)
  public void test032()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("DD942");
      MockPrintStream mockPrintStream0 = new MockPrintStream("DD942");
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("DD942", "DD942");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      compiler0.newCompilerOptions();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = new Node(27, node0, 1, 38);
      typeInference0.flowThrough(node1, linkedFlowScope0);
      Node node2 = new Node((-26), node1, 40, 1152);
      LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope1);
      assertNotSame(linkedFlowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test033()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("DD942");
      MockPrintStream mockPrintStream0 = new MockPrintStream("DD942");
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("DD942", "DD942");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      compiler0.newCompilerOptions();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = new Node(27, node0, 1, 38);
      LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // BITNOT 1 : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test034()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Tdb5e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      PeepholeMinimizeConditions peepholeMinimizeConditions0 = new PeepholeMinimizeConditions(false);
      Node node0 = Node.newString("", 116, 116);
      Node node1 = compiler0.parseTestCode("Tdb5e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
      Scope scope0 = Scope.createLatticeBottom(node1);
      compiler0.getOptions();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(2102, node0, 2013, 85);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.append(semanticReverseAbstractInterpreter0);
      typeInference0.flowThrough(node2, linkedFlowScope0);
      Node node3 = new Node(151, node1, 46, 53);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOfSorted((SortedMap<String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      typeInference1.flowThrough(node3, linkedFlowScope0);
      typeInference0.flowThrough(node3, linkedFlowScope1);
      BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, true);
      assertEquals(BooleanLiteralSet.EMPTY, booleanLiteralSet1);
  }

  @Test(timeout = 4000)
  public void test035()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_FALSE;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope1 = LinkedFlowScope.createEntryLattice(scope0);
      typeInference0.createInitialEstimateLattice();
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope3 = new LinkedFlowScope(linkedFlowScope1);
      Node node1 = new Node(130, node0, 12, 1498);
      typeInference0.flowThrough(node1, linkedFlowScope3);
      PeepholeFoldConstants peepholeFoldConstants0 = new PeepholeFoldConstants(false);
      LinkedFlowScope linkedFlowScope4 = new LinkedFlowScope(linkedFlowScope0);
      Node node2 = new Node(148, node1, 2, 42);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(linkedFlowScope0, flowScope0);
  }

  @Test(timeout = 4000)
  public void test036()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_EX;
      mockFileOutputStream0.release();
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      Node node1 = new Node(150, node0, 53, 138);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 150
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test037()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_FALSE;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(140, node0, (-281), 143);
      JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("K/6r=!9HD#X<", jSTypeNative0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      ControlFlowAnalysis.computeFollowNode(node1);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(linkedFlowScope0, flowScope0);
  }

  @Test(timeout = 4000)
  public void test038()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_EX;
      mockFileOutputStream0.release();
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope.createEntryLattice(scope0);
      typeInference0.flowThrough(node0, linkedFlowScope0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      Node node1 = new Node(150, node0, 53, 138);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 150
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test039()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      NavigableMap<String, CodingConvention.AssertionFunctionSpec> navigableMap0 = treeMap0.headMap("Td95e", false);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      Node node1 = new Node(66, node0, 36, 400000);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("");
      treeMap0.put("Ot!", codingConvention_AssertionFunctionSpec0);
      LinkedFlowScope.createEntryLattice(scope0);
      typeInference0.branchedFlowThrough(node0, linkedFlowScope1);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, navigableMap0);
      typeInference1.flowThrough(node1, linkedFlowScope2);
      System.setCurrentTimeMillis(4095);
      FlowScope flowScope1 = typeInference0.createInitialEstimateLattice();
      assertFalse(flowScope1.equals((Object)flowScope0));
  }

  @Test(timeout = 4000)
  public void test040()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("75");
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("75", "75");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      typeInference0.flowThrough(node0, linkedFlowScope1);
      FileSystemHandling.shouldAllThrowIOExceptions();
      Node node1 = new Node(128, node0, 31, 2767);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope1);
      assertNotSame(linkedFlowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test041()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("DD942");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("DD942", "DD942");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, true);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
      Scope scope1 = typedScopeCreator0.createInitialScope(node0);
      scope1.getArgumentsVar();
      JqueryCodingConvention jqueryCodingConvention1 = new JqueryCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention1, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, treeMap0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      closureReverseAbstractInterpreter0.append(chainableReverseAbstractInterpreter0);
      scope0.getArgumentsVar();
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      ArrayList<GraphNode<Node, ControlFlowGraph.Branch>> arrayList0 = new ArrayList<GraphNode<Node, ControlFlowGraph.Branch>>();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(101, node0, 30, 52);
      // Undeclared exception!
      typeInference0.flowThrough(node1, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test042()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createGlobalScope(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler1 = new Compiler();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      Scope.createGlobalScope(node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      LinkedFlowScope linkedFlowScope3 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = new Node(102, node0, 37, 0);
      node1.getJsDocBuilderForNode();
      typeInference0.flowThrough(node1, linkedFlowScope1);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // INC 37 : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test043()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td395e");
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("Td395e", "Td395e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      Node node1 = new Node(109, node0, 193, (-1984));
      typeInference0.branchedFlowThrough(node0, flowScope0);
      FlowScope flowScope1 = linkedFlowScope0.createChildFlowScope();
      typeInference0.flowThrough(node1, flowScope1);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      typeInference0.createEntryLattice();
      LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      typeInference1.join(linkedFlowScope1, flowScope0);
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node1, linkedFlowScope1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 109
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test044()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("DD942");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("DD942", "DD942");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
      Scope scope1 = typedScopeCreator0.createInitialScope(node0);
      scope1.getArgumentsVar();
      JqueryCodingConvention jqueryCodingConvention1 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter1 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter1);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope1, treeMap0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      scope0.getArgumentsVar();
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      ArrayList<GraphNode<Node, ControlFlowGraph.Branch>> arrayList0 = new ArrayList<GraphNode<Node, ControlFlowGraph.Branch>>();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope1);
      Node node1 = new Node(131, node0, 101, 16);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      FlowScope flowScope1 = typeInference0.createInitialEstimateLattice();
      assertFalse(flowScope1.equals((Object)flowScope0));
  }

  @Test(timeout = 4000)
  public void test045()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Ed95");
      MockPrintStream mockPrintStream0 = new MockPrintStream("Ed95");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      controlFlowGraph0.newSubGraph();
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, false);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph1, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager((MessageFormatter) null, mockPrintStream0);
      Compiler compiler1 = new Compiler(printStreamErrorManager0);
      TightenTypes tightenTypes0 = new TightenTypes(compiler1);
      Node node1 = new Node(135, node0, 3253, 119);
      FlowScope flowScope0 = typeInference1.createEntryLattice();
      typeInference1.branchedFlowThrough(node0, flowScope0);
      typeInference1.createEntryLattice();
      FlowScope flowScope1 = typeInference0.createEntryLattice();
      FlowScope flowScope2 = typeInference0.flowThrough(node1, flowScope1);
      assertNotSame(flowScope2, flowScope1);
      
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;
      TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
      BooleanLiteralSet booleanLiteralSet1 = BooleanLiteralSet.FALSE;
      BooleanLiteralSet booleanLiteralSet2 = BooleanLiteralSet.TRUE;
      BooleanLiteralSet booleanLiteralSet3 = TypeInference.getBooleanOutcomes(booleanLiteralSet1, booleanLiteralSet2, false);
      assertEquals(BooleanLiteralSet.TRUE, booleanLiteralSet3);
  }

  @Test(timeout = 4000)
  public void test046()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td395e");
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("Td395e", "Td395e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      typeInference0.flowThrough(node0, linkedFlowScope0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      scope0.getArgumentsVar();
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      ArrayList<GraphNode<Node, ControlFlowGraph.Branch>> arrayList0 = new ArrayList<GraphNode<Node, ControlFlowGraph.Branch>>();
      LinkedFlowScope linkedFlowScope1 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(127, node0, (-1), 1);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope1);
      assertNotSame(linkedFlowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test047()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Node node1 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      Scope scope0 = Scope.createLatticeBottom(node1);
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      Node node2 = new Node(51, node0, 4095, 15);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      FlowScope flowScope0 = typeInference1.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test048()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("EOdd95");
      MockPrintStream mockPrintStream0 = new MockPrintStream("EOdd95");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("EOdd95", "EOdd95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, false);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = new Node(143, node0, 47, 113);
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test049()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("Ed95");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope3 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope4 = new LinkedFlowScope(linkedFlowScope2);
      typeInference0.flowThrough(node0, linkedFlowScope4);
      Node node1 = new Node(124, node0, 26, 1873);
      typeInference0.flowThrough(node1, linkedFlowScope3);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope3);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // EMPTY 26 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test050()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Ed95");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_TRUE;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      TightenTypes tightenTypes0 = new TightenTypes(compiler1);
      Node node1 = new Node(13);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // NE : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test051()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      treeMap0.headMap("Td95e", false);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope.createEntryLattice(scope0);
      typeInference0.flowThrough(node0, linkedFlowScope0);
      Node node1 = new Node(77, node0, 36, 400000);
      LinkedFlowScope.createEntryLattice((Scope) null);
      Node node2 = new Node(47, node1, 47, 61);
      typeInference0.flowThrough(node1, linkedFlowScope0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
      assertEquals(BooleanLiteralSet.BOTH, booleanLiteralSet1);
  }

  @Test(timeout = 4000)
  public void test052()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("DD942");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("DD942", "DD942");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph2 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      Scope scope1 = Scope.createGlobalScope(node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope1);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = new Node(118, node0, 39, 43);
      typeInference0.flowThrough(node1, linkedFlowScope0);
      typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope1);
      assertNotSame(flowScope0, linkedFlowScope1);
  }

  @Test(timeout = 4000)
  public void test053()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_EX;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(15, node0, (-18), 32);
      node1.toString(true, false, true);
      Node node2 = new Node(41, node1, 83, 4095);
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      Scope.createGlobalScope(node2);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter1 = closureReverseAbstractInterpreter0.append(chainableReverseAbstractInterpreter0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Key");
      ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("", codingConvention_AssertionFunctionSpec0, "Td95e", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter1, scope0, immutableMap0);
      typeInference0.flowThrough(node2, linkedFlowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LE : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test054()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("DD942");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("DD942", "DD942");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = null;
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      Scope scope0 = Scope.createLatticeBottom(node0);
      Compiler compiler1 = new Compiler();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_TRUE;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference1.createInitialEstimateLattice();
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      typeInference0.flowThrough(node0, flowScope0);
      Node node1 = new Node(77, node0, 119, 55);
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // TRY 119 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test055()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("DD942");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("DD942", "DD942");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
      Scope scope1 = typedScopeCreator0.createInitialScope(node0);
      scope1.getArgumentsVar();
      JqueryCodingConvention jqueryCodingConvention1 = new JqueryCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention1, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, treeMap0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      scope0.getArgumentsVar();
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      ArrayList<GraphNode<Node, ControlFlowGraph.Branch>> arrayList0 = new ArrayList<GraphNode<Node, ControlFlowGraph.Branch>>();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(101, node0, 30, 52);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test056()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td395e");
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("Td395e", "Td395e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      Node node1 = new Node(109, node0, 193, (-1984));
      typeInference0.branchedFlowThrough(node0, flowScope0);
      FlowScope flowScope1 = typeInference0.createEntryLattice();
      typeInference0.createEntryLattice();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node1, flowScope1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 109
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test057()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, true);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_TRUE;
      controlFlowGraph1.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      TightenTypes tightenTypes0 = new TightenTypes(compiler1);
      Node node1 = new Node(107, node0, 126, 36);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 107
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test058()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Ed95");
      MockPrintStream mockPrintStream0 = new MockPrintStream("Ed95");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      controlFlowGraph0.newSubGraph();
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, true);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(138, node0, (-3620), 4095);
      typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 138
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test059()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Ed95");
      MockPrintStream mockPrintStream0 = new MockPrintStream("Ed95");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, false);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.SYN_BLOCK;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(136, node0, 127, 54);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 136
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test060()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Ed95");
      MockPrintStream mockPrintStream0 = new MockPrintStream("Ed95");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, false);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.SYN_BLOCK;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope0);
      linkedFlowScope0.createChildFlowScope();
      Node node1 = new Node(52, node0, 2268, 118);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope1);
      assertNotSame(flowScope0, linkedFlowScope1);
  }

  @Test(timeout = 4000)
  public void test061()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Ed95");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = null;
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = compiler0.options;
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = new Node(124, node0, (-233), 1);
      typeInference0.flowThrough(node0, linkedFlowScope2);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope2);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // EMPTY does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test062()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      boolean boolean0 = false;
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      treeMap0.headMap("", false);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      LinkedFlowScope linkedFlowScope3 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope4 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope5 = new LinkedFlowScope(linkedFlowScope3);
      typeInference0.flowThrough(node0, linkedFlowScope1);
      Node node1 = new Node(66, node0, 36, 400000);
      LinkedFlowScope.createEntryLattice((Scope) null);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope4);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 66
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test063()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Scope scope0 = Scope.createLatticeBottom(node0);
      compiler0.getOptions();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention(closureCodingConvention0);
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = new Node(85, node0, 37, 32);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      FlowScope flowScope0 = semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node0, linkedFlowScope0, false);
      typeInference0.flowThrough(node1, flowScope0);
      Node node2 = Normalize.parseAndNormalizeTestCode(compiler0, "Object#Element");
      Node node3 = new Node(54, node2, 148, 158);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      Node node4 = null;
      try {
        node4 = new Node(48, node2, node0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // first new child has existing parent
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test064()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("Ed95");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      controlFlowGraph0.newSubGraph();
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope3 = new LinkedFlowScope(linkedFlowScope2);
      LinkedFlowScope linkedFlowScope4 = new LinkedFlowScope(linkedFlowScope3);
      typeInference0.flowThrough(node0, linkedFlowScope3);
      Node node1 = new Node(46, node0, 133, 4);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope4);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SHNE 133 : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test065()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      scope0.getArgumentsVar();
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      ArrayList<GraphNode<Node, ControlFlowGraph.Branch>> arrayList0 = new ArrayList<GraphNode<Node, ControlFlowGraph.Branch>>();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = new Node(115, node0, node0, node0);
      Node node2 = new Node(15, node1, 1745, 4095);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope1);
      assertNotSame(flowScope0, linkedFlowScope1);
  }

  @Test(timeout = 4000)
  public void test066()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("DD942");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("DD942", "DD942");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
      Scope scope1 = typedScopeCreator0.createInitialScope(node0);
      scope1.getArgumentsVar();
      JqueryCodingConvention jqueryCodingConvention1 = new JqueryCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention1, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, treeMap0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      scope0.getArgumentsVar();
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      ArrayList<GraphNode<Node, ControlFlowGraph.Branch>> arrayList0 = new ArrayList<GraphNode<Node, ControlFlowGraph.Branch>>();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope1);
      Node node1 = new Node(32, node0, 118, 519);
      typeInference0.flowThrough(node1, flowScope0);
      typeInference0.branchedFlowThrough(node0, flowScope0);
      assertNotSame(flowScope0, linkedFlowScope1);
      assertNotSame(linkedFlowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test067()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Ed95");
      MockPrintStream mockPrintStream0 = new MockPrintStream("Ed95");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      controlFlowGraph0.newSubGraph();
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, true);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.SYN_BLOCK;
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope3 = new LinkedFlowScope(linkedFlowScope2);
      LinkedFlowScope linkedFlowScope4 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = new Node((-189), node0, 46, 151);
      typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      Node node2 = new Node(33, node1, node1);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node2, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // -189
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test068()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("E*d95");
      MockPrintStream mockPrintStream0 = new MockPrintStream("E*d95");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("E*d95", "E*d95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.SYN_BLOCK;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = new Node(137, node0, 15, 37);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 137
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test069()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Ed95");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, true);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, false);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      Node node1 = new Node(145, node0, 481, 174);
      typeInference0.flowThrough(node1, flowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 145
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test070()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      scope0.getArgumentsVar();
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      ArrayList<GraphNode<Node, ControlFlowGraph.Branch>> arrayList0 = new ArrayList<GraphNode<Node, ControlFlowGraph.Branch>>();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope1);
      Node node1 = new Node(84, node0, 84, 54);
      typeInference0.flowThrough(node1, flowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 84
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test071()  throws Throwable  {
      MockPrintStream mockPrintStream0 = new MockPrintStream("Ed95");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      controlFlowGraph0.newSubGraph();
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, false);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.SYN_BLOCK;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      linkedFlowScope0.createChildFlowScope();
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      Node node1 = new Node(36, node0, 16, 1263);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope2);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 36
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test072()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      scope0.getArgumentsVar();
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      ArrayList<GraphNode<Node, ControlFlowGraph.Branch>> arrayList0 = new ArrayList<GraphNode<Node, ControlFlowGraph.Branch>>();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(113, node0, 3, 1);
      typeInference0.flowThrough(node1, linkedFlowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // WHILE 3 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test073()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Ed95");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, (byte[]) null);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      mockFileOutputStream0.release();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      typeInference0.createInitialEstimateLattice();
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      FlowScope flowScope0 = linkedFlowScope0.createChildFlowScope();
      typeInference0.flowThrough(node0, flowScope0);
      Node node1 = new Node(139, node0, (-573), 31);
      Node node2 = new Node(31, node1, 1704, 46);
      typeInference0.flowThrough(node1, linkedFlowScope1);
      typeInference0.flowThrough(node2, linkedFlowScope0);
      System.setCurrentTimeMillis((-224L));
  }

  @Test(timeout = 4000)
  public void test074()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Ed95");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      byte[] byteArray0 = new byte[4];
      byteArray0[0] = (byte) (-93);
      byteArray0[1] = (byte) (-66);
      byteArray0[2] = (byte)118;
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      treeMap0.descendingMap();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = new Node(16, node0, (-52), 51);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope1);
      assertNotSame(flowScope0, linkedFlowScope1);
  }

  @Test(timeout = 4000)
  public void test075()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("E*d95");
      MockPrintStream mockPrintStream0 = new MockPrintStream("E*d95");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("E*d95", "E*d95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.SYN_BLOCK;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope0);
      linkedFlowScope0.createChildFlowScope();
      Node node1 = new Node(119, node0, 15, 37);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // WITH 15 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test076()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      FileSystemHandling.shouldAllThrowIOExceptions();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_EX;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.TRUE;
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      BooleanLiteralSet booleanLiteralSet1 = BooleanLiteralSet.BOTH;
      BooleanLiteralSet booleanLiteralSet2 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet1, true);
      assertEquals(BooleanLiteralSet.BOTH, booleanLiteralSet2);
      
      compiler0.getTopScope();
      LinkedFlowScope.createEntryLattice((Scope) null);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = new Node(144, node0, 123, 145);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope1);
      assertFalse(list0.isEmpty());
      
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope1);
      assertNotSame(flowScope0, linkedFlowScope1);
  }

  @Test(timeout = 4000)
  public void test077()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("DD942");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("DD942", "DD942");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      compiler0.getOptions();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.UNCOND;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      ControlFlowGraph<Node> controlFlowGraph2 = typeInference0.getCfg();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph2, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(140, node0, 1, 16);
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      FlowScope flowScope0 = linkedFlowScope_FlowScopeJoinOp0.apply((FlowScope) linkedFlowScope0, (FlowScope) linkedFlowScope0);
      typeInference0.branchedFlowThrough(node0, flowScope0);
      FlowScope flowScope1 = typeInference0.createEntryLattice();
      typeInference0.createEntryLattice();
      typeInference0.flowThrough(node0, flowScope1);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 140
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test078()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Ed95");
      MockPrintStream mockPrintStream0 = new MockPrintStream("Ed95");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap1 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap1);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      typeInference0.flowThrough(node0, linkedFlowScope0);
      Node node1 = new Node(147, node0, 2167, 2);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough((Node) null, flowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test079()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("DD942");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("DD942", "DD942");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      compiler0.getOptions();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.UNCOND;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      typeInference0.flowThrough(node0, linkedFlowScope1);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      Node node1 = new Node(142, node0, (-2348), 4095);
      PeepholeFoldWithTypes peepholeFoldWithTypes0 = new PeepholeFoldWithTypes();
      Node node2 = peepholeFoldWithTypes0.optimizeSubtree(node1);
      FlowScope flowScope1 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test080()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("EOdd95");
      MockPrintStream mockPrintStream0 = new MockPrintStream("EOdd95");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("EOdd95", "EOdd95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, false);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = new Node(141, node0, (-1186), 43);
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      assertNotSame(flowScope1, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test081()  throws Throwable  {
      FileSystemHandling.shouldAllThrowIOExceptions();
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createGlobalScope(node0);
      SimpleErrorReporter simpleErrorReporter1 = new SimpleErrorReporter();
      Scope scope1 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      Compiler compiler1 = new Compiler(mockPrintStream0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope1);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = LinkedFlowScope.createEntryLattice(scope1);
      typeInference0.flowThrough(node0, linkedFlowScope2);
      Node node1 = new Node(155, node0, (-579), 8);
      node1.isOptionalArg();
      FlowScope flowScope0 = linkedFlowScope0.createChildFlowScope();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // CAST does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test082()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("EOdd95");
      MockPrintStream mockPrintStream0 = new MockPrintStream("EOdd95");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("EOdd95", "EOdd95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, false);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      typeInference0.flowThrough(node0, linkedFlowScope0);
      Node node1 = new Node(90, node0, 2867, 50);
      typeInference0.flowThrough(node1, linkedFlowScope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // ASSIGN_LSH 2867 : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test083()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Ed95");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createGlobalScope(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      byte[] byteArray0 = new byte[4];
      byteArray0[1] = (byte) (-93);
      byteArray0[1] = (byte) (-93);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      scope0.getArgumentsVar();
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      controlFlowGraph1.getNeighborNodes(node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      typeInference0.flowThrough(node0, linkedFlowScope0);
      Node node1 = new Node(145, node0, (-1640), 57);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph1, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 145
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test084()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Ed95");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      SimpleErrorReporter simpleErrorReporter1 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_EX;
      controlFlowGraph1.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      tightenTypes0.getTypeRegistry();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter1);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = LinkedFlowScope.createEntryLattice(scope0);
      typeInference0.flowThrough(node0, linkedFlowScope1);
      Node node1 = new Node(101, node0, 38, 700);
      node1.isOptionalArg();
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope2);
      System.setCurrentTimeMillis(4095);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test085()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      linkedFlowScope0.createChildFlowScope();
      typeInference0.flowThrough(node0, linkedFlowScope0);
      Node node1 = new Node(146, node0, 43, 309);
      Node node2 = new Node(4095, node1, (-1811), 57);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      typeInference1.flowThrough(node1, flowScope0);
      typeInference1.createEntryLattice();
      System.setCurrentTimeMillis(591L);
  }

  @Test(timeout = 4000)
  public void test086()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_FALSE;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOf((Map<? extends String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      JSTypeNative jSTypeNative0 = JSTypeNative.U2U_FUNCTION_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("prototype", jSTypeNative0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      compiler0.getParserConfig();
      tightenTypes0.getTypeRegistry();
      typeInference0.flowThrough(node0, linkedFlowScope1);
      LinkedFlowScope linkedFlowScope3 = new LinkedFlowScope(linkedFlowScope2);
      typeInference0.flowThrough(node0, linkedFlowScope0);
      Node node1 = new Node(38, node0, 117, 811);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node1, linkedFlowScope3);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // NAME 117 is not a string node
         //
         verifyException("com.google.javascript.rhino.Node", e);
      }
  }

  @Test(timeout = 4000)
  public void test087()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Ed95");
      MockPrintStream mockPrintStream0 = new MockPrintStream("Ed95");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, false);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.SYN_BLOCK;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope0);
      linkedFlowScope0.createChildFlowScope();
      Node node1 = new Node(125, node0, 57, 37);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // BLOCK 57 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test088()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Ed95");
      MockPrintStream mockPrintStream0 = new MockPrintStream("Ed95");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      controlFlowGraph0.newSubGraph();
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, false);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.SYN_BLOCK;
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      LinkedFlowScope linkedFlowScope3 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope4 = new LinkedFlowScope(linkedFlowScope3);
      typeInference0.flowThrough(node0, linkedFlowScope4);
      Node node1 = new Node(104, node0, (-4043), 15);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test089()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockFileOutputStream mockFileOutputStream1 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream1);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, true);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      Scope scope0 = Scope.createGlobalScope(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      LinkedList<GraphNode<Node, ControlFlowGraph.Branch>> linkedList0 = new LinkedList<GraphNode<Node, ControlFlowGraph.Branch>>();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      LinkedFlowScope linkedFlowScope3 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = new Node(12, node0, 52, (-310));
      typeInference0.branchedFlowThrough(node0, linkedFlowScope3);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test090()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Ed95");
      MockPrintStream mockPrintStream0 = new MockPrintStream("Ed95");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      controlFlowGraph0.newSubGraph();
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, false);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.SYN_BLOCK;
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      LinkedFlowScope linkedFlowScope3 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope4 = new LinkedFlowScope(linkedFlowScope3);
      typeInference0.flowThrough(node0, linkedFlowScope4);
      Node node1 = new Node(112, node0, (-4043), 15);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test091()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Ed95");
      MockPrintStream mockPrintStream0 = new MockPrintStream("Ed95");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      controlFlowGraph0.newSubGraph();
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, false);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.SYN_BLOCK;
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph1, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      typeInference1.flowThrough(node0, linkedFlowScope0);
      typeInference0.flowThrough(node0, linkedFlowScope0);
      FlowScope flowScope0 = linkedFlowScope1.createChildFlowScope();
      Node node1 = new Node(148, node0, 1, 30);
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SETTER_DEF 1 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test092()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_EX;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope.createEntryLattice((Scope) null);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;
      BooleanLiteralSet booleanLiteralSet1 = BooleanLiteralSet.TRUE;
      TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet1, false);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      Scope scope1 = cleanupPasses0.topScope;
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = new Node(120, node0, 30, 116);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      FlowScope flowScope0 = typeInference1.createInitialEstimateLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test093()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Ed95");
      MockPrintStream mockPrintStream0 = new MockPrintStream("Ed95");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      controlFlowGraph0.newSubGraph();
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, false);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.SYN_BLOCK;
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph1, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      typeInference1.flowThrough(node0, linkedFlowScope0);
      typeInference0.flowThrough(node0, linkedFlowScope0);
      Node node1 = new Node(111, node0, 2867, 50);
      typeInference1.flowThrough(node1, linkedFlowScope0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
      assertSame(booleanLiteralSet0, booleanLiteralSet1);
  }

  @Test(timeout = 4000)
  public void test094()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_EX;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      compiler0.newCompilerOptions();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      treeMap0.headMap("", false);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      LinkedFlowScope linkedFlowScope3 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope4 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope5 = new LinkedFlowScope(linkedFlowScope3);
      LinkedFlowScope linkedFlowScope6 = new LinkedFlowScope(linkedFlowScope2);
      Node node1 = new Node(74, node0, 36, 400000);
      LinkedFlowScope.createEntryLattice((Scope) null);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope4);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 74
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test095()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_EX;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, false);
      LinkedFlowScope linkedFlowScope3 = (LinkedFlowScope)typeInference0.flowThrough(node0, linkedFlowScope1);
      compiler0.reportCodeChange();
      Node node1 = new Node(37, node0, node0, node0, node0);
      LinkedFlowScope linkedFlowScope4 = new LinkedFlowScope(linkedFlowScope3);
      LinkedFlowScope linkedFlowScope5 = new LinkedFlowScope(linkedFlowScope2);
      Node node2 = new Node(12, node1, 144, (-90));
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.TreeMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test096()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_EX;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      Node node1 = new Node(30, node0, node0);
      node0.checkTreeEquals(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      LinkedFlowScope.createEntryLattice((Scope) null);
      compiler0.reportCodeChange();
      int int0 = 3903;
      Node node2 = null;
      try {
        node2 = new Node(53, node0, node0, node0, node0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test097()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_EX;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      treeMap0.headMap("", false);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope3 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = new Node(55, node0, node0);
      Node node2 = new Node(2, node1, 65279, 1);
      typeInference0.branchedFlowThrough(node0, linkedFlowScope3);
      typeInference0.flowThrough(node1, linkedFlowScope3);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.TRUE;
      BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
      assertSame(booleanLiteralSet0, booleanLiteralSet1);
  }

  @Test(timeout = 4000)
  public void test098()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Ed95");
      MockPrintStream mockPrintStream0 = new MockPrintStream("Ed95");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, false);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.SYN_BLOCK;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      ControlFlowGraph.Branch controlFlowGraph_Branch1 = ControlFlowGraph.Branch.ON_EX;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch1, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      FlowScope flowScope0 = typeInference1.flowThrough(node0, linkedFlowScope1);
      FlowScope flowScope1 = typeInference0.flowThrough(node0, flowScope0);
      Node node1 = new Node(106, node0, (-1973), 2);
      FlowScope flowScope2 = typeInference0.flowThrough(node1, flowScope0);
      assertNotSame(flowScope2, flowScope1);
  }

  @Test(timeout = 4000)
  public void test099()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_EX;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      treeMap0.headMap("", false);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      LinkedFlowScope linkedFlowScope3 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope4 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope5 = new LinkedFlowScope(linkedFlowScope3);
      typeInference0.flowThrough(node0, linkedFlowScope1);
      Node node1 = new Node(74, node0, 36, 400000);
      LinkedFlowScope linkedFlowScope6 = LinkedFlowScope.createEntryLattice((Scope) null);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope6);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 74
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test100()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      Scope scope1 = cleanupPasses0.topScope;
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      BooleanLiteralSet booleanLiteralSet1 = BooleanLiteralSet.TRUE;
      TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet1, false);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = new Node(50, node0, 151, 31);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 50
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test101()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Ed95");
      MockPrintStream mockPrintStream0 = new MockPrintStream("Ed95");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      controlFlowGraph0.newSubGraph();
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, false);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.SYN_BLOCK;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      linkedFlowScope0.createChildFlowScope();
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = new Node(36, node0, (-1240), 1263);
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, jqueryCodingConvention0);
      Scope scope1 = typedScopeCreator0.createScope(node1, scope0);
      LinkedFlowScope linkedFlowScope3 = LinkedFlowScope.createEntryLattice(scope1);
      typeInference0.flowThrough(node0, linkedFlowScope3);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope2);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 36
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test102()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_EX;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, false);
      typeInference0.flowThrough(node0, linkedFlowScope1);
      compiler0.reportCodeChange();
      Node node1 = new Node(37, node0, node0, node0, node0);
      Node node2 = new Node(30, node1, 153, 137);
      linkedFlowScope2.createChildFlowScope();
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node2, linkedFlowScope2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.TreeMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test103()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream("Td95e");
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      int int0 = 61;
      Node node1 = new Node(61, node0, 49, 400000);
      JSTypeNative jSTypeNative0 = JSTypeNative.BOOLEAN_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Td95e", jSTypeNative0);
      ImmutableMap.of("msg.primitive.expected", codingConvention_AssertionFunctionSpec0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 61
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test104()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = compiler0.options;
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      byte[] byteArray0 = new byte[1];
      byteArray0[0] = (byte)118;
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      treeMap0.descendingMap();
      scope0.getArgumentsVar();
      CodingConvention codingConvention0 = compiler0.getCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(codingConvention0, jSTypeRegistry0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(codingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.append(semanticReverseAbstractInterpreter0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, treeMap0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = new Node(40, node0, 2, (-52));
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test105()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_EX;
      controlFlowGraph1.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, false);
      typeInference0.flowThrough(node0, linkedFlowScope1);
      Node node1 = new Node(53, node0, node0, node0, node0);
      Node node2 = new Node(3903, node1, 4, 1);
      FlowScope flowScope0 = linkedFlowScope2.createChildFlowScope();
      typeInference0.flowThrough(node1, flowScope0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.TRUE;
      BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, true);
      assertSame(booleanLiteralSet0, booleanLiteralSet1);
  }

  @Test(timeout = 4000)
  public void test106()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      BooleanLiteralSet booleanLiteralSet1 = BooleanLiteralSet.FALSE;
      BooleanLiteralSet booleanLiteralSet2 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet1, true);
      assertEquals(BooleanLiteralSet.FALSE, booleanLiteralSet2);
      
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = new Node(29, node0, 129, 48);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(linkedFlowScope0, flowScope0);
  }

  @Test(timeout = 4000)
  public void test107()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Ed95");
      MockPrintStream mockPrintStream0 = new MockPrintStream("Ed95");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, false);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.SYN_BLOCK;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      Node node1 = new Node(43, node0, 40, 54);
      typeInference0.flowThrough(node1, flowScope0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.TRUE;
      BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
      assertSame(booleanLiteralSet1, booleanLiteralSet0);
  }

  @Test(timeout = 4000)
  public void test108()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      Scope scope1 = cleanupPasses0.topScope;
      Scope scope2 = Scope.createLatticeBottom(node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope2);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope2);
      Node node1 = new Node(15, node0, (-515), 40);
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      assertNotSame(flowScope1, linkedFlowScope2);
  }

  @Test(timeout = 4000)
  public void test109()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      Compiler compiler1 = new Compiler();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_FALSE;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOf((Map<? extends String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      BooleanLiteralSet booleanLiteralSet1 = BooleanLiteralSet.FALSE;
      BooleanLiteralSet booleanLiteralSet2 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet1, false);
      assertEquals(BooleanLiteralSet.FALSE, booleanLiteralSet2);
      
      LinkedFlowScope.createEntryLattice(scope0);
      typeInference0.createInitialEstimateLattice();
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope0);
      typeInference0.flowThrough(node0, linkedFlowScope0);
      Node node1 = new Node(49, node0, 1048, (-1406));
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope1);
      assertNotSame(flowScope0, linkedFlowScope1);
  }

  @Test(timeout = 4000)
  public void test110()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_FALSE;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope1 = LinkedFlowScope.createEntryLattice(scope0);
      typeInference0.createInitialEstimateLattice();
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope3 = new LinkedFlowScope(linkedFlowScope2);
      typeInference0.flowThrough(node0, linkedFlowScope1);
      Node node1 = new Node(54, node0, 0, 13);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      FlowScope flowScope1 = typeInference0.flowThrough(node0, flowScope0);
      assertNotSame(linkedFlowScope0, flowScope0);
      assertNotSame(flowScope0, flowScope1);
  }

  @Test(timeout = 4000)
  public void test111()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = new Node(65, node0, 49, 400000);
      JSTypeNative jSTypeNative0 = JSTypeNative.BOOLEAN_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Td95e", jSTypeNative0);
      ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("msg.primitive.expected", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableMap0);
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 65
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test112()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      BooleanLiteralSet booleanLiteralSet1 = BooleanLiteralSet.FALSE;
      BooleanLiteralSet booleanLiteralSet2 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet1, true);
      assertEquals(BooleanLiteralSet.FALSE, booleanLiteralSet2);
      
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = new Node(4, node0, 15, 1680);
      typeInference0.createEntryLattice();
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope1);
      assertNotSame(flowScope0, linkedFlowScope1);
  }

  @Test(timeout = 4000)
  public void test113()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_FALSE;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOf((Map<? extends String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      BooleanLiteralSet booleanLiteralSet1 = BooleanLiteralSet.FALSE;
      TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet1, false);
      LinkedFlowScope.createEntryLattice(scope0);
      typeInference0.createInitialEstimateLattice();
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope0);
      typeInference0.flowThrough(node0, linkedFlowScope0);
      Node node1 = new Node(13, node0, 8202, 38);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope2);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // NE 8202 : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test114()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_FALSE;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOf((Map<? extends String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      JSTypeNative jSTypeNative0 = JSTypeNative.U2U_FUNCTION_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("prototype", jSTypeNative0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      compiler0.getParserConfig();
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      JSType[] jSTypeArray0 = new JSType[10];
      Node node1 = jSTypeRegistry0.createParameters(jSTypeArray0);
      typeInference0.createEntryLattice();
      typeInference0.createEntryLattice();
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test115()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      CompilerOptions compilerOptions1 = new CompilerOptions();
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      BooleanLiteralSet booleanLiteralSet1 = BooleanLiteralSet.BOTH;
      TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet1, false);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = new Node(81, node0, 49, 400000);
      JSTypeNative jSTypeNative0 = JSTypeNative.BOOLEAN_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Td95e", jSTypeNative0);
      ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("msg.primitive.expected", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableMap0);
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 81
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test116()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_FALSE;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope1 = LinkedFlowScope.createEntryLattice(scope0);
      typeInference0.createInitialEstimateLattice();
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope3 = new LinkedFlowScope(linkedFlowScope2);
      typeInference0.flowThrough(node0, linkedFlowScope1);
      Node node1 = new Node(54, node0, 0, 13);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope3);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 54
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test117()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_FALSE;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOf((Map<? extends String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope.createEntryLattice(scope0);
      typeInference1.createInitialEstimateLattice();
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = new Node(153, node0, 0, 2759);
      FlowScope flowScope0 = typeInference1.flowThrough(node1, linkedFlowScope0);
      assertNotSame(linkedFlowScope0, flowScope0);
  }

  @Test(timeout = 4000)
  public void test118()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Ed95");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      byte[] byteArray0 = new byte[0];
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_TRUE;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      controlFlowGraph1.getNodes();
      typeInference0.createInitialEstimateLattice();
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = new Node(132, node0, 136, (-1723));
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SCRIPT 1 [synthetic: com.google.javascript.rhino.Node$IntPropListItem@0000000617] [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000000618] [input_id: com.google.javascript.rhino.Node$ObjectPropListItem@0000000619] does not have a condition.
         //
         verifyException("com.google.javascript.jscomp.NodeUtil", e);
      }
  }

  @Test(timeout = 4000)
  public void test119()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_FALSE;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOf((Map<? extends String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope.createEntryLattice(scope0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      BooleanLiteralSet booleanLiteralSet1 = BooleanLiteralSet.FALSE;
      TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet1, false);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      Scope scope1 = cleanupPasses0.topScope;
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      typeInference0.flowThrough(node0, flowScope0);
      Node node1 = new Node(38, node0, 156, 135);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // NAME 156 is not a string node
         //
         verifyException("com.google.javascript.rhino.Node", e);
      }
  }

  @Test(timeout = 4000)
  public void test120()  throws Throwable  {
      FileSystemHandling.shouldAllThrowIOExceptions();
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Ed95");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, false);
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_EX;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      typeInference0.createInitialEstimateLattice();
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      linkedFlowScope0.createChildFlowScope();
      typeInference0.flowThrough(node0, linkedFlowScope0);
      Node node1 = new Node(8, node0, 57, 30);
      typeInference0.flowThrough(node1, linkedFlowScope1);
      typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 8
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test121()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_FALSE;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOf((Map<? extends String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope.createEntryLattice(scope0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      BooleanLiteralSet booleanLiteralSet1 = BooleanLiteralSet.FALSE;
      BooleanLiteralSet booleanLiteralSet2 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet1, false);
      assertEquals(BooleanLiteralSet.FALSE, booleanLiteralSet2);
      
      CompilerOptions compilerOptions0 = new CompilerOptions();
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      Scope scope1 = cleanupPasses0.topScope;
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      typeInference0.flowThrough(node0, linkedFlowScope0);
      Node node1 = new Node(30, node0, 132, 148);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope1);
      assertNotSame(flowScope0, linkedFlowScope1);
  }

  @Test(timeout = 4000)
  public void test122()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Ed95");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      byte[] byteArray0 = new byte[0];
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TightenTypes tightenTypes0 = new TightenTypes(compiler1);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      typeInference0.flowThrough(node0, linkedFlowScope0);
      typeInference0.flowThrough(node0, linkedFlowScope0);
      Node node1 = new Node(100, node0, 42, 130);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node1, linkedFlowScope1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test123()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Ed95");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, false);
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      mockFileOutputStream0.flush();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_EX;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = Node.newNumber((-2709.32245058), 55, 42);
      typeInference0.flowThrough(node1, linkedFlowScope1);
      Node node2 = new Node(100, node0, 48, 2);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // NUMBER -2709.32245058 55 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test124()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Ed95");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      byte[] byteArray0 = new byte[4];
      byteArray0[0] = (byte) (-93);
      byteArray0[1] = (byte) (-66);
      byteArray0[2] = (byte)118;
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      treeMap0.descendingMap();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = new Node(116, node0, node0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope1);
      assertNotSame(flowScope0, linkedFlowScope1);
  }

  @Test(timeout = 4000)
  public void test125()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Ed95");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      byte[] byteArray0 = new byte[4];
      byteArray0[0] = (byte) (-93);
      byteArray0[1] = (byte) (-66);
      byteArray0[2] = (byte)118;
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      treeMap0.descendingMap();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = new Node(130, node0, (-52), 139);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope1);
      assertNotSame(flowScope0, linkedFlowScope1);
  }

  @Test(timeout = 4000)
  public void test126()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Ed95");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      byte[] byteArray0 = new byte[0];
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_EX;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      TightenTypes tightenTypes0 = new TightenTypes(compiler1);
      Node node1 = new Node(134, node0, 57, 121);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 134
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test127()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Ed95");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      byte[] byteArray0 = new byte[0];
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_EX;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      TightenTypes tightenTypes0 = new TightenTypes(compiler1);
      Node node1 = new Node(31, node0, 117, (-216));
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope1);
      assertEquals(1, list0.size());
      
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.createEntryLattice();
      FlowScope flowScope2 = typeInference0.flowThrough(node1, flowScope1);
      assertNotSame(flowScope2, flowScope0);
  }

  @Test(timeout = 4000)
  public void test128()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Ed95");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, false);
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      byte[] byteArray0 = new byte[4];
      byteArray0[0] = (byte) (-93);
      byteArray0[1] = (byte) (-66);
      byteArray0[2] = (byte)118;
      byteArray0[3] = (byte)112;
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      treeMap0.descendingMap();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = new Node(130, node0, (-52), 139);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope2);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // EXPR_RESULT does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test129()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      PrintStream printStream0 = mockPrintStream0.append((CharSequence) "Td95e");
      Compiler compiler0 = new Compiler(printStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      mockFileOutputStream0.getChannel();
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "Td95e");
      mockFileOutputStream0.getChannel();
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      JqueryCodingConvention jqueryCodingConvention1 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      Compiler compiler1 = new Compiler(printStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = new Node(47, node0, 30, 29);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope2);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // REGEXP 30 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test130()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      PrintStream printStream0 = mockPrintStream0.append((CharSequence) "Td95e");
      Compiler compiler0 = new Compiler(printStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      mockFileOutputStream0.getChannel();
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      Scope scope0 = Scope.createGlobalScope(node0);
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      BooleanLiteralSet booleanLiteralSet1 = BooleanLiteralSet.TRUE;
      TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet1, true);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      typeInference0.flowThrough(node0, linkedFlowScope0);
      Node node1 = new Node(4, node0, 12, 120);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // RETURN 12 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test131()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Ed95");
      MockPrintStream mockPrintStream0 = new MockPrintStream("Ed95");
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, false);
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.SYN_BLOCK;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope0);
      FlowScope flowScope0 = linkedFlowScope0.createChildFlowScope();
      typeInference0.flowThrough(node0, flowScope0);
      Node node1 = compiler0.parseTestCode("com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer");
      Node node2 = new Node(103, node1, 57, 37);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // DEC 57 : number does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test132()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Ed95");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, false);
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      treeMap0.descendingMap();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = new Node(122, node0, (-52), 139);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope2);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // VOID does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test133()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("DD942");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("DD942", "DD942");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_TRUE;
      controlFlowGraph1.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      LinkedFlowScope linkedFlowScope3 = new LinkedFlowScope(linkedFlowScope0);
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager((MessageFormatter) null, mockPrintStream0);
      Compiler compiler2 = new Compiler(printStreamErrorManager0);
      TightenTypes tightenTypes0 = new TightenTypes(compiler2);
      Node node1 = new Node(108, node0, 119, 39);
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // IF 119 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test134()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_FALSE;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOf((Map<? extends String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      JSTypeNative jSTypeNative0 = JSTypeNative.U2U_FUNCTION_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("prototype", jSTypeNative0);
      typeInference0.createInitialEstimateLattice();
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      compiler0.getParserConfig();
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      JSType[] jSTypeArray0 = new JSType[0];
      Node node1 = jSTypeRegistry0.createParameters(jSTypeArray0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test135()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("DD942");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("DD942", "DD942");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_TRUE;
      controlFlowGraph1.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = (LinkedFlowScope)typeInference1.createInitialEstimateLattice();
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope0);
      typeInference0.flowThrough(node0, linkedFlowScope1);
      LinkedFlowScope linkedFlowScope3 = new LinkedFlowScope(linkedFlowScope1);
      PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager((MessageFormatter) null, mockPrintStream0);
      Compiler compiler2 = new Compiler(printStreamErrorManager0);
      TightenTypes tightenTypes0 = new TightenTypes(compiler2);
      Node node1 = new Node(108, node0, 119, 39);
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // IF 119 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test136()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Ed95");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = null;
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      byte[] byteArray0 = new byte[0];
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_TRUE;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      TightenTypes tightenTypes0 = new TightenTypes(compiler1);
      Node node1 = new Node(5, node0, 40, 2);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 5
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test137()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("DD942");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("DD942", "DD942");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_TRUE;
      controlFlowGraph1.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference1.createInitialEstimateLattice();
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      typeInference0.flowThrough(node0, flowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      Node node1 = new Node(16, node0, 109, 4095);
      // Undeclared exception!
      try { 
        typeInference1.branchedFlowThrough(node1, linkedFlowScope2);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // GT 109 : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test138()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      PrintStream printStream0 = mockPrintStream0.append((CharSequence) "Td95e");
      Compiler compiler0 = new Compiler(printStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      BooleanLiteralSet booleanLiteralSet1 = BooleanLiteralSet.EMPTY;
      TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet1, false);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      Node node1 = new Node(42, node0, 55, 54);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // THIS 55 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test139()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      BooleanLiteralSet booleanLiteralSet1 = BooleanLiteralSet.TRUE;
      TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet1, false);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      LinkedFlowScope linkedFlowScope3 = new LinkedFlowScope(linkedFlowScope2);
      Node node1 = new Node(56, node0, 134, (-2598));
      typeInference0.branchedFlowThrough(node0, linkedFlowScope3);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 56
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test140()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, true);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      BooleanLiteralSet booleanLiteralSet1 = BooleanLiteralSet.TRUE;
      TypeInference.getBooleanOutcomes(booleanLiteralSet1, booleanLiteralSet0, true);
      controlFlowGraph0.getNeighborNodes(node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      LinkedFlowScope linkedFlowScope3 = new LinkedFlowScope(linkedFlowScope0);
      Node node1 = new Node(31, node0, 1, 57);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // DELPROP 1 : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test141()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("DD942");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("DD942", "DD942");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_TRUE;
      controlFlowGraph1.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference1.createInitialEstimateLattice();
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      typeInference0.flowThrough(node0, flowScope0);
      Node node1 = new Node(47, node0, 43, (-472));
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // REGEXP does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test142()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_EX;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = (LinkedFlowScope)typeInference0.createInitialEstimateLattice();
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      LinkedFlowScope linkedFlowScope3 = (LinkedFlowScope)typeInference0.flowThrough(node0, linkedFlowScope0);
      LinkedFlowScope linkedFlowScope4 = (LinkedFlowScope)typeInference0.flowThrough(node0, linkedFlowScope3);
      Node node1 = new Node(57, node0, 1, 30);
      typeInference0.flowThrough(node1, linkedFlowScope3);
      assertNotSame(linkedFlowScope0, linkedFlowScope3);
      assertNotSame(linkedFlowScope3, linkedFlowScope4);
  }

  @Test(timeout = 4000)
  public void test143()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Ed95");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, false);
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_EX;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      typeInference0.createInitialEstimateLattice();
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      linkedFlowScope0.createChildFlowScope();
      typeInference0.flowThrough(node0, linkedFlowScope0);
      Node node1 = new Node(8, node0, 57, 30);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 8
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test144()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Ed95");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Ed95", "Ed95");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      byte[] byteArray0 = new byte[0];
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, false);
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_EX;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      typeInference0.createInitialEstimateLattice();
      TightenTypes tightenTypes0 = new TightenTypes(compiler1);
      Node node1 = new Node(48, node0, 12, 38);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 48
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test145()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_FALSE;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOf((Map<? extends String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      JSTypeNative jSTypeNative0 = JSTypeNative.U2U_FUNCTION_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("prototype", jSTypeNative0);
      immutableSortedMap0.getOrDefault((Object) null, codingConvention_AssertionFunctionSpec0);
      linkedFlowScope0.inferSlotType((String) null, (JSType) null);
      typeInference0.createInitialEstimateLattice();
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      typeInference0.flowThrough(node0, linkedFlowScope0);
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      Node node1 = new Node(2898, node0, 94, 2);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SCRIPT 1 [synthetic: com.google.javascript.rhino.Node$IntPropListItem@0000000617] [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000000618] [input_id: com.google.javascript.rhino.Node$ObjectPropListItem@0000000619] does not have a condition.
         //
         verifyException("com.google.javascript.jscomp.NodeUtil", e);
      }
  }

  @Test(timeout = 4000)
  public void test146()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      scope0.getArgumentsVar();
      TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
      controlFlowGraph0.getNeighborNodes(node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope1);
      Node node1 = new Node(84, node0, 84, 4);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 84
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test147()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
      CompilerOptions compilerOptions0 = compiler0.options;
      CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
      Scope scope1 = cleanupPasses0.topScope;
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node0, (FlowScope) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test148()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_EX;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = (LinkedFlowScope)typeInference0.createInitialEstimateLattice();
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      LinkedFlowScope linkedFlowScope3 = (LinkedFlowScope)typeInference0.flowThrough(node0, linkedFlowScope0);
      LinkedFlowScope linkedFlowScope4 = (LinkedFlowScope)typeInference0.flowThrough(node0, linkedFlowScope3);
      assertNotSame(linkedFlowScope0, linkedFlowScope4);
      
      Node node1 = new Node(57, node0, 1, 30);
      LinkedFlowScope linkedFlowScope5 = new LinkedFlowScope(linkedFlowScope1);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope5);
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void test149()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, false);
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_EX;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      typeInference0.createInitialEstimateLattice();
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      FlowScope flowScope0 = linkedFlowScope1.createChildFlowScope();
      typeInference0.flowThrough(node0, flowScope0);
      Node node1 = new Node(52, node0, 57, 2075626741);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // INSTANCEOF 57 : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test150()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = (LinkedFlowScope)typeInference0.createInitialEstimateLattice();
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      typeInference0.flowThrough(node0, linkedFlowScope0);
      typeInference0.flowThrough(node0, linkedFlowScope0);
      Node node1 = new Node(12, node0, 50, 30);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope2);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // EQ 50 : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test151()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, true);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_EX;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = (LinkedFlowScope)typeInference0.createInitialEstimateLattice();
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      LinkedFlowScope linkedFlowScope3 = (LinkedFlowScope)typeInference0.flowThrough(node0, linkedFlowScope0);
      Node node1 = new Node(56, node0, 349, 164);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope3);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 56
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test152()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_FALSE;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOf((Map<? extends String, ? extends CodingConvention.AssertionFunctionSpec>) treeMap0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      JSTypeNative jSTypeNative0 = JSTypeNative.U2U_FUNCTION_TYPE;
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("prototype", jSTypeNative0);
      immutableSortedMap0.getOrDefault((Object) null, codingConvention_AssertionFunctionSpec0);
      linkedFlowScope0.inferSlotType((String) null, (JSType) null);
      typeInference0.createInitialEstimateLattice();
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      typeInference0.flowThrough(node0, linkedFlowScope0);
      Node node1 = new Node(2, node0, (-1), (-2332));
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      JSType[] jSTypeArray0 = new JSType[0];
      Node node2 = jSTypeRegistry0.createParameters(jSTypeArray0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test153()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_EX;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = (LinkedFlowScope)typeInference0.createInitialEstimateLattice();
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      LinkedFlowScope linkedFlowScope3 = (LinkedFlowScope)typeInference0.flowThrough(node0, linkedFlowScope0);
      typeInference0.flowThrough(node0, linkedFlowScope3);
      Node node1 = new Node(57, node0, 1, 30);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 57
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test154()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
      controlFlowGraph0.getNeighborNodes(node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      Node node1 = new Node(1, node0, 54, 56);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 1
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test155()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_EX;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = (LinkedFlowScope)typeInference0.createInitialEstimateLattice();
      LinkedFlowScope linkedFlowScope2 = new LinkedFlowScope(linkedFlowScope1);
      LinkedFlowScope linkedFlowScope3 = (LinkedFlowScope)typeInference0.flowThrough(node0, linkedFlowScope0);
      assertNotSame(linkedFlowScope0, linkedFlowScope3);
      
      Node node1 = new Node((-449), node0, 38, 53);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope1);
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void test156()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      SimpleErrorReporter simpleErrorReporter1 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph1, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      BooleanLiteralSet booleanLiteralSet1 = BooleanLiteralSet.FALSE;
      TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet1, true);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      typeInference0.flowThrough(node0, linkedFlowScope0);
      Node node1 = new Node(51, node0, (-2388), 51);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // IN : boolean does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test157()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      linkedFlowScope_FlowScopeJoinOp0.apply(flowScope0, (FlowScope) linkedFlowScope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test158()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      Scope scope0 = Scope.createLatticeBottom(node0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler1 = new Compiler(mockPrintStream0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      scope0.getArgumentsVar();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      typeInference0.flowThrough(node0, linkedFlowScope1);
      Node node1 = new Node(1, node0, 54, 56);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 1
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test159()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, (byte[]) null);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      File file0 = MockFile.createTempFile("com.google.javascript.jscomp.InlineFunctions$FunctionState", "deprecated");
      SourceFile sourceFile0 = SourceFile.fromFile(file0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler1 = new Compiler(mockPrintStream0);
      compiler1.compile(sourceFile0, sourceFile0, compilerOptions0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope1);
      assertNotSame(flowScope0, linkedFlowScope1);
      
      Node node1 = compiler1.parseTestCode("}SJ");
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SCRIPT [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000001844] [input_id: com.google.javascript.rhino.Node$ObjectPropListItem@0000001845] does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void test160()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, (byte[]) null);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, true, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      File file0 = MockFile.createTempFile("com.google.javascript.jscomp.InlineFunctions$FunctionState", "deprecated");
      SourceFile sourceFile0 = SourceFile.fromFile(file0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler1 = new Compiler(mockPrintStream0);
      compiler1.compile(sourceFile0, sourceFile0, compilerOptions0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
      System.setCurrentTimeMillis(15);
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
      FlowScope flowScope1 = linkedFlowScope_FlowScopeJoinOp0.apply((FlowScope) linkedFlowScope0, flowScope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope1);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test161()  throws Throwable  {
      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Td95e");
      MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
      Compiler compiler0 = new Compiler(mockPrintStream0);
      Node node0 = compiler0.parseSyntheticCode("Td95e", "Td95e");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, (byte[]) null);
      ControlFlowGraph<Node> controlFlowGraph1 = new ControlFlowGraph<Node>(node0, false, false);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      File file0 = MockFile.createTempFile("com.google.javascript.jscomp.InlineFunctions$FunctionState", "deprecated");
      SourceFile sourceFile0 = SourceFile.fromFile(file0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      Compiler compiler1 = new Compiler(mockPrintStream0);
      compiler1.compile(sourceFile0, sourceFile0, compilerOptions0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
      TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope1);
      typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.createEntryLattice();
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test162()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("Could not find message entry for fallback argument {0}");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
      Scope.createLatticeBottom(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Key");
      Scope scope0 = null;
      MockFile.createTempFile("0{~L|/<e Uv`-0", "Object#Key");
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      Node.newString((-2516), "Object#Element");
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      TypeInference typeInference0 = null;
      try {
        typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, (Scope) null, treeMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.Compiler", e);
      }
  }

  @Test(timeout = 4000)
  public void test163()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("Could not find message entry for fallback argument {0}");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Key");
      String string0 = "0{~L|/<e Uv`-0";
      File file0 = MockFile.createTempFile("0{~L|/<e Uv`-0", "Object#Key");
      SourceFile sourceFile0 = SourceFile.fromFile(file0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = null;
      try {
        typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test164()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      Compiler compiler0 = new Compiler();
      String string0 = "Could not find message entry for fallback argument {0}";
      Node node0 = Node.newString("Could not find message entry for fallback argument {0}");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
      Scope.createLatticeBottom(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Key");
      File file0 = MockFile.createTempFile("0{~L|/<e Uv`-0", "Object#Key");
      SourceFile sourceFile0 = SourceFile.fromFile(file0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      compiler0.compile(sourceFile0, sourceFile0, compilerOptions0);
      TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
      TypeInference typeInference0 = null;
      try {
        typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, (Scope) null, treeMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test165()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;
      // Undeclared exception!
      try { 
        TypeInference.getBooleanOutcomes(booleanLiteralSet0, (BooleanLiteralSet) null, false);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test166()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;
      BooleanLiteralSet booleanLiteralSet1 = BooleanLiteralSet.EMPTY;
      BooleanLiteralSet booleanLiteralSet2 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet1, true);
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("Could not find message entry for fallback argument {0}");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
      ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = closureReverseAbstractInterpreter0.getFirst();
      Scope scope0 = Scope.createGlobalScope(node0);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Key");
      TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet2, false);
      PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
      peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("HBq j?5?nX^bcw", codingConvention_AssertionFunctionSpec0);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap1 = immutableSortedMap0.headMap("Object#Element", false);
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap2 = immutableSortedMap1.headMap("of[n{hbk'");
      TypeInference typeInference0 = null;
      try {
        typeInference0 = new TypeInference(compiler0, controlFlowGraph0, chainableReverseAbstractInterpreter0, scope0, immutableSortedMap2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.Compiler", e);
      }
  }

  @Test(timeout = 4000)
  public void test167()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      BooleanLiteralSet booleanLiteralSet1 = BooleanLiteralSet.EMPTY;
      TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet1, true);
      BooleanLiteralSet booleanLiteralSet2 = BooleanLiteralSet.TRUE;
      BooleanLiteralSet booleanLiteralSet3 = BooleanLiteralSet.EMPTY;
      TypeInference.getBooleanOutcomes(booleanLiteralSet2, booleanLiteralSet3, true);
      BooleanLiteralSet booleanLiteralSet4 = BooleanLiteralSet.BOTH;
      BooleanLiteralSet booleanLiteralSet5 = BooleanLiteralSet.BOTH;
      TypeInference.getBooleanOutcomes(booleanLiteralSet4, booleanLiteralSet5, true);
      String string0 = "B'k~@pPWg";
      MockPrintStream mockPrintStream0 = null;
      try {
        mockPrintStream0 = new MockPrintStream("B'k~@pPWg", "");
        fail("Expecting exception: UnsupportedEncodingException");
      
      } catch(Throwable e) {
         //
         // 
         //
         verifyException("java.io.PrintStream", e);
      }
  }

  @Test(timeout = 4000)
  public void test168()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;
      BooleanLiteralSet booleanLiteralSet1 = BooleanLiteralSet.TRUE;
      BooleanLiteralSet booleanLiteralSet2 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet1, false);
      assertEquals(BooleanLiteralSet.TRUE, booleanLiteralSet2);
  }
}
