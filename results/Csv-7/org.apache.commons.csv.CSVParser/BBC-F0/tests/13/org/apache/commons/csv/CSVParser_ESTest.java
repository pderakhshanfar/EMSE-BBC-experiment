/*
 * This file was automatically generated by EvoSuite
 * Tue Nov 17 07:59:27 GMT 2020
 */

package org.apache.commons.csv;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.StringReader;
import java.net.URL;
import java.nio.charset.Charset;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.csv.Quote;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.mock.java.io.MockFile;
import org.evosuite.runtime.mock.java.net.MockURL;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class CSVParser_ESTest extends CSVParser_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      StringReader stringReader0 = new StringReader("`n5!nsg\"eXZ_=\"#)G2)");
      CSVFormat cSVFormat0 = CSVFormat.EXCEL;
      stringReader0.close();
      CSVParser cSVParser0 = new CSVParser(stringReader0, cSVFormat0);
      Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
      // Undeclared exception!
      try { 
        cSVParser0.forEach(consumer0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // java.io.IOException: Stream closed
         //
         verifyException("org.apache.commons.csv.CSVParser$1", e);
      }
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      File file0 = MockFile.createTempFile("No more CSV records available", "");
      CSVFormat cSVFormat0 = CSVFormat.EXCEL;
      CSVParser cSVParser0 = CSVParser.parse(file0, cSVFormat0);
      CSVRecord cSVRecord0 = cSVParser0.nextRecord();
      assertNull(cSVRecord0);
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.newFormat('u');
      String[] stringArray0 = new String[4];
      stringArray0[0] = "l$m;#$YzVuL#`D_!#";
      stringArray0[1] = "eof";
      stringArray0[2] = "(startline";
      CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
      CSVParser cSVParser0 = CSVParser.parse("EdR*o@}", cSVFormat1);
      assertEquals(0L, cSVParser0.getRecordNumber());
      
      CSVRecord cSVRecord0 = cSVParser0.nextRecord();
      assertEquals("[EdR*o@}]", cSVRecord0.toString());
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.MYSQL;
      StringReader stringReader0 = new StringReader("NullString=<");
      CSVParser cSVParser0 = cSVFormat0.parse(stringReader0);
      CSVRecord cSVRecord0 = cSVParser0.nextRecord();
      assertEquals("[NullString=<]", cSVRecord0.toString());
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.RFC4180;
      CSVParser cSVParser0 = CSVParser.parse(" |o", cSVFormat0);
      cSVParser0.close();
      boolean boolean0 = cSVParser0.isClosed();
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.RFC4180;
      StringReader stringReader0 = new StringReader("");
      CSVParser cSVParser0 = cSVFormat0.parse(stringReader0);
      LinkedList<CSVRecord> linkedList0 = cSVParser0.getRecords((LinkedList<CSVRecord>) null);
      assertNull(linkedList0);
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      File file0 = MockFile.createTempFile("No more CSV records available", "");
      CSVFormat cSVFormat0 = CSVFormat.EXCEL;
      CSVParser cSVParser0 = CSVParser.parse(file0, cSVFormat0);
      List<CSVRecord> list0 = cSVParser0.getRecords();
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      Quote quote0 = Quote.NON_NUMERIC;
      String[] stringArray0 = new String[2];
      stringArray0[0] = "UmuthDUXp1";
      CSVFormat cSVFormat0 = new CSVFormat('M', (Character) null, quote0, (Character) null, (Character) null, true, false, "No header mapping was specified, the record values can't be accessed by name", "UmuthDUXp1", stringArray0, false);
      CSVParser cSVParser0 = CSVParser.parse("No header mapping was specified, the record values can't be accessed by name", cSVFormat0);
      long long0 = cSVParser0.getRecordNumber();
      assertEquals(0L, long0);
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      Character character0 = Character.valueOf('\"');
      Quote quote0 = Quote.NON_NUMERIC;
      Character character1 = Character.valueOf('u');
      String[] stringArray0 = new String[0];
      CSVFormat cSVFormat0 = new CSVFormat('9', character0, quote0, character1, character0, false, false, "url", "url", stringArray0, false);
      CSVParser cSVParser0 = CSVParser.parse("url", cSVFormat0);
      Map<String, Integer> map0 = cSVParser0.getHeaderMap();
      assertTrue(map0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      Character character0 = Character.valueOf('\"');
      Quote quote0 = Quote.NON_NUMERIC;
      Character character1 = Character.valueOf('u');
      String[] stringArray0 = new String[0];
      CSVFormat cSVFormat0 = new CSVFormat('9', character0, quote0, character1, character0, false, false, "url", "url", stringArray0, false);
      CSVParser cSVParser0 = CSVParser.parse("url", cSVFormat0);
      long long0 = cSVParser0.getCurrentLineNumber();
      assertEquals(1L, long0);
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      Charset charset0 = Charset.defaultCharset();
      CSVFormat cSVFormat0 = CSVFormat.EXCEL;
      // Undeclared exception!
      try { 
        CSVParser.parse((URL) null, charset0, cSVFormat0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Parameter 'url' must not be null!
         //
         verifyException("org.apache.commons.csv.Assertions", e);
      }
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      URL uRL0 = MockURL.getHttpExample();
      Charset charset0 = Charset.defaultCharset();
      CSVFormat cSVFormat0 = CSVFormat.newFormat('t');
      try { 
        CSVParser.parse(uRL0, charset0, cSVFormat0);
        fail("Expecting exception: IOException");
      
      } catch(IOException e) {
         //
         // Could not find: www.someFakeButWellFormedURL.org
         //
         verifyException("org.evosuite.runtime.mock.java.net.EvoHttpURLConnection", e);
      }
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.MYSQL;
      String[] stringArray0 = new String[8];
      CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
      // Undeclared exception!
      try { 
        CSVParser.parse("(line ", cSVFormat1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // The header contains duplicate names: [null, null, null, null, null, null, null, null]
         //
         verifyException("org.apache.commons.csv.CSVFormat", e);
      }
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      // Undeclared exception!
      try { 
        CSVParser.parse("", (CSVFormat) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Parameter 'format' must not be null!
         //
         verifyException("org.apache.commons.csv.Assertions", e);
      }
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.EXCEL;
      String[] stringArray0 = new String[0];
      CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
      try { 
        CSVParser.parse("\"8~ZVN!gg!(Fm", cSVFormat1);
        fail("Expecting exception: IOException");
      
      } catch(IOException e) {
         //
         // (startline 1) EOF reached before encapsulated token finished
         //
         verifyException("org.apache.commons.csv.Lexer", e);
      }
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.EXCEL;
      File file0 = MockFile.createTempFile("2>b|d`{f*,>zlfsb", "~d'.");
      Character character0 = new Character('5');
      CSVFormat cSVFormat1 = cSVFormat0.withEscape(character0);
      CSVFormat cSVFormat2 = cSVFormat1.withCommentStart(character0);
      // Undeclared exception!
      try { 
        CSVParser.parse(file0, cSVFormat2);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // The comment start and the escape character cannot be the same ('5')
         //
         verifyException("org.apache.commons.csv.CSVFormat", e);
      }
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.MYSQL;
      // Undeclared exception!
      try { 
        CSVParser.parse((File) null, cSVFormat0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Parameter 'file' must not be null!
         //
         verifyException("org.apache.commons.csv.Assertions", e);
      }
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      MockFile mockFile0 = new MockFile("bg?8UZ9bVleaNHY;%*", "bg?8UZ9bVleaNHY;%*");
      Character character0 = Character.valueOf('Q');
      Quote quote0 = Quote.NONE;
      String[] stringArray0 = new String[1];
      CSVFormat cSVFormat0 = new CSVFormat('Q', character0, quote0, character0, character0, false, false, "bg?8UZ9bVleaNHY;%*", "b", stringArray0, false);
      try { 
        CSVParser.parse((File) mockFile0, cSVFormat0);
        fail("Expecting exception: FileNotFoundException");
      
      } catch(FileNotFoundException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.evosuite.runtime.mock.java.io.MockFileInputStream", e);
      }
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      StringReader stringReader0 = new StringReader("`n5!nsg\"eXZ_=\"#)G2)");
      CSVFormat cSVFormat0 = CSVFormat.EXCEL;
      stringReader0.close();
      CSVParser cSVParser0 = new CSVParser(stringReader0, cSVFormat0);
      try { 
        cSVParser0.nextRecord();
        fail("Expecting exception: IOException");
      
      } catch(IOException e) {
         //
         // Stream closed
         //
         verifyException("java.io.StringReader", e);
      }
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.RFC4180;
      CSVParser cSVParser0 = CSVParser.parse("(line ", cSVFormat0);
      // Undeclared exception!
      try { 
        cSVParser0.getRecords((LinkedList<CSVRecord>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.csv.CSVParser", e);
      }
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.DEFAULT;
      CSVParser cSVParser0 = CSVParser.parse("s+Jl4<`8!.", cSVFormat0);
      cSVParser0.close();
      LinkedList<CSVRecord> linkedList0 = new LinkedList<CSVRecord>();
      try { 
        cSVParser0.getRecords(linkedList0);
        fail("Expecting exception: IOException");
      
      } catch(IOException e) {
         //
         // Stream closed
         //
         verifyException("java.io.BufferedReader", e);
      }
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      Quote quote0 = Quote.NON_NUMERIC;
      String[] stringArray0 = new String[2];
      stringArray0[0] = "UmuthDUXp1";
      CSVFormat cSVFormat0 = new CSVFormat('M', (Character) null, quote0, (Character) null, (Character) null, true, false, "No header mapping was specified, the record values can't be accessed by name", "UmuthDUXp1", stringArray0, false);
      CSVParser cSVParser0 = CSVParser.parse("No header mapping was specified, the record values can't be accessed by name", cSVFormat0);
      cSVParser0.close();
      try { 
        cSVParser0.getRecords();
        fail("Expecting exception: IOException");
      
      } catch(IOException e) {
         //
         // Stream closed
         //
         verifyException("java.io.BufferedReader", e);
      }
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      StringReader stringReader0 = new StringReader("");
      Quote quote0 = Quote.MINIMAL;
      String[] stringArray0 = new String[2];
      CSVFormat cSVFormat0 = new CSVFormat('v', (Character) null, quote0, (Character) null, (Character) null, false, false, (String) null, (String) null, stringArray0, false);
      CSVParser cSVParser0 = null;
      try {
        cSVParser0 = new CSVParser(stringReader0, cSVFormat0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // The header contains duplicate names: [null, null]
         //
         verifyException("org.apache.commons.csv.CSVFormat", e);
      }
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      StringReader stringReader0 = new StringReader("!0?|*");
      CSVParser cSVParser0 = null;
      try {
        cSVParser0 = new CSVParser(stringReader0, (CSVFormat) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Parameter 'format' must not be null!
         //
         verifyException("org.apache.commons.csv.Assertions", e);
      }
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      Character character0 = Character.valueOf('0');
      Quote quote0 = Quote.NON_NUMERIC;
      Character character1 = new Character('u');
      String[] stringArray0 = new String[0];
      CSVFormat cSVFormat0 = new CSVFormat('M', character0, quote0, character1, character0, false, true, "No header mapping was specified, the record values can't be accessed by name", "No header mapping was specified, the record values can't be accessed by name", stringArray0, false);
      StringReader stringReader0 = new StringReader("No header mapping was specified, the record values can't be accessed by name");
      stringReader0.close();
      CSVParser cSVParser0 = null;
      try {
        cSVParser0 = new CSVParser(stringReader0, cSVFormat0);
        fail("Expecting exception: IOException");
      
      } catch(Throwable e) {
         //
         // Stream closed
         //
         verifyException("java.io.StringReader", e);
      }
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      Character character0 = Character.valueOf('$');
      Quote quote0 = Quote.ALL;
      Character character1 = new Character('a');
      String[] stringArray0 = new String[1];
      CSVFormat cSVFormat0 = new CSVFormat('\u0015', character0, quote0, character1, character0, true, true, "urQA", "urQA", stringArray0, true);
      CSVParser cSVParser0 = CSVParser.parse("au9d\nj90x;j>y", cSVFormat0);
      assertEquals(1L, cSVParser0.getRecordNumber());
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.newFormat('k');
      CSVParser cSVParser0 = CSVParser.parse("Unexpected Token type: ", cSVFormat0);
      LinkedList<CSVRecord> linkedList0 = new LinkedList<CSVRecord>();
      cSVParser0.getRecords(linkedList0);
      assertEquals(1, linkedList0.size());
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.EXCEL;
      CSVParser cSVParser0 = CSVParser.parse("\r\n", cSVFormat0);
      Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
      cSVParser0.forEach(consumer0);
      assertEquals(1L, cSVParser0.getRecordNumber());
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.RFC4180;
      CSVParser cSVParser0 = CSVParser.parse("wyaccdjo\"a!|3joa]", cSVFormat0);
      cSVParser0.close();
      Consumer<CSVRecord> consumer0 = (Consumer<CSVRecord>) mock(Consumer.class, new ViolatedAssumptionAnswer());
      cSVParser0.forEach(consumer0);
      assertEquals(0L, cSVParser0.getRecordNumber());
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      Character character0 = Character.valueOf('0');
      Quote quote0 = Quote.NON_NUMERIC;
      Character character1 = new Character('u');
      String[] stringArray0 = new String[0];
      CSVFormat cSVFormat0 = new CSVFormat('M', character0, quote0, character1, character0, false, true, "No header mapping was specified, the record values can't be accessed by name", "No header mapping was specified, the record values can't be accessed by name", stringArray0, false);
      StringReader stringReader0 = new StringReader("No header mapping was specified, the record values can't be accessed by name");
      cSVFormat0.parse(stringReader0);
      CSVParser cSVParser0 = new CSVParser(stringReader0, cSVFormat0);
      assertEquals(0L, cSVParser0.getRecordNumber());
  }

  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      StringReader stringReader0 = new StringReader("[`;W`MiGJ=5z}n:7{i");
      CSVFormat cSVFormat0 = CSVFormat.MYSQL;
      CSVParser cSVParser0 = new CSVParser(stringReader0, cSVFormat0);
      Map<String, Integer> map0 = cSVParser0.getHeaderMap();
      assertNull(map0);
  }

  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.newFormat('u');
      String[] stringArray0 = new String[4];
      stringArray0[0] = "l$m;#$YzVuL#`D_!#";
      stringArray0[1] = "eof";
      stringArray0[2] = "(startline";
      CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);
      CSVParser cSVParser0 = CSVParser.parse("EdR*o@}", cSVFormat1);
      Map<String, Integer> map0 = cSVParser0.getHeaderMap();
      assertNotNull(map0);
      assertEquals(4, map0.size());
      assertEquals(0L, cSVParser0.getRecordNumber());
  }

  @Test(timeout = 4000)
  public void test32()  throws Throwable  {
      Character character0 = Character.valueOf('0');
      Quote quote0 = Quote.NON_NUMERIC;
      Character character1 = new Character('u');
      String[] stringArray0 = new String[0];
      CSVFormat cSVFormat0 = new CSVFormat('M', character0, quote0, character1, character0, false, true, "No header mapping was specified, the record values can't be accessed by name", "No header mapping was specified, the record values can't be accessed by name", stringArray0, false);
      StringReader stringReader0 = new StringReader("No header mapping was specified, the record values can't be accessed by name");
      CSVParser cSVParser0 = cSVFormat0.parse(stringReader0);
      long long0 = cSVParser0.getRecordNumber();
      assertEquals(1L, long0);
  }

  @Test(timeout = 4000)
  public void test33()  throws Throwable  {
      Character character0 = Character.valueOf('$');
      Quote quote0 = Quote.ALL;
      Character character1 = new Character('a');
      String[] stringArray0 = new String[1];
      CSVFormat cSVFormat0 = new CSVFormat('\u0015', character0, quote0, character1, character0, true, true, "urQA", "urQA", stringArray0, true);
      StringReader stringReader0 = new StringReader("urQA");
      CSVParser cSVParser0 = cSVFormat0.parse(stringReader0);
      cSVParser0.getCurrentLineNumber();
      assertEquals(1L, cSVParser0.getRecordNumber());
  }

  @Test(timeout = 4000)
  public void test34()  throws Throwable  {
      File file0 = MockFile.createTempFile("No more CSV records available", "");
      CSVFormat cSVFormat0 = CSVFormat.EXCEL;
      CSVParser cSVParser0 = CSVParser.parse(file0, cSVFormat0);
      boolean boolean0 = cSVParser0.isClosed();
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test35()  throws Throwable  {
      CSVFormat cSVFormat0 = CSVFormat.EXCEL;
      CSVParser cSVParser0 = CSVParser.parse("\r\n", cSVFormat0);
      List<CSVRecord> list0 = cSVParser0.getRecords();
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void test36()  throws Throwable  {
      URL uRL0 = MockURL.getFtpExample();
      Charset charset0 = Charset.defaultCharset();
      CSVFormat cSVFormat0 = CSVFormat.RFC4180;
      // Undeclared exception!
      try { 
        CSVParser.parse(uRL0, charset0, cSVFormat0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.net.URL", e);
      }
  }

  @Test(timeout = 4000)
  public void test37()  throws Throwable  {
      Character character0 = Character.valueOf('$');
      Quote quote0 = Quote.ALL;
      Character character1 = new Character('a');
      String[] stringArray0 = new String[1];
      CSVFormat cSVFormat0 = new CSVFormat('\u0015', character0, quote0, character1, character0, true, true, "urQA", "urQA", stringArray0, true);
      StringReader stringReader0 = new StringReader("urQA");
      CSVParser cSVParser0 = cSVFormat0.parse(stringReader0);
      cSVParser0.iterator();
      assertEquals(1L, cSVParser0.getRecordNumber());
  }
}
