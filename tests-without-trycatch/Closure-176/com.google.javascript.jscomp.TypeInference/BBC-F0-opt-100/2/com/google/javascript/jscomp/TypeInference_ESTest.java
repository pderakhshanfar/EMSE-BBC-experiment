/*
 * This file was automatically generated by EvoSuite
 * Wed Oct 13 16:07:39 GMT 2021
 */

package com.google.javascript.jscomp;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.common.collect.ImmutableBiMap;
import com.google.common.collect.ImmutableSortedMap;
import com.google.javascript.jscomp.ClosureCodingConvention;
import com.google.javascript.jscomp.CodingConvention;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.ControlFlowGraph;
import com.google.javascript.jscomp.ExploitAssigns;
import com.google.javascript.jscomp.JqueryCodingConvention;
import com.google.javascript.jscomp.LinkedFlowScope;
import com.google.javascript.jscomp.Scope;
import com.google.javascript.jscomp.SourceFile;
import com.google.javascript.jscomp.TightenTypes;
import com.google.javascript.jscomp.TypeInference;
import com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.FlowScope;
import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.SimpleErrorReporter;
import com.google.javascript.rhino.jstype.BooleanLiteralSet;
import com.google.javascript.rhino.jstype.JSType;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import java.util.List;
import java.util.Map;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class TypeInference_ESTest extends TypeInference_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test000()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(6, 6, 6);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH", "JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH", "JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      JSType[] jSTypeArray0 = new JSType[1];
      Node node2 = jSTypeRegistry0.createParameters(jSTypeArray0);
      FlowScope flowScope1 = typeInference1.flowThrough(node2, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test001()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      // Undeclared exception!
//      try { 
        TypeInference.getBooleanOutcomes((BooleanLiteralSet) null, booleanLiteralSet0, true);
//        fail("Expecting exception: NullPointerException");
      
//      } catch(NullPointerException e) {
//         //
//         // no message in exception (getMessage() returned null)
//         //
//         verifyException("com.google.javascript.jscomp.TypeInference", e);
//      }
  }

  @Test(timeout = 4000)
  public void test002()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = Node.newString("Oa", 1, 1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer", "5T", "com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer");
      Node node1 = compiler0.parse(sourceFile0);
      Node node2 = new Node(38, node1, 40, 1);
      node0.addChildToBack(node2);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
//      try { 
        typeInference0.flowThrough(node2, linkedFlowScope0);
//        fail("Expecting exception: UnsupportedOperationException");
      
//      } catch(UnsupportedOperationException e) {
//         //
//         // NAME 40 is not a string node
//         //
//         verifyException("com.google.javascript.rhino.Node", e);
//      }
  }

  @Test(timeout = 4000)
  public void test003()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(64);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
//      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
//        fail("Expecting exception: NullPointerException");
      
//      } catch(NullPointerException e) {
//         //
//         // no message in exception (getMessage() returned null)
//         //
//         verifyException("com.google.common.base.Preconditions", e);
//      }
  }

  @Test(timeout = 4000)
  public void test004()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = Node.newString("", 1, 1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = null;
//      try {
        typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
//        fail("Expecting exception: NullPointerException");
      
//      } catch(NullPointerException e) {
//         //
//         // no message in exception (getMessage() returned null)
//         //
//         verifyException("com.google.javascript.jscomp.Compiler", e);
//      }
  }

  @Test(timeout = 4000)
  public void test005()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(32, 32, 32);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH", "JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH", "JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(100);
      // Undeclared exception!
//      try { 
        typeInference0.flowThrough(node2, linkedFlowScope0);
//        fail("Expecting exception: NullPointerException");
      
//      } catch(NullPointerException e) {
//         //
//         // no message in exception (getMessage() returned null)
//         //
//         verifyException("com.google.javascript.jscomp.TypeInference", e);
//      }
  }

  @Test(timeout = 4000)
  public void test006()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(13, 13, 13);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.gogle.javascript.jscomp.TypeInference$TemplteTypeReplacer", "Z)9!r6", "com.gogle.javascript.jscomp.TypeInference$TemplteTypeReplacer");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(15, node0, node0, 118, 220);
      // Undeclared exception!
//      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
//        fail("Expecting exception: IllegalArgumentException");
      
//      } catch(IllegalArgumentException e) {
//         //
//         // LE 118 : boolean does not exist in graph
//         //
//         verifyException("com.google.javascript.jscomp.graph.Graph", e);
//      }
  }

  @Test(timeout = 4000)
  public void test007()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(30);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer", "com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer", "com.google.javascript.jscomp.TypeInference$2");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createGlobalScope(node1);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
//      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
//        fail("Expecting exception: NullPointerException");
      
//      } catch(NullPointerException e) {
//         //
//         // no message in exception (getMessage() returned null)
//         //
//         verifyException("com.google.javascript.jscomp.TypeInference", e);
//      }
  }

  @Test(timeout = 4000)
  public void test008()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(140);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("%yyYU1/&F[|@k6T", "nG3H", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH");
      compiler0.parse(sourceFile0);
      Node node1 = new Node(49, node0, node0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
//      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
//        fail("Expecting exception: IllegalArgumentException");
      
//      } catch(IllegalArgumentException e) {
//         //
//         // THROW does not exist in graph
//         //
//         verifyException("com.google.javascript.jscomp.graph.Graph", e);
//      }
  }

  @Test(timeout = 4000)
  public void test009()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(102);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("yw3((K$$7c=U]Yh{&", "P(!,8kxA\"Cf", "Ff");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test010()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(46);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer", "com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer", "com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test011()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(101);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("yw3((K$$7c=U]Yh{&", "P(!,8kxA\"Cf", "Ff");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
//      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
//        fail("Expecting exception: NullPointerException");
      
//      } catch(NullPointerException e) {
//         //
//         // no message in exception (getMessage() returned null)
//         //
//         verifyException("com.google.javascript.jscomp.TypeInference", e);
//      }
  }

  @Test(timeout = 4000)
  public void test012()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(61);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer", "LP", "com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer");
      compiler0.parse(sourceFile0);
      node0.addChildToBack(node0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test013()  throws Throwable  {
      Node node0 = new Node(1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer", "Z)9!r6", "com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(32, node0, node0, 43, 2367);
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("ILb@FeC<UY}MZ?'jpY");
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of("prototype", codingConvention_AssertionFunctionSpec0, "com.google.common.collect.Lists$RandomAccessListWrapper", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test014()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
      BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
      assertSame(booleanLiteralSet0, booleanLiteralSet1);
  }

  @Test(timeout = 4000)
  public void test015()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(129, 129, 129);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      Node node1 = compiler0.parseSyntheticCode("J_HIDDENINERFCE_PROPERTYMMATCH", "J_HIDDENINERFCE_PROPERTYMMATCH");
      Scope scope0 = Scope.createGlobalScope(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      node0.setType(51);
      Node node2 = new Node(30, node0, 39, (-2687));
      // Undeclared exception!
//      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
//        fail("Expecting exception: IllegalArgumentException");
      
//      } catch(IllegalArgumentException e) {
//         //
//         // NEW does not exist in graph
//         //
//         verifyException("com.google.javascript.jscomp.graph.Graph", e);
//      }
  }

  @Test(timeout = 4000)
  public void test016()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(37);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.common.collect.CollectPreconditions", "com.google.common.collect.CollectPreconditions", "msg.not.ctor");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test017()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(154, 154, 154);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(4);
      // Undeclared exception!
//      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
//        fail("Expecting exception: IllegalArgumentException");
      
//      } catch(IllegalArgumentException e) {
//         //
//         // RETURN does not exist in graph
//         //
//         verifyException("com.google.javascript.jscomp.graph.Graph", e);
//      }
  }

  @Test(timeout = 4000)
  public void test018()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(153, 253, 129);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = (LinkedFlowScope)typeInference0.createInitialEstimateLattice();
      LinkedFlowScope linkedFlowScope1 = new LinkedFlowScope(linkedFlowScope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope1);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test019()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(152, 152, 152);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer", "com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer", "com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer");
      compiler0.parse(sourceFile0);
      node0.addChildToBack(node0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test020()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(6, 6, 6);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JSC_HIDDEN_INTERFACE_PROPETY_MISMATCH", "JSC_HIDDEN_INTERFACE_PROPETY_MISMATCH", "");
      Node node1 = compiler0.parse(sourceFile0);
      node1.addChildToBack(node0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(149, node1, node1, 18, 47);
      // Undeclared exception!
//      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
//        fail("Expecting exception: IllegalArgumentException");
      
//      } catch(IllegalArgumentException e) {
//         //
//         // CONST 18 does not exist in graph
//         //
//         verifyException("com.google.javascript.jscomp.graph.Graph", e);
//      }
  }

  @Test(timeout = 4000)
  public void test021()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(13, 13, 13);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.gogle.javascript.jscomp.TypeInference$TemplteTypeReplacer", "Z)9!r6", "com.gogle.javascript.jscomp.TypeInference$TemplteTypeReplacer");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      Node node2 = new Node(148);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test022()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(6, 6, 6);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromFile("Zno^a^]yE");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(147);
      // Undeclared exception!
//      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
//        fail("Expecting exception: IllegalArgumentException");
      
//      } catch(IllegalArgumentException e) {
//         //
//         // GETTER_DEF does not exist in graph
//         //
//         verifyException("com.google.javascript.jscomp.graph.Graph", e);
//      }
  }

  @Test(timeout = 4000)
  public void test023()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(72);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer", "com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer", "com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createGlobalScope(node1);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      Node node2 = new Node(146);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test024()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(145, 145, 145);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JS_HIDDEN_IERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_IERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_IERFACE_PROPERTY_MIMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createGlobalScope(node1);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test025()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(144);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JS_HIDvEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDvEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDvEN_INERFACE_PROPERTY_MIMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test026()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(102);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("yw3((K$$7c=U]Yh{&", "P(!,8kxA\"Cf", "Ff");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(143, node1, node0, 57, 1070);
      // Undeclared exception!
//      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
//        fail("Expecting exception: IllegalStateException");
      
//      } catch(IllegalStateException e) {
//         //
//         // 143
//         //
//         verifyException("com.google.javascript.rhino.Token", e);
//      }
  }

  @Test(timeout = 4000)
  public void test027()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(142, 142, 142);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("XS_HIDDEN_INERFACE_zROPERTY_MIMATCH", "XS_HIDDEN_INERFACE_zROPERTY_MIMATCH", "XS_HIDDEN_INERFACE_zROPERTY_MIMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test028()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(141);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.DefaultPassConfig$70", "com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer", "com.google.javascript.jscomp.DefaultPassConfig$70");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createGlobalScope(node1);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test029()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(114);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(138);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test030()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(137);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test031()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(108, 108, 123);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromFile("Zno^a^]yE");
      Node node1 = compiler0.parse(sourceFile0);
      node1.addChildToBack(node0);
      Scope scope0 = Scope.createGlobalScope(node1);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      Node node2 = new Node(135);
      // Undeclared exception!
//      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
//        fail("Expecting exception: IllegalStateException");
      
//      } catch(IllegalStateException e) {
//         //
//         // 135
//         //
//         verifyException("com.google.javascript.rhino.Token", e);
//      }
  }

  @Test(timeout = 4000)
  public void test032()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(133);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test033()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(140);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JS_HIDvEN_IeERFACE_PROPERTYyMIMdTCH", "JS_HIDvEN_IeERFACE_PROPERTYyMIMdTCH", "JS_HIDvEN_IeERFACE_PROPERTYyMIMdTCH");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createGlobalScope(node1);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      Node node2 = new Node(131);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      // Undeclared exception!
//      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
//        fail("Expecting exception: IllegalStateException");
      
//      } catch(IllegalStateException e) {
//         //
//         // 131
//         //
//         verifyException("com.google.javascript.rhino.Token", e);
//      }
  }

  @Test(timeout = 4000)
  public void test034()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(128);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test035()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(127, 127, 127);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JS_HIDDEN_IERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_IERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_IERFACE_PROPERTY_MIMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createGlobalScope(node1);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test036()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(6, 6, 6);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JSC_HIDDEN_INTERFACE_PROPETY_MISMATCH", "JSC_HIDDEN_INTERFACE_PROPETY_MISMATCH", "Ff");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(126, node1, node1, 42, 47);
      // Undeclared exception!
//      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
//        fail("Expecting exception: IllegalArgumentException");
      
//      } catch(IllegalArgumentException e) {
//         //
//         // LABEL 42 does not exist in graph
//         //
//         verifyException("com.google.javascript.jscomp.graph.Graph", e);
//      }
  }

  @Test(timeout = 4000)
  public void test037()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(114);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(125);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test038()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(124);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer", "Z)9!r6", "com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test039()  throws Throwable  {
      Node node0 = new Node(123, 145, 145);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference$BooleanOutcomePair", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair", "JS_HIDDEN_IERFACE_PROPERTY_MIM,TCH");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createGlobalScope(node1);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test040()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(6, 6, 6);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JSC_HIDDEN_INTERFACE_PROPETY_MISMATCH", "JSC_HIDDEN_INTERFACE_PROPETY_MISMATCH", "");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(121);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test041()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = Node.newString(12, "", 12, 12);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInfeence$TemplateTypeReplacer", "", "");
      Node node1 = compiler0.parse(sourceFile0);
      node1.addChildToBack(node0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(120);
      // Undeclared exception!
//      try { 
        typeInference0.flowThrough(node2, linkedFlowScope0);
//        fail("Expecting exception: NullPointerException");
      
//      } catch(NullPointerException e) {
//         //
//         // no message in exception (getMessage() returned null)
//         //
//         verifyException("com.google.javascript.jscomp.TypeInference", e);
//      }
  }

  @Test(timeout = 4000)
  public void test042()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(1, 1, 1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.gogle.javascript.jscomp.TypeInference$TemplteTypeReplacer", "Z)9!r6", "com.gogle.javascript.jscomp.TypeInference$TemplteTypeReplacer");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      Node node2 = new Node(118, node0, node0, 16, 37);
      // Undeclared exception!
//      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
//        fail("Expecting exception: IllegalArgumentException");
      
//      } catch(IllegalArgumentException e) {
//         //
//         // VAR 16 does not exist in graph
//         //
//         verifyException("com.google.javascript.jscomp.graph.Graph", e);
//      }
  }

  @Test(timeout = 4000)
  public void test043()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = Node.newString(26, "", 26, 26);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("crm.google.javascript.scrmp.TypeInferece$TemplateTypeReplacer", "", "");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      Node node2 = new Node(117);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test044()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(116);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.DefaultPassConfig$88", "Z)9!r6", "com.google.javascript.jscomp.DefaultPassConfig$88");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test045()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(115);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test046()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(114);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test047()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(113);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JS_HIDDEN_INERFACE_PROPERYY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERYY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERYY_MIMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createGlobalScope(node1);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test048()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(6);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JSC_HIDDEN_INTERFACE_PROPETY_MISMATCH", "JSC_HIDDEN_INTERFACE_PROPETY_MISMATCH", "JSC_HIDDEN_INTERFACE_PROPETY_MISMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      Node node2 = new Node(112);
      ExploitAssigns exploitAssigns0 = new ExploitAssigns();
      Node node3 = exploitAssigns0.optimizeSubtree(node2);
      FlowScope flowScope0 = typeInference1.createInitialEstimateLattice();
      // Undeclared exception!
//      try { 
        typeInference0.branchedFlowThrough(node3, flowScope0);
//        fail("Expecting exception: IllegalArgumentException");
      
//      } catch(IllegalArgumentException e) {
//         //
//         // DEFAULT_CASE does not exist in graph
//         //
//         verifyException("com.google.javascript.jscomp.graph.Graph", e);
//      }
  }

  @Test(timeout = 4000)
  public void test049()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(66, 66, 66);
      Node node1 = new Node(111, (-55), 60);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer", "com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer", "com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer");
      Node node2 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createGlobalScope(node2);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
//      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
//        fail("Expecting exception: IllegalArgumentException");
      
//      } catch(IllegalArgumentException e) {
//         //
//         // CASE does not exist in graph
//         //
//         verifyException("com.google.javascript.jscomp.graph.Graph", e);
//      }
  }

  @Test(timeout = 4000)
  public void test050()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(110);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test051()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(151, 151, 151);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      CodingConvention codingConvention0 = compiler0.getCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(codingConvention0, (JSTypeRegistry) null);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(109, node1, node0, 49, 12);
      // Undeclared exception!
//      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
//        fail("Expecting exception: IllegalStateException");
      
//      } catch(IllegalStateException e) {
//         //
//         // 109
//         //
//         verifyException("com.google.javascript.rhino.Token", e);
//      }
  }

  @Test(timeout = 4000)
  public void test052()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(108, 108, 108);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JS_HIDDEN_IERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_IERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_IERFACE_PROPERTY_MIMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createGlobalScope(node1);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test053()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(107, 107, 107);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JS_HIDDEN_IERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_IERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_IERFACE_PROPERTY_MIMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createGlobalScope(node1);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test054()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(1, 1, 1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer", "Z)9!r6", "com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      Node node2 = new Node(106, node0, node0, 1, 38);
      // Undeclared exception!
//      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
//        fail("Expecting exception: IllegalStateException");
      
//      } catch(IllegalStateException e) {
//         //
//         // 106
//         //
//         verifyException("com.google.javascript.rhino.Token", e);
//      }
  }

  @Test(timeout = 4000)
  public void test055()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(105);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer", "Z)9!r6", "com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test056()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(103);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test057()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(97);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test058()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(96);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createGlobalScope(node1);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test059()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(94);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer", "com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer", "com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test060()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(75);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH");
      compiler0.parse(sourceFile0);
      node0.addChildToBack(node0);
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(93, 4, 141);
      // Undeclared exception!
//      try { 
        typeInference0.flowThrough(node1, linkedFlowScope0);
//        fail("Expecting exception: NullPointerException");
      
//      } catch(NullPointerException e) {
//         //
//         // no message in exception (getMessage() returned null)
//         //
//         verifyException("com.google.javascript.jscomp.TypeInference", e);
//      }
  }

  @Test(timeout = 4000)
  public void test061()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(92);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer", "com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer", "com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test062()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(6, 6, 6);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromFile("Zno^a^]yE");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createGlobalScope(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(91);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test063()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(89);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test064()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(87);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javscript.rscomp.Typenfe08nce$TemplateTyeReplcer", "com.google.javscript.rscomp.Typenfe08nce$TemplateTyeReplcer", "com.google.javscript.rscomp.Typenfe08nce$TemplateTyeReplcer");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test065()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(85);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer", "com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer", "com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createGlobalScope(node1);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
//      try { 
        typeInference0.flowThrough(node0, linkedFlowScope0);
//        fail("Expecting exception: NullPointerException");
      
//      } catch(NullPointerException e) {
//         //
//         // no message in exception (getMessage() returned null)
//         //
//         verifyException("com.google.javascript.jscomp.TypeInference", e);
//      }
  }

  @Test(timeout = 4000)
  public void test066()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(84, 84, 84);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer", "com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer", "com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test067()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(82);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH");
      compiler0.parse(sourceFile0);
      node0.addChildToBack(node0);
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test068()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(6, 6, 6);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromFile("Zno^a^]yE");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createGlobalScope(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(81);
      // Undeclared exception!
//      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
//        fail("Expecting exception: IllegalStateException");
      
//      } catch(IllegalStateException e) {
//         //
//         // 81
//         //
//         verifyException("com.google.javascript.rhino.Token", e);
//      }
  }

  @Test(timeout = 4000)
  public void test069()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(80);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer", "com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer", "com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test070()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(79, 79, 79);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JS_HIDDEN_INERFAAE_POPERTY_MMMATCH", "JS_HIDDEN_INERFAAE_POPERTY_MMMATCH", "JS_HIDDEN_INERFAAE_POPERTY_MMMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test071()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(78, 78, 78);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JS_HIDDEN_INERFAAE_POPERTY_MMMATCH", "JS_HIDDEN_INERFAAE_POPERTY_MMMATCH", "JS_HIDDEN_INERFAAE_POPERTY_MMMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test072()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(114);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(77, node0, 36, 55);
      // Undeclared exception!
//      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
//        fail("Expecting exception: IllegalArgumentException");
      
//      } catch(IllegalArgumentException e) {
//         //
//         // TRY 36 does not exist in graph
//         //
//         verifyException("com.google.javascript.jscomp.graph.Graph", e);
//      }
  }

  @Test(timeout = 4000)
  public void test073()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(75, 75, 75);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test074()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(73);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("prototype", "prototype", "prototype");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test075()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(72);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer", "com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer", "com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createGlobalScope(node1);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test076()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(69);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("tC", "tC", "tC");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createGlobalScope(node1);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test077()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(66, 66, 66);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("WA", "j+GU\"7{Bbe gIr6~7", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test078()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(65);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer", "LP", "com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer");
      compiler0.parse(sourceFile0);
      node0.addChildToBack(node0);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test079()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(64);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
//      try { 
        typeInference0.flowThrough(node0, linkedFlowScope0);
//        fail("Expecting exception: NullPointerException");
      
//      } catch(NullPointerException e) {
//         //
//         // no message in exception (getMessage() returned null)
//         //
//         verifyException("com.google.common.base.Preconditions", e);
//      }
  }

  @Test(timeout = 4000)
  public void test080()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(61);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("prototype", "prototype", "prototype");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(155, node1, node0, node1, node0, 37, 1);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test081()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(58, 58, 58);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JS_HIDDEN_INERFAAE_POPERTY_MMMATCH", "JS_HIDDEN_INERFAAE_POPERTY_MMMATCH", "JS_HIDDEN_INERFAAE_POPERTY_MMMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test082()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(110);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(57);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test083()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(6, 6, 6);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromFile("no^a^S]ZyE");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(56);
      // Undeclared exception!
//      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
//        fail("Expecting exception: IllegalStateException");
      
//      } catch(IllegalStateException e) {
//         //
//         // 56
//         //
//         verifyException("com.google.javascript.rhino.Token", e);
//      }
  }

  @Test(timeout = 4000)
  public void test084()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(1, 1, 1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer", "Z)9!r6", "com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      Node node2 = new Node(55, node0, node0, 55, 52);
      // Undeclared exception!
//      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
//        fail("Expecting exception: IllegalStateException");
      
//      } catch(IllegalStateException e) {
//         //
//         // 55
//         //
//         verifyException("com.google.javascript.rhino.Token", e);
//      }
  }

  @Test(timeout = 4000)
  public void test085()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = Node.newString("", 26, 26);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer", "", "");
      compiler0.parse(sourceFile0);
      Node node1 = new Node(54);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test086()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(124, 124, 124);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
      Node node1 = compiler0.parse(sourceFile0);
      Node node2 = new Node(53, node1, node0);
      Scope scope0 = Scope.createLatticeBottom(node2);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, false, false);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test087()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = Node.newString(26, "", 26, 26);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer", "", "");
      Node node1 = compiler0.parse(sourceFile0);
      Node node2 = new Node(52, node1, 30, 12);
      node0.addChildToBack(node2);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test088()  throws Throwable  {
      Node node0 = new Node(140);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("N$Wo0K>;`vVUo?N9 ", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("N$Wo0K>;`vVUo?N9 ");
      ImmutableBiMap<String, CodingConvention.AssertionFunctionSpec> immutableBiMap0 = ImmutableBiMap.of("JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", codingConvention_AssertionFunctionSpec0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableBiMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(50);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test089()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(140, 140, 140);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("%yyYU1/&F[|@k6T", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      Node node2 = new Node(49, node0, node0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node2, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test090()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(48, 48, 48);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer", "com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer", "com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test091()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = Node.newString("");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("4,>,:Y@j;DUW]kZF!", "", "");
      compiler0.parse(sourceFile0);
      Node node1 = new Node(47, node0, (-2962), 4);
      Scope scope0 = Scope.createLatticeBottom(node1);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
//      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
//        fail("Expecting exception: IllegalArgumentException");
      
//      } catch(IllegalArgumentException e) {
//         //
//         // REGEXP does not exist in graph
//         //
//         verifyException("com.google.javascript.jscomp.graph.Graph", e);
//      }
  }

  @Test(timeout = 4000)
  public void test092()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(45, 45, 45);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer", "com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer", "com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test093()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(44, 44, 44);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("WA", "j+GU\"7{Bbe gIr6~7", "JS_HIDDEN_INERFACE_PROPERTY_MIMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test094()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(105);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("prototype", "prototype", "ASSIGN_MOD");
      Node node1 = compiler0.parse(sourceFile0);
      Node node2 = new Node(43, node1, (-294), 308);
      node0.addChildToBack(node2);
      Scope scope0 = Scope.createGlobalScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
//      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
//        fail("Expecting exception: IllegalArgumentException");
      
//      } catch(IllegalArgumentException e) {
//         //
//         // FALSE does not exist in graph
//         //
//         verifyException("com.google.javascript.jscomp.graph.Graph", e);
//      }
  }

  @Test(timeout = 4000)
  public void test095()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(124, 124, 124);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JS_HIDDEN_IERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_IERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_IERFACE_PROPERTY_MIMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createGlobalScope(node1);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(42, node1, node0, node1, node0);
      // Undeclared exception!
//      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
//        fail("Expecting exception: IllegalArgumentException");
      
//      } catch(IllegalArgumentException e) {
//         //
//         // THIS does not exist in graph
//         //
//         verifyException("com.google.javascript.jscomp.graph.Graph", e);
//      }
  }

  @Test(timeout = 4000)
  public void test096()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(41);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("prototype", "prototype", "prototype");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test097()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = Node.newString("Oa", 1, 1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer", "5T", "com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer");
      compiler0.parse(sourceFile0);
      Node node1 = Node.newNumber(1346.1586460786);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      // Undeclared exception!
//      try { 
        typeInference1.branchedFlowThrough(node1, flowScope0);
//        fail("Expecting exception: IllegalArgumentException");
      
//      } catch(IllegalArgumentException e) {
//         //
//         // NUMBER 1346.1586460786 does not exist in graph
//         //
//         verifyException("com.google.javascript.jscomp.graph.Graph", e);
//      }
  }

  @Test(timeout = 4000)
  public void test098()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = Node.newString("Oa", 1, 1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer", "5T", "com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer");
      Node node1 = compiler0.parse(sourceFile0);
      Node node2 = new Node(38, node1, 40, 1);
      node0.addChildToBack(node2);
      Scope scope0 = Scope.createLatticeBottom(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableSortedMap0);
      // Undeclared exception!
//      try { 
        typeInference1.branchedFlowThrough(node2, flowScope0);
//        fail("Expecting exception: UnsupportedOperationException");
      
//      } catch(UnsupportedOperationException e) {
//         //
//         // NAME 40 is not a string node
//         //
//         verifyException("com.google.javascript.rhino.Node", e);
//      }
  }

  @Test(timeout = 4000)
  public void test099()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(145, 145, 145);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("JS_HIDDEN_IERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_IERFACE_PROPERTY_MIMATCH", "JS_HIDDEN_IERFACE_PROPERTY_MIMATCH");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createGlobalScope(node1);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(37);
      // Undeclared exception!
//      try { 
        typeInference0.flowThrough(node2, linkedFlowScope0);
//        fail("Expecting exception: NullPointerException");
      
//      } catch(NullPointerException e) {
//         //
//         // no message in exception (getMessage() returned null)
//         //
//         verifyException("com.google.javascript.jscomp.TypeInference", e);
//      }
  }

  @Test(timeout = 4000)
  public void test100()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(105);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("1I|%_wVsE^E\"N~}E5", "Z)9!r6", "ASSIGN_MOD");
      compiler0.parse(sourceFile0);
      Node node1 = new Node(36, node0, 48, (-2482));
      Scope scope0 = Scope.createGlobalScope(node1);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
//      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
//        fail("Expecting exception: IllegalStateException");
      
//      } catch(IllegalStateException e) {
//         //
//         // 36
//         //
//         verifyException("com.google.javascript.rhino.Token", e);
//      }
  }

  @Test(timeout = 4000)
  public void test101()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = Node.newString(34, "", 34, 34);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("crm.google.javascript.scrmp.TypeInferece$TemplateTypeReplacer", "", "");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test102()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(23);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromCode("com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer", "com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer", "com.google.javscript.rscomp.Typenfe0ence$TemplateTyeReplcer");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      Node node2 = new Node(32, node0, node0, 43, 48);
      // Undeclared exception!
//      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
//        fail("Expecting exception: IllegalArgumentException");
      
//      } catch(IllegalArgumentException e) {
//         //
//         // TYPEOF 43 : string does not exist in graph
//         //
//         verifyException("com.google.javascript.jscomp.graph.Graph", e);
//      }
  }

  @Test(timeout = 4000)
  public void test103()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(134, 134, 134);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Compiler compiler0 = new Compiler();
      ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_EX;
      controlFlowGraph0.connectIfNotFound(node0, controlFlowGraph_Branch0, node0);
      SourceFile sourceFile0 = SourceFile.fromCode(">", ">", "com.google.javascript.jscomp.TypeInference$2");
      Node node1 = compiler0.parse(sourceFile0);
      Scope scope0 = Scope.createLatticeBottom(node1);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertEquals(1, list0.size());
  }

  @Test(timeout = 4000)
  public void test104()  throws Throwable  {
      ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
      Node node0 = new Node(6, 6, 6);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
      Compiler compiler0 = new Compiler();
      SourceFile sourceFile0 = SourceFile.fromFile("Zo^a^2(]yE");
      Node node1 = compiler0.parse(sourceFile0);
      node0.addChildToBack(node1);
      Scope scope0 = Scope.createLatticeBottom(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableSortedMap0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node2 = new Node(86);
      // Undeclared exception!
//      try { 
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
//        fail("Expecting exception: NullPointerException");
      
//      } catch(NullPointerException e) {
//         //
//         // no message in exception (getMessage() returned null)
//         //
//         verifyException("com.google.javascript.jscomp.TypeInference", e);
//      }
  }
}
